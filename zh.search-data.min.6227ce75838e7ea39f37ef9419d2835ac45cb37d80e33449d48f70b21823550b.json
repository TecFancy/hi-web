[{"id":0,"href":"/docs/javascript/2/2.1/","title":"\u003cscript\u003e 元素","section":"HTML 中的 JavaScript","content":"\u0026lt;script\u0026gt; 元素 #  将 JavaScript 插入 HTML 的主要方法是使用元素。这个元素是由网景公司创造出来，并最早在 Netscape Navigator 2 中实现的。后来，这个元素被正式加入到 HTML 规范。元素有下列 8 个属性。\n async：可选。表示应该立即开始下载脚本，但不能阻止其他页面动作，比如下载资源或等待其他脚本加载。只对外部脚本文件有效。 charset：可选。使用 src 属性指定的代码字符集。这个属性很少使用，因为大多数浏览器不在乎它的值。 crossorigin：可选。配置相关请求的 CORS（跨源资源共享）设置。默认不使用 CORS。crossorigin=\u0026ldquo;anonymous\u0026quot;配置文件请求不必设置凭据标志。crossorigin=\u0026ldquo;use-credentials\u0026quot;设置凭据标志，意味着出站请求会包含凭据。 defer：可选。表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。在 IE7 及更早的版本中，对行内脚本也可以指定这个属性。 integrity：可选。允许比对接收到的资源和指定的加密签名以验证子资源完整性（SRI，Subresource Integrity）。如果接收到的资源的签名与这个属性指定的签名不匹配，则页面会报错，脚本不会执行。这个属性可以用于确保内容分发网络（CDN，Content Delivery Network）不会提供恶意内容。 language：废弃。最初用于表示代码块中的脚本语言（如\u0026quot;JavaScript\u0026rdquo;、\u0026ldquo;JavaScript 1.2\u0026quot;或\u0026quot;VBScript\u0026rdquo;）。大多数浏览器都会忽略这个属性，不应该再使用它。 src：可选。表示包含要执行的代码的外部文件。 type：可选。代替 language，表示代码块中脚本语言的内容类型（也称 MIME 类型）。按照惯例，这个值始终都是\u0026quot;text/javascript\u0026rdquo;，尽管\u0026quot;text/javascript\u0026quot;和\u0026quot;text/ecmascript\u0026quot;都已经废弃了。JavaScript 文件的 MIME 类型通常是\u0026quot;application/x-javascript\u0026quot;，不过给 type 属性这个值有可能导致脚本被忽略。在非 IE 的浏览器中有效的其他值还有\u0026quot;application/javascript\u0026quot;和\u0026quot;application/ecmascript\u0026quot;。如果这个值是 module，则代码会被当成 ES6 模块，而且只有这时候代码中才能出现 import 和 export 关键字。  使用 \u0026lt;script\u0026gt; 的方式有两种：通过它直接在网页中嵌入 JavaScript 代码，以及通过它在网页中包含外部 JavaScript 文件。\n要嵌入行内 JavaScript 代码，直接把代码放在 \u0026lt;script\u0026gt; 元素中就行：\n\u0026lt;script\u0026gt; function sayHi() { console.log(\u0026#34;Hi!\u0026#34;); } \u0026lt;/script\u0026gt; 包含在 \u0026lt;script\u0026gt; 内的代码会被从上到下解释。在上面的例子中，被解释的是一个函数定义，并且该函数会被保存在解释器环境中。在 \u0026lt;script\u0026gt; 元素中的代码被计算完成之前，页面的其余内容不会被加载，也不会被显示。\n在使用行内 JavaScript 代码时，要注意代码中不能出现字符串 \u0026lt;/script\u0026gt;。比如，下面的代码会导致浏览器报错：\n\u0026lt;script\u0026gt; function sayScript() { console.log(\u0026#34;\u0026lt;/script\u0026gt;\u0026#34;); } \u0026lt;/script\u0026gt; 浏览器解析行内脚本的方式决定了它在看到字符串 \u0026lt;/script\u0026gt; 时，会将其当成结束的 \u0026lt;/script\u0026gt; 标签。想避免这个问题，只需要转义字符“\\”1 即可：\n\u0026lt;script\u0026gt; function sayScript() { console.log(\u0026#34;\u0026lt;\\/script\u0026gt;\u0026#34;); } \u0026lt;/script\u0026gt; 这样修改之后，代码就可以被浏览器完全解释，不会导致任何错误。\n要包含外部文件中的 JavaScript，就必须使用 src 属性。这个属性的值是一个 URL，指向包含 JavaScript 代码的文件，比如：\n\u0026lt;script src=\u0026#34;example.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 这个例子在页面中加载了一个名为 example.js 的外部文件。文件本身只需包含要放在 \u0026lt;script\u0026gt; 的起始及结束标签中间的 JavaScript 代码。与解释行内 JavaScript 一样，在解释外部 JavaScript 文件时，页面也会阻塞。（阻塞时间也包含下载文件的时间。）在 XHTML 文档中，可以忽略结束标签，比如：\n\u0026lt;script src=\u0026#34;example.js\u0026#34; /\u0026gt; 以上语法不能在 HTML 文件中使用，因为它是无效的 HTML，有些浏览器不能正常处理，比如 IE。\n注意 按照惯例，外部 JavaScript 文件的扩展名是.js。这不是必需的，因为浏览器不会检查所包含 JavaScript 文件的扩展名。这就为使用服务器端脚本语言动态生成 JavaScript 代码，或者在浏览器中将 JavaScript 扩展语言（如 TypeScript，或 React 的 JSX）转译为 JavaScript 提供了可能性。不过要注意，服务器经常会根据文件扩展来确定响应的正确 MIME 类型。如果不打算使用.js 扩展名，一定要确保服务器能返回正确的 MIME 类型。  另外，使用了 src 属性的 \u0026lt;script\u0026gt; 元素不应该再在 \u0026lt;script\u0026gt; 和 \u0026lt;/script\u0026gt; 标签中再包含其他 JavaScript 代码。如果两者都提供的话，则浏览器只会下载并执行脚本文件，从而忽略行内代码。\n\u0026lt;script\u0026gt; 元素的一个最为强大、同时也备受争议的特性是，它可以包含来自外部域的 JavaScript 文件。跟 \u0026lt;img\u0026gt; 元素很像，\u0026lt;script\u0026gt; 元素的 src 属性可以是一个完整的 URL，而且这个 URL 指向的资源可以跟包含它的 HTML 页面不在同一个域中，比如这个例子：\n\u0026lt;script src=\u0026#34;http://www.somewhere.com/afile.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 浏览器在解析这个资源时，会向 src 属性指定的路径发送一个 GET 请求，以取得相应资源，假定是一个 JavaScript 文件。这个初始的请求不受浏览器同源策略限制，但返回并被执行的 JavaScript 则受限制。当然，这个请求仍然受父页面 HTTP/HTTPS 协议的限制。\n来自外部域的代码会被当成加载它的页面的一部分来加载和解释。这个能力可以让我们通过不同的域分发 JavaScript。不过，引用了放在别人服务器上的 JavaScript 文件时要格外小心，因为恶意的程序员随时可能替换这个文件。在包含外部域的 JavaScript 文件时，要确保该域是自己所有的，或者该域是一个可信的来源。\u0026lt;script\u0026gt; 标签的 integrity 属性是防范这种问题的一个武器，但这个属性也不是所有浏览器都支持。\n不管包含的是什么代码，浏览器都会按照 \u0026lt;script\u0026gt; 在页面中出现的顺序依次解释它们，前提是它们没有使用 defer 和 async 属性。第二个 \u0026lt;script\u0026gt; 元素的代码必须在第一个 \u0026lt;script\u0026gt; 元素的代码解释完毕才能开始解释，第三个则必须等第二个解释完，以此类推。\n标签占位符 #  过去，所有 \u0026lt;script\u0026gt; 元素都被放在页面的 \u0026lt;head\u0026gt; 标签内，如下面的例子所示：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Example HTML Page\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;example1.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;example2.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 这里是页面内容 --\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 这种做法的主要目的是把外部的 CSS 和 JavaScript 文件都集中放到一起。不过，把所有 JavaScript 文件都放在 \u0026lt;head\u0026gt; 里，也就意味着必须把所有 JavaScript 代码都下载、解析和解释完成后，才能开始渲染页面（页面在浏览器解析到 \u0026lt;body\u0026gt; 的起始标签时开始渲染）。对于需要很多 JavaScript 的页面，这会导致页面渲染的明显延迟，在此期间浏览器窗口完全空白。为解决这个问题，现代 Web 应用程序通常将所有 JavaScript 引用放在 \u0026lt;body\u0026gt; 元素中的页面内容后面，如下面的例子所示：\n这样一来，页面会在处理 JavaScript 代码之前完全渲染页面。用户会感觉页面加载更快了，因为浏览器显示空白页面的时间短了。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Example HTML Page\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 这里是页面内容 --\u0026gt; \u0026lt;script src=\u0026#34;example1.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;example2.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 推迟执行脚本 #  HTML 4.01 为 \u0026lt;script\u0026gt; 元素定义了一个叫 defer 的属性。这个属性表示脚本在执行的时候不会改变页面的结构。也就是说，脚本会被延迟到整个页面都解析完毕后再运行。因此，在 \u0026lt;script\u0026gt; 元素中设置 defer 属性，相当于告诉浏览器立即下载，但延迟执行。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Example HTML Page\u0026lt;/title\u0026gt; \u0026lt;script defer src=\u0026#34;example1.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script defer src=\u0026#34;example2.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 这里是页面内容 --\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 虽然这个例子中的 \u0026lt;script\u0026gt; 元素包含在页面的 \u0026lt;head\u0026gt; 中，但它们会在浏览器解析到结束的 \u0026lt;/html\u0026gt; 标签后才会执行。HTML5 规范要求脚本应该按照它们出现的顺序执行，因此第一个推迟的脚本会在第二个推迟的脚本之前执行，而且两者都会在 DOMContentLoaded 事件之前执行（关于事件，请参考第 17 章）。不过在实际当中，推迟执行的脚本不一定总会按顺序执行或者在 DOMContentLoaded 事件之前执行，因此最好只包含一个这样的脚本。\n如前所述，defer 属性只对外部脚本文件才有效。这是 HTML5 中明确规定的，因此支持 HTML5 的浏览器会忽略行内脚本的 defer 属性。IE4~7 展示出的都是旧的行为，IE8 及更高版本则支持 HTML5 定义的行为。\n对 defer 属性的支持是从 IE4、Firefox 3.5、Safari 5 和 Chrome 7 开始的。其他所有浏览器则会忽略这个属性，按照通常的做法来处理脚本。考虑到这一点，还是把要推迟执行的脚本放在页面底部比较好。\n注意 对于 XHTML 文档，指定 defer 属性时应该写成 defer=\u0026ldquo;defer\u0026rdquo;。  异步执行脚本 #  HTML5 为 \u0026lt;script\u0026gt; 元素定义了 async 属性。从改变脚本处理方式上看，async 属性与 defer 类似。当然，它们两者也都只适用于外部脚本，都会告诉浏览器立即开始下载。不过，与 defer 不同的是，标记为 async 的脚本并不保证能按照它们出现的次序执行，比如：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Example HTML Page\u0026lt;/title\u0026gt; \u0026lt;script async src=\u0026#34;example1.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script async src=\u0026#34;example2.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 这里是页面内容 --\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 在这个例子中，第二个脚本可能先于第一个脚本执行。因此，重点在于它们之间没有依赖关系。给脚本添加 async 属性的目的是告诉浏览器，不必等脚本下载和执行完后再加载页面，同样也不必等到该异步脚本下载和执行后再加载其他脚本。正因为如此，异步脚本不应该在加载期间修改 DOM。\n异步脚本保证会在页面的 load 事件前执行，但可能会在 DOMContentLoaded（参见第 17 章）之前或之后。Firefox 3.6、Safari 5 和 Chrome 7 支持异步脚本。使用 async 也会告诉页面你不会使用 document.write，不过好的 Web 开发实践根本就不推荐使用这个方法。\n注意 对于 XHTML 文档，指定 async 属性时应该写成 async=\u0026ldquo;async\u0026rdquo;。  动态加载脚本 #  除了 \u0026lt;script\u0026gt; 标签，还有其他方式可以加载脚本。因为 JavaScript 可以使用 DOM API，所以通过向 DOM 中动态添加 script 元素同样可以加载指定的脚本。只要创建一个 script 元素并将其添加到 DOM 即可。\nlet script = document.createElement(\u0026#34;script\u0026#34;); script.src = \u0026#34;gibberish.js\u0026#34;; document.head.appendChild(script); 当然，在把 HTMLElement 元素添加到 DOM 且执行到这段代码之前不会发送请求。默认情况下，以这种方式创建的 \u0026lt;script\u0026gt; 元素是以异步方式加载的，相当于添加了 async 属性。不过这样做可能会有问题，因为所有浏览器都支持 createElement()方法，但不是所有浏览器都支持 async 属性。因此，如果要统一动态脚本的加载行为，可以明确将其设置为同步加载：\nlet script = document.createElement(\u0026#34;script\u0026#34;); script.src = \u0026#34;gibberish.js\u0026#34;; script.async = false; document.head.appendChild(script); 以这种方式获取的资源对浏览器预加载器是不可见的。这会严重影响它们在资源获取队列中的优先级。根据应用程序的工作方式以及怎么使用，这种方式可能会严重影响性能。要想让预加载器知道这些动态请求文件的存在，可以在文档头部显式声明它们：\n\u0026lt;link rel=\u0026#34;preload\u0026#34; href=\u0026#34;gibberish.js\u0026#34; /\u0026gt; XHTML 中的变化 #  可扩展超文本标记语言（XHTML，Extensible HyperText Markup Language）是将 HTML 作为 XML 的应用重新包装的结果。与 HTML 不同，在 XHTML 中使用 JavaScript 必须指定 type 属性且值为 text/javascript，HTML 中则可以没有这个属性。XHTML 虽然已经退出历史舞台，但实践中偶尔可能也会遇到遗留代码，为此本节稍作介绍。\n在 XHTML 中编写代码的规则比 HTML 中严格，这会影响使用 \u0026lt;script\u0026gt; 元素嵌入 JavaScript 代码。下面的代码块虽然在 HTML 中有效，但在 XHML 中是无效的。\n\u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; function compare(a, b) { if (a \u0026lt; b) { console.log(\u0026#34;A is less than B\u0026#34;); } else if (a \u0026gt; b) { console.log(\u0026#34;A is greater than B\u0026#34;); } else { console.log(\u0026#34;A is equal to B\u0026#34;); } } \u0026lt;/script\u0026gt; 在 HTML 中，解析 \u0026lt;script\u0026gt; 元素会应用特殊规则。XHTML 中则没有这些规则。这意味着 a \u0026lt; b 语句中的小于号（\u0026lt;）会被解释成一个标签的开始，并且由于作为标签开始的小于号后面不能有空格，这会导致语法错误。\n避免 XHTML 中这种语法错误的方法有两种。第一种是把所有小于号（\u0026lt;）都替换成对应的 HTML 实体形式（\u0026lt;）。结果代码就是这样的：\n\u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; function compare(a, b) { if (a \u0026amp;lt; b) { console.log(\u0026#34;A is less than B\u0026#34;); } else if (a \u0026gt; b) { console.log(\u0026#34;A is greater than B\u0026#34;); } else { console.log(\u0026#34;A is equal to B\u0026#34;); } } \u0026lt;/script\u0026gt; 这样代码就可以在 XHTML 页面中运行了。不过，缺点是会影响阅读。好在还有另一种方法。\n第二种方法是把所有代码都包含到一个 CDATA 块中。在 XHTML（及 XML）中，CDATA 块表示文档中可以包含任意文本的区块，其内容不作为标签来解析，因此可以在其中包含任意字符，包括小于号，并且不会引发语法错误。使用 CDATA 的格式如下：\n\u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; \u0026lt;![CDATA[ function compare(a, b) { if (a \u0026lt; b) { console.log(\u0026#34;A is less than B\u0026#34;); } else if (a \u0026gt; b) { console.log(\u0026#34;A is greater than B\u0026#34;); } else { console.log(\u0026#34;A is equal to B\u0026#34;); } } ]]\u0026gt; \u0026lt;/script\u0026gt; 在兼容 XHTML 的浏览器中，这样能解决问题。但在不支持 CDATA 块的非 XHTML 兼容浏览器中则不行。为此，CDATA 标记必须使用 JavaScript 注释来抵消：\n\u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; //\u0026lt;![CDATA[  function compare(a, b) { if (a \u0026lt; b) { console.log(\u0026#34;A is less than B\u0026#34;); } else if (a \u0026gt; b) { console.log(\u0026#34;A is greater than B\u0026#34;); } else { console.log(\u0026#34;A is equal to B\u0026#34;); } } //]]\u0026gt; \u0026lt;/script\u0026gt; 这种格式适用于所有现代浏览器。虽然有点黑科技的味道，但它可以通过 XHTML 验证，而且对 XHTML 之前的浏览器也能优雅地降级。\n注意 XHTML 模式会在页面的 MIME 类型被指定为\u0026quot;application/xhtml+xml\u0026quot;时触发。并不是所有浏览器都支持以这种方式送达的 XHTML。  废弃的语法 #  自 1995 年 Netscape 2 发布以来，所有浏览器都将 JavaScript 作为默认的编程语言。type 属性使用一个 MIME 类型字符串来标识 \u0026lt;script\u0026gt; 的内容，但 MIME 类型并没有跨浏览器标准化。即使浏览器默认使用 JavaScript，在某些情况下某个无效或无法识别的 MIME 类型也可能导致浏览器跳过（不执行）相关代码。因此，除非你使用 XHTML 或 \u0026lt;script\u0026gt; 标签要求或包含非 JavaScript 代码，最佳做法是不指定 type 属性。\n在最初采用 script 元素时，它标志着开始走向与传统 HTML 解析不同的流程。对这个元素需要应用特殊的解析规则，而这在不支持 JavaScript 的浏览器（特别是 Mosaic）中会导致问题。不支持的浏览器会把 \u0026lt;script\u0026gt; 元素的内容输出到页面上，从而破坏页面的外观。\nNetscape 联合 Mosaic 拿出了一个解决方案，对不支持 JavaScript 的浏览器隐藏嵌入的 JavaScript 代码。最终方案是把脚本代码包含在一个 HTML 注释中，像这样：\n\u0026lt;script\u0026gt; \u0026lt;!-- function sayHi() { console.log(\u0026#34;Hi!\u0026#34;); } //--\u0026gt; \u0026lt;/script\u0026gt; 使用这种格式，Mosaic 等浏览器就可以忽略 \u0026lt;script\u0026gt; 标签中的内容，而支持 JavaScript 的浏览器则必须识别这种模式，将其中的内容作为 JavaScript 来解析。\n虽然这种格式仍然可以被所有浏览器识别和解析，但已经不再必要，而且不应该再使用了。在 XHTML 模式下，这种格式也会导致脚本被忽略，因为代码处于有效的 XML 注释当中。\n"},{"id":1,"href":"/docs/javascript/5/5.1/","title":"Date","section":"基本引用类型","content":"Date #  ECMAScript 的 Date 类型参考了 Java 早期版本中的 java.util.Date。为此，Date 类型将日期保存为自协调世界时（UTC，Universal Time Coordinated）时间 1970 年 1 月 1 日午夜（零时）至今所经过的毫秒数。使用这种存储格式，Date 类型可以精确表示 1970 年 1 月 1 日之前及之后 285 616 年的日期。\n要创建日期对象，就使用 new 操作符来调用 Date 构造函数：\nlet now = new Date(); 在不给 Date 构造函数传参数的情况下，创建的对象将保存当前日期和时间。要基于其他日期和时间创建日期对象，必须传入其毫秒表示（UNIX 纪元 1970 年 1 月 1 日午夜之后的毫秒数）。ECMAScript 为此提供了两个辅助方法：Date.parse()和 Date.UTC()。\nDate.parse()方法接收一个表示日期的字符串参数，尝试将这个字符串转换为表示该日期的毫秒数。ECMA-262 第 5 版定义了 Date.parse()应该支持的日期格式，填充了第 3 版遗留的空白。所有实现都必须支持下列日期格式：\n “月/日/年”，如\u0026quot;5/23/2019\u0026quot;； “月名 日, 年”，如\u0026quot;May 23, 2019\u0026quot;； “周几 月名 日 年 时:分:秒 时区”，如\u0026quot;Tue May 23 2019 00:00:00 GMT-0700\u0026quot;； ISO 8601 扩展格式“YYYY-MM-DDTHH:mm:ss.sssZ”，如 2019-05-23T00:00:00（只适用于兼容 ES5 的实现）。  比如，要创建一个表示“2019 年 5 月 23 日”的日期对象，可以使用以下代码：\nlet someDate = new Date(Date.parse(\u0026#34;May 23, 2019\u0026#34;)); 如果传给 Date.parse()的字符串并不表示日期，则该方法会返回 NaN。如果直接把表示日期的字符串传给 Date 构造函数，那么 Date 会在后台调用 Date.parse()。换句话说，下面这行代码跟前面那行代码是等价的：\nlet someDate = new Date(\u0026#34;May 23, 2019\u0026#34;); 这两行代码得到的日期对象相同。\n注意 不同的浏览器对 Date 类型的实现有很多问题。比如，很多浏览器会选择用当前日期替代越界的日期，因此有些浏览器会将\u0026quot;January 32, 2019\u0026quot;解释为\u0026quot;February 1, 2019\u0026quot;。Opera 则会插入当前月的当前日，返回\u0026quot;January 当前日, 2019\u0026quot;。就是说，如果是在 9 月 21 日运行代码，会返回\u0026quot;January 21, 2019\u0026quot;。  Date.UTC()方法也返回日期的毫秒表示，但使用的是跟 Date.parse()不同的信息来生成这个值。传给 Date.UTC()的参数是年、零起点月数（1 月是 0，2 月是 1，以此类推）、日（1~31）、时（0~23）、分、秒和毫秒。这些参数中，只有前两个（年和月）是必需的。如果不提供日，那么默认为 1 日。其他参数的默认值都是 0。下面是使用 Date.UTC()的两个例子：\n// GMT时间2000年1月1日零点 let y2k = new Date(Date.UTC(2000, 0)); // GMT时间2005年5月5日下午5点55分55秒 let allFives = new Date(Date.UTC(2005, 4, 5, 17, 55, 55)); 这个例子创建了两个日期 。第一个日期是 2000 年 1 月 1 日零点（GMT），2000 代表年，0 代表月（1 月）。因为没有其他参数（日取 1，其他取 0），所以结果就是该月第 1 天零点。第二个日期表示 2005 年 5 月 5 日下午 5 点 55 分 55 秒（GMT）。虽然日期里面涉及的都是 5，但月数必须用 4，因为月数是零起点的。小时也必须是 17，因为这里采用的是 24 小时制，即取值范围是 0~23。其他参数就都很直观了。\n与 Date.parse()一样，Date.UTC()也会被 Date 构造函数隐式调用，但有一个区别：这种情况下创建的是本地日期，不是 GMT 日期。不过 Date 构造函数跟 Date.UTC()接收的参数是一样的。因此，如果第一个参数是数值，则构造函数假设它是日期中的年，第二个参数就是月，以此类推。前面的例子也可以这样来写：\n// 本地时间2000年1月1日零点 let y2k = new Date(2000, 0); // 本地时间2005年5月5日下午5点55分55秒 let allFives = new Date(2005, 4, 5, 17, 55, 55); 以上代码创建了与前面例子中相同的两个日期，但这次的两个日期是（由于系统设置决定的）本地时区的日期。\nECMAScript 还提供了 Date.now()方法，返回表示方法执行时日期和时间的毫秒数。这个方法可以方便地用在代码分析中：\n// 起始时间 let start = Date.now(); // 调用函数 doSomething(); // 结束时间 let stop = Date.now(), result = stop - start; 继承的方法 #  与其他类型一样，Date 类型重写了 toLocaleString()、toString()和 valueOf()方法。但与其他类型不同，重写后这些方法的返回值不一样。Date 类型的 toLocaleString()方法返回与浏览器运行的本地环境一致的日期和时间。这通常意味着格式中包含针对时间的 AM（上午）或 PM（下午），但不包含时区信息（具体格式可能因浏览器而不同）。toString()方法通常返回带时区信息的日期和时间，而时间也是以 24 小时制（0~23）表示的。下面给出了 toLocaleString()和 toString()返回的 2019 年 2 月 1 日零点的示例（地区为\u0026quot;en-US\u0026quot;的 PST，即 Pacific Standard Time，太平洋标准时间）：\ntoLocaleString() - 2/1/2019 12:00:00 AM toString() - Thu Feb 1 2019 00:00:00 GMT-0800 (Pacific Standard Time) 现代浏览器在这两个方法的输出上已经趋于一致。在比较老的浏览器上，每个方法返回的结果可能在每个浏览器上都是不同的。这些差异意味着 toLocaleString()和 toString()可能只对调试有用，不能用于显示。\nDate 类型的 valueOf()方法根本就不返回字符串，这个方法被重写后返回的是日期的毫秒表示。因此，操作符（如小于号和大于号）可以直接使用它返回的值。比如下面的例子：\nlet date1 = new Date(2019, 0, 1); // 2019年1月1日 let date2 = new Date(2019, 1, 1); // 2019年2月1日  console.log(date1 \u0026lt; date2); // true console.log(date1 \u0026gt; date2); // false 日期 2019 年 1 月 1 日在 2019 年 2 月 1 日之前，所以说前者小于后者没问题。因为 2019 年 1 月 1 日的毫秒表示小于 2019 年 2 月 1 日的毫秒表示，所以用小于号比较这两个日期时会返回 true。这也是确保日期先后的一个简单方式。\n日期格式化方法 #  Date 类型有几个专门用于格式化日期的方法，它们都会返回字符串：\n toDateString()显示日期中的周几、月、日、年（格式特定于实现）； toTimeString()显示日期中的时、分、秒和时区（格式特定于实现）； toLocaleDateString()显示日期中的周几、月、日、年（格式特定于实现和地区）； toLocaleTimeString()显示日期中的时、分、秒（格式特定于实现和地区）； toUTCString()显示完整的 UTC 日期（格式特定于实现）。  这些方法的输出与 toLocaleString()和 toString()一样，会因浏览器而异。因此不能用于在用户界面上一致地显示日期。\n注意 还有一个方法叫 toGMTString()，这个方法跟 toUTCString()是一样的，目的是为了向后兼容。不过，规范建议新代码使用 toUTCString()。  日期/时间组件方法 #  Date 类型剩下的方法（见下表）直接涉及取得或设置日期值的特定部分。注意表中“UTC 日期”，指的是没有时区偏移（将日期转换为 GMT）时的日期。\n   方法 说明     getTime() 返回日期的毫秒表示；与 valueOf()相同   setTime(milliseconds) 设置日期的毫秒表示，从而修改整个日期   getFullYear() 返回 4 位数年（即 2019 而不是 19）   getUTCFullYear() 返回 UTC 日期的 4 位数年   setFullYear(year) 设置日期的年（year 必须是 4 位数）   setUTCFullYear(year) 设置 UTC 日期的年（year 必须是 4 位数）   getMonth() 返回日期的月（0 表示 1 月，11 表示 12 月）   getUTCMonth() 返回 UTC 日期的月（0 表示 1 月，11 表示 12 月）   setMonth(month) 设置日期的月（month 为大于 0 的数值，大于 11 加年）   setUTCMonth(month) 设置 UTC 日期的月（month 为大于 0 的数值，大于 11 加年）   getDate() 返回日期中的日（1~31）   getUTCDate() 返回 UTC 日期中的日（1~31）   setDate(date) 设置日期中的日（如果 date 大于该月天数，则加月）   setUTCDate(date) 设置 UTC 日期中的日（如果 date 大于该月天数，则加月）   getDay() 返回日期中表示周几的数值（0 表示周日，6 表示周六）   getUTCDay() 返回 UTC 日期中表示周几的数值（0 表示周日，6 表示周六）   getHours() 返回日期中的时（0~23）   getUTCHours() 返回 UTC 日期中的时（0~23）   setHours(hours) 设置日期中的时（如果 hours 大于 23，则加日）   setUTCHours(hours) 设置 UTC 日期中的时（如果 hours 大于 23，则加日）   getMinutes() 返回日期中的分（0~59）   getUTCMinutes() 返回 UTC 日期中的分（0~59）   setMinutes(minutes) 设置日期中的分（如果 minutes 大于 59，则加时）   setUTCMinutes(minutes) 设置 UTC 日期中的分（如果 minutes 大于 59，则加时）   getSeconds() 返回日期中的秒（0~59）   getUTCSeconds() 返回 UTC 日期中的秒（0~59）   setSeconds(seconds) 设置日期中的秒（如果 seconds 大于 59，则加分）   setUTCSeconds(seconds) 设置 UTC 日期中的秒（如果 seconds 大于 59，则加分）   getMilliseconds() 返回日期中的毫秒   getUTCMilliseconds() 返回 UTC 日期中的毫秒   setMilliseconds(milliseconds) 设置日期中的毫秒   setUTCMilliseconds(milliseconds) 设置 UTC 日期中的毫秒   getTimezoneOffset() 返回以分钟计的 UTC 与本地时区的偏移量（如美国 EST 即“东部标准时间”返回 300，进入夏令时的地区可能有所差异）    "},{"id":2,"href":"/docs/javascript/","title":"Javascript","section":"Docs","content":"JavaScript #  关于 JavaScript，谷歌公司的一位技术经理曾经跟我分享过一个无法反驳的观点。他说 JavaScript 并不是一门真正有内聚力的编程语言，至少形式上不是。ECMA-262 规范定义了 JavaScript，但 JavaScript 没有唯一正确的实现。更重要的是，这门语言与其宿主关系密切。实际上宿主为 JavaScript 定义了与外界交互所需的全部 API：DOM、网络请求、系统硬件、存储、事件、文件、加密，还有数以百计的其他 API。各种浏览器及其 JavaScript 引擎都按照自己的理解实现了这些规范。Chrome 有 Blink/V8，Firefox 有 Gecko/SpiderMonkey，Safari 有 WebKit/JavaScriptCore，微软有 Trident/EdgeHTML/Chakra。浏览器以合规的方式运行绝大多数 JavaScript，但 Web 上随处可见迎合各种浏览器偏好的页面。因此，对 JavaScript 更准确的定位应该是一组浏览器实现。\nWeb 纯化论者可能认为 JavaScript 本身并非网页不可或缺的部分，但他们必须承认，如果没有 JavaScript，那么现代 Web 势必发生严重倒退。毫不夸张地讲，JavaScript 才是真正不可或缺的。如今，手机、计算机、平板设备、电视、游戏机、智能手表、冰箱，甚至连汽车都内置了可以执行 JavaScript 代码的 Web 浏览器。地球上有近 30 亿人在使用安装了 Web 浏览器的智能手机。这门语言迅速发展的社区催生了大量高质量的开源项目。浏览器也已经支持模拟原生移动应用程序的 API。Stack Overflow 2019 年的开发者调查显示，JavaScript 连续 7 年位于最流行编程语言榜首。\n我们正迎来 JavaScript 的复兴。\n"},{"id":3,"href":"/docs/javascript/6/6.1/","title":"Object","section":"集合引用类型","content":"Object #  到目前为止，大多数引用值的示例使用的是 Object 类型。Object 是 ECMAScript 中最常用的类型之一。虽然 Object 的实例没有多少功能，但很适合存储和在应用程序间交换数据。\n显式地创建 Object 的实例有两种方式。第一种是使用 new 操作符和 Object 构造函数，如下所示：\nlet person = new Object(); person.name = \u0026#34;Nicholas\u0026#34;; person.age = 29; 另一种方式是使用对象字面量（object literal）表示法。对象字面量是对象定义的简写形式，目的是为了简化包含大量属性的对象的创建。比如，下面的代码定义了与前面示例相同的 person 对象，但使用的是对象字面量表示法：\nlet person = { name: \u0026#34;Nicholas\u0026#34;, age: 29, }; 在这个例子中，左大括号（{）表示对象字面量开始，因为它出现在一个表达式上下文（expression context）中。在 ECMAScript 中，表达式上下文指的是期待返回值的上下文。赋值操作符表示后面要期待一个值，因此左大括号表示一个表达式的开始。同样是左大括号，如果出现在语句上下文（statement context）中，比如 if 语句的条件后面，则表示一个语句块的开始。\n接下来指定了 name 属性，后跟一个冒号，然后是属性的值。逗号用于在对象字面量中分隔属性，因此字符串\u0026quot;Nicholas\u0026quot;后面有一个逗号，而 29 后面没有，因为 age 是这个对象的最后一个属性。在最后一个属性后面加上逗号在非常老的浏览器中会导致报错，但所有现代浏览器都支持这种写法。\n在对象字面量表示法中，属性名可以是字符串或数值，比如：\nlet person = { name: \u0026#34;Nicholas\u0026#34;, age: 29, 5: true, }; 这个例子会得到一个带有属性 name、age 和 5 的对象。注意，数值属性会自动转换为字符串。\n当然也可以用对象字面量表示法来定义一个只有默认属性和方法的对象，只要使用一对大括号，中间留空就行了：\nlet person = {}; // 与new Object()相同 person.name = \u0026#34;Nicholas\u0026#34;; person.age = 29; 这个例子跟本节开始的第一个例子是等效的，虽然看起来有点怪。对象字面量表示法通常只在为了让属性一目了然时才使用。\n注意 在使用对象字面量表示法定义对象时，并不会实际调用 Object 构造函数。  虽然使用哪种方式创建 Object 实例都可以，但实际上开发者更倾向于使用对象字面量表示法。这是因为对象字面量代码更少，看起来也更有封装所有相关数据的感觉。事实上，对象字面量已经成为给函数传递大量可选参数的主要方式，比如：\nfunction displayInfo(args) { let output = \u0026#34;\u0026#34;; if (typeof args.name == \u0026#34;string\u0026#34;) { output += \u0026#34;Name: \u0026#34; + args.name + \u0026#34;\\n\u0026#34;; } if (typeof args.age == \u0026#34;number\u0026#34;) { output += \u0026#34;Age: \u0026#34; + args.age + \u0026#34;\\n\u0026#34;; } alert(output); } displayInfo({ name: \u0026#34;Nicholas\u0026#34;, age: 29, }); displayInfo({ name: \u0026#34;Greg\u0026#34;, }); 这里，函数 displayInfo()接收一个名为 args 的参数。这个参数可能有属性 name 或 age，也可能两个属性都有或者都没有。函数内部会使用 typeof 操作符测试每个属性是否存在，然后根据属性有无构造并显示一条消息。然后，这个函数被调用了两次，每次都通过一个对象字面量传入了不同的数据。两种情况下，函数都正常运行。\n注意 这种模式非常适合函数有大量可选参数的情况。一般来说，命名参数更直观，但在可选参数过多的时候就显得笨拙了。最好的方式是对必选参数使用命名参数，再通过一个对象字面量来封装多个可选参数。  虽然属性一般是通过点语法来存取的，这也是面向对象语言的惯例，但也可以使用中括号来存取属性。在使用中括号时，要在括号内使用属性名的字符串形式，比如：\nconsole.log(person[\u0026#34;name\u0026#34;]); // \u0026#34;Nicholas\u0026#34; console.log(person.name); // \u0026#34;Nicholas\u0026#34; 从功能上讲，这两种存取属性的方式没有区别。使用中括号的主要优势就是可以通过变量访问属性，就像下面这个例子中一样：\nlet propertyName = \u0026#34;name\u0026#34;; console.log(person[propertyName]); // \u0026#34;Nicholas\u0026#34; 另外，如果属性名中包含可能会导致语法错误的字符，或者包含关键字/保留字时，也可以使用中括号语法。比如：\nperson[\u0026#34;first name\u0026#34;] = \u0026#34;Nicholas\u0026#34;; 因为\u0026quot;first name\u0026quot;中包含一个空格，所以不能使用点语法来访问。不过，属性名中是可以包含非字母数字字符的，这时候只要用中括号语法存取它们就行了。\n通常，点语法是首选的属性存取方式，除非访问属性时必须使用变量。\n"},{"id":4,"href":"/docs/javascript/1/","title":"什么是 JavaScript","section":"Javascript","content":"什么是 JavaScript #  1995 年，JavaScript 问世。当时，它的主要用途是代替 Perl 等服务器端语言处理输入验证。在此之前，要验证某个必填字段是否已填写，或者某个输入的值是否有效，需要与服务器的一次往返通信。网景公司希望通过在其 Navigator 浏览器中加入 JavaScript 来改变这个局面。在那个普遍通过电话拨号上网的年代，由客户端处理某些基本的验证是让人兴奋的新功能。缓慢的网速让页面每次刷新都考验着人们的耐心。\n从那时起，JavaScript 逐渐成为市面上所有主流浏览器的标配。如今，JavaScript 的应用也不再局限于数据验证，而是渗透到浏览器窗口及其内容的方方面面。JavaScript 已被公认为主流的编程语言，能够实现复杂的计算与交互，包括闭包、匿名（lambda）函数，甚至元编程等特性。不仅是桌面浏览器，手机浏览器和屏幕阅读器也支持 JavaScript，其重要性可见一斑。就连拥有自家客户端脚本语言 VBScript 的微软公司，也在其 Internet Explorer（以下简称 IE）浏览器最初的版本中包含了自己的 JavaScript 实现。\n从简单的输入验证脚本到强大的编程语言，JavaScript 的崛起没有任何人预测到。它很简单，学会用只要几分钟；它又很复杂，掌握它要很多年。要真正学好用好 JavaScript，理解其本质、历史及局限性是非常重要的。\n"},{"id":5,"href":"/docs/javascript/9/9.1/","title":"代理基础","section":"代理与反射","content":"代理基础 #  正如本篇开头所介绍的，代理是目标对象的抽象。从很多方面看，代理类似 C++指针，因为它可以用作目标对象的替身，但又完全独立于目标对象。目标对象既可以直接被操作，也可以通过代理来操作。但直接操作会绕过代理施予的行为。\n注意 ECMAScript 代理与 C++指针有重大区别，后面会再讨论。不过作为一种有助于理解的类比，指针在概念上还是比较合适的结构。  创建空代理 #  最简单的代理是空代理，即除了作为一个抽象的目标对象，什么也不做。默认情况下，在代理对象上执行的所有操作都会无障碍地传播到目标对象。因此，在任何可以使用目标对象的地方，都可以通过同样的方式来使用与之关联的代理对象。\n代理是使用 Proxy 构造函数创建的。这个构造函数接收两个参数：目标对象和处理程序对象。缺少其中任何一个参数都会抛出 TypeError。要创建空代理，可以传一个简单的对象字面量作为处理程序对象，从而让所有操作畅通无阻地抵达目标对象。\n如下面的代码所示，在代理对象上执行的任何操作实际上都会应用到目标对象。唯一可感知的不同就是代码中操作的是代理对象。\nconst target = { id: \u0026#34;target\u0026#34;, }; const handler = {}; const proxy = new Proxy(target, handler); // id属性会访问同一个值 console.log(target.id); // target console.log(proxy.id); // target  // 给目标属性赋值会反映在两个对象上 // 因为两个对象访问的是同一个值 target.id = \u0026#34;foo\u0026#34;; console.log(target.id); // foo console.log(proxy.id); // foo  // 给代理属性赋值会反映在两个对象上 // 因为这个赋值会转移到目标对象 proxy.id = \u0026#34;bar\u0026#34;; console.log(target.id); // bar console.log(proxy.id); // bar  // hasOwnProperty()方法在两个地方 // 都会应用到目标对象 console.log(target.hasOwnProperty(\u0026#34;id\u0026#34;)); // true console.log(proxy.hasOwnProperty(\u0026#34;id\u0026#34;)); // true  // Proxy.prototype是undefined // 因此不能使用instanceof操作符 console.log(target instanceof Proxy); // TypeError: Function has non-object prototype \u0026#39;undefined\u0026#39; in instanceof check console.log(proxy instanceof Proxy); // TypeError: Function has non-object prototype \u0026#39;undefined\u0026#39; in instanceof check  // 严格相等可以用来区分代理和目标 console.log(target === proxy); // false 定义捕获器 #  使用代理的主要目的是可以定义捕获器（trap）。捕获器就是在处理程序对象中定义的“基本操作的拦截器”。每个处理程序对象可以包含零个或多个捕获器，每个捕获器都对应一种基本操作，可以直接或间接在代理对象上调用。每次在代理对象上调用这些基本操作时，代理可以在这些操作传播到目标对象之前先调用捕获器函数，从而拦截并修改相应的行为。\n注意 捕获器（trap）是从操作系统中借用的概念。在操作系统中，捕获器是程序流中的一个同步中断，可以暂停程序流，转而执行一段子例程，之后再返回原始程序流。  例如，可以定义一个 get()捕获器，在 ECMAScript 操作以某种形式调用 get()时触发。下面的例子定义了一个 get()捕获器：\nconst target = { foo: \u0026#34;bar\u0026#34;, }; const handler = { // 捕获器在处理程序对象中以方法名为键  get() { return \u0026#34;handler override\u0026#34;; }, }; const proxy = new Proxy(target, handler); 这样，当通过代理对象执行 get()操作时，就会触发定义的 get()捕获器。当然，get()不是 ECMAScript 对象可以调用的方法。这个操作在 JavaScript 代码中可以通过多种形式触发并被 get()捕获器拦截到。proxy[property]、proxy.property 或 Object.create(proxy)[property]等操作都会触发基本的 get()操作以获取属性。因此所有这些操作只要发生在代理对象上，就会触发 get()捕获器。注意，只有在代理对象上执行这些操作才会触发捕获器。在目标对象上执行这些操作仍然会产生正常的行为。\nconst target = { foo: \u0026#34;bar\u0026#34;, }; const handler = { // 捕获器在处理程序对象中以方法名为键  get() { return \u0026#34;handler override\u0026#34;; }, }; const proxy = new Proxy(target, handler); console.log(target.foo); // bar console.log(proxy.foo); // handler override  console.log(target[\u0026#34;foo\u0026#34;]); // bar console.log(proxy[\u0026#34;foo\u0026#34;]); // handler override  console.log(Object.create(target)[\u0026#34;foo\u0026#34;]); // bar console.log(Object.create(proxy)[\u0026#34;foo\u0026#34;]); // handler override 捕获器参数和反射 API #  所有捕获器都可以访问相应的参数，基于这些参数可以重建被捕获方法的原始行为。比如，get()捕获器会接收到目标对象、要查询的属性和代理对象三个参数。\nconst target = { foo: \u0026#34;bar\u0026#34;, }; const handler = { get(trapTarget, property, receiver) { console.log(trapTarget === target); console.log(property); console.log(receiver === proxy); }, }; const proxy = new Proxy(target, handler); proxy.foo; // true // foo // true 有了这些参数，就可以重建被捕获方法的原始行为：\nconst target = { foo: \u0026#34;bar\u0026#34;, }; const handler = { get(trapTarget, property, receiver) { return trapTarget[property]; }, }; const proxy = new Proxy(target, handler); console.log(proxy.foo); // bar console.log(target.foo); // bar 所有捕获器都可以基于自己的参数重建原始操作，但并非所有捕获器行为都像 get()那么简单。因此，通过手动写码如法炮制的想法是不现实的。实际上，开发者并不需要手动重建原始行为，而是可以通过调用全局 Reflect 对象上（封装了原始行为）的同名方法来轻松重建。\n处理程序对象中所有可以捕获的方法都有对应的反射（Reflect）API 方法。这些方法与捕获器拦截的方法具有相同的名称和函数签名，而且也具有与被拦截方法相同的行为。因此，使用反射 API 也可以像下面这样定义出空代理对象：\nconst target = { foo: \u0026#34;bar\u0026#34;, }; const handler = { get() { return Reflect.get(...arguments); }, }; const proxy = new Proxy(target, handler); console.log(proxy.foo); // bar console.log(target.foo); // bar 甚至还可以写得更简洁一些：\nconst target = { foo: \u0026#34;bar\u0026#34;, }; const handler = { get: Reflect.get, }; const proxy = new Proxy(target, handler); console.log(proxy.foo); // bar console.log(target.foo); // bar 事实上，如果真想创建一个可以捕获所有方法，然后将每个方法转发给对应反射 API 的空代理，那么甚至不需要定义处理程序对象：\nconst target = { foo: \u0026#34;bar\u0026#34;, }; const proxy = new Proxy(target, Reflect); console.log(proxy.foo); // bar console.log(target.foo); // bar 反射 API 为开发者准备好了样板代码，在此基础上开发者可以用最少的代码修改捕获的方法。比如，下面的代码在某个属性被访问时，会对返回的值进行一番修饰：\nconst target = { foo: \u0026#34;bar\u0026#34;, baz: \u0026#34;qux\u0026#34;, }; const handler = { get(trapTarget, property, receiver) { let decoration = \u0026#34;\u0026#34;; if (property === \u0026#34;foo\u0026#34;) { decoration = \u0026#34;!!!\u0026#34;; } return Reflect.get(...arguments) + decoration; }, }; const proxy = new Proxy(target, handler); console.log(proxy.foo); // bar!!! console.log(target.foo); // bar  console.log(proxy.baz); // qux console.log(target.baz); // qux 捕获器不变式 #  使用捕获器几乎可以改变所有基本方法的行为，但也不是没有限制。根据 ECMAScript 规范，每个捕获的方法都知道目标对象上下文、捕获函数签名，而捕获处理程序的行为必须遵循“捕获器不变式”（trap invariant）。捕获器不变式因方法不同而异，但通常都会防止捕获器定义出现过于反常的行为。\n比如，如果目标对象有一个不可配置且不可写的数据属性，那么在捕获器返回一个与该属性不同的值时，会抛出 TypeError：\nconst target = {}; Object.defineProperty(target, \u0026#34;foo\u0026#34;, { configurable: false, writable: false, value: \u0026#34;bar\u0026#34;, }); const handler = { get() { return \u0026#34;qux\u0026#34;; }, }; const proxy = new Proxy(target, handler); console.log(proxy.foo); // TypeError 可撤销代理 #  有时候可能需要中断代理对象与目标对象之间的联系。对于使用 new Proxy()创建的普通代理来说，这种联系会在代理对象的生命周期内一直持续存在。\nProxy 也暴露了 revocable()方法，这个方法支持撤销代理对象与目标对象的关联。撤销代理的操作是不可逆的。而且，撤销函数（revoke()）是幂等的，调用多少次的结果都一样。撤销代理之后再调用代理会抛出 TypeError。\n撤销函数和代理对象是在实例化时同时生成的：\nconst target = { foo: \u0026#34;bar\u0026#34;, }; const handler = { get() { return \u0026#34;intercepted\u0026#34;; }, }; const { proxy, revoke } = Proxy.revocable(target, handler); console.log(proxy.foo); // intercepted console.log(target.foo); // bar  revoke(); console.log(proxy.foo); // TypeError 实用反射 API #  某些情况下应该优先使用反射 API，这是有一些理由的。\n反射 API 与对象 API #  在使用反射 API 时，要记住：\n(1) 反射 API 并不限于捕获处理程序；\n(2) 大多数反射 API 方法在 Object 类型上有对应的方法。\n通常，Object 上的方法适用于通用程序，而反射方法适用于细粒度的对象控制与操作。\n状态标记 #  很多反射方法返回称作“状态标记”的布尔值，表示意图执行的操作是否成功。有时候，状态标记比那些返回修改后的对象或者抛出错误（取决于方法）的反射 API 方法更有用。例如，可以使用反射 API 对下面的代码进行重构：\n// 初始代码  const o = {}; try { Object.defineProperty(o, \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;); console.log(\u0026#34;success\u0026#34;); } catch (e) { console.log(\u0026#34;failure\u0026#34;); } 在定义新属性时如果发生问题，Reflect.defineProperty()会返回 false，而不是抛出错误。因此使用这个反射方法可以这样重构上面的代码：\n// 重构后的代码  const o = {}; if (Reflect.defineProperty(o, \u0026#34;foo\u0026#34;, { value: \u0026#34;bar\u0026#34; })) { console.log(\u0026#34;success\u0026#34;); } else { console.log(\u0026#34;failure\u0026#34;); } 以下反射方法都会提供状态标记：\n Reflect.defineProperty() Reflect.preventExtensions() Reflect.setPrototypeOf() Reflect.set() Reflect.deleteProperty()  用一等函数替代操作符 #  以下反射方法提供只有通过操作符才能完成的操作。\n Reflect.get()：可以替代对象属性访问操作符。 Reflect.set()：可以替代=赋值操作符。 Reflect.has()：可以替代 in 操作符或 with()。 Reflect.deleteProperty()：可以替代 delete 操作符。 Reflect.construct()：可以替代 new 操作符。  安全地应用函数 #  在通过 apply 方法调用函数时，被调用的函数可能也定义了自己的 apply 属性（虽然可能性极小）。为绕过这个问题，可以使用定义在 Function 原型上的 apply 方法，比如：\nFunction.prototype.apply.call(myFunc, thisVal, argumentList); 这种可怕的代码完全可以使用 Reflect.apply 来避免：\nReflect.apply(myFunc, thisVal, argumentsList); 代理另一个代理 #  代理可以拦截反射 API 的操作，而这意味着完全可以创建一个代理，通过它去代理另一个代理。这样就可以在一个目标对象之上构建多层拦截网：\nconst target = { foo: \u0026#34;bar\u0026#34;, }; const firstProxy = new Proxy(target, { get() { console.log(\u0026#34;first proxy\u0026#34;); return Reflect.get(...arguments); }, }); const secondProxy = new Proxy(firstProxy, { get() { console.log(\u0026#34;second proxy\u0026#34;); return Reflect.get(...arguments); }, }); console.log(secondProxy.foo); // second proxy // first proxy // bar 代理的问题与不足 #  代理是在 ECMAScript 现有基础之上构建起来的一套新 API，因此其实现已经尽力做到最好了。很大程度上，代理作为对象的虚拟层可以正常使用。但在某些情况下，代理也不能与现在的 ECMAScript 机制很好地协同。\n代理中的 this #  代理潜在的一个问题来源是 this 值。我们知道，方法中的 this 通常指向调用这个方法的对象：\nconst target = { thisValEqualsProxy() { return this === proxy; }, }; const proxy = new Proxy(target, {}); console.log(target.thisValEqualsProxy()); // false console.log(proxy.thisValEqualsProxy()); // true 从直觉上讲，这样完全没有问题：调用代理上的任何方法，比如 proxy.outerMethod()，而这个方法进而又会调用另一个方法，如 this.innerMethod()，实际上都会调用 proxy.innerMethod()。多数情况下，这是符合预期的行为。可是，如果目标对象依赖于对象标识，那就可能碰到意料之外的问题。\nconst wm = new WeakMap(); class User { constructor(userId) { wm.set(this, userId); } set id(userId) { wm.set(this, userId); } get id() { return wm.get(this); } } 由于这个实现依赖 User 实例的对象标识，在这个实例被代理的情况下就会出问题：\nconst user = new User(123); console.log(user.id); // 123  const userInstanceProxy = new Proxy(user, {}); console.log(userInstanceProxy.id); // undefined 这是因为 User 实例一开始使用目标对象作为 WeakMap 的键，代理对象却尝试从自身取得这个实例。要解决这个问题，就需要重新配置代理，把代理 User 实例改为代理 User 类本身。之后再创建代理的实例就会以代理实例作为 WeakMap 的键了：\nconst UserClassProxy = new Proxy(User, {}); const proxyUser = new UserClassProxy(456); console.log(proxyUser.id); 代理与内部槽位 #  代理与内置引用类型（比如 Array）的实例通常可以很好地协同，但有些 ECMAScript 内置类型可能会依赖代理无法控制的机制，结果导致在代理上调用某些方法会出错。\n一个典型的例子就是 Date 类型。根据 ECMAScript 规范，Date 类型方法的执行依赖 this 值上的内部槽位[[NumberDate]]。代理对象上不存在这个内部槽位，而且这个内部槽位的值也不能通过普通的 get()和 set()操作访问到，于是代理拦截后本应转发给目标对象的方法会抛出 TypeError：\nconst target = new Date(); const proxy = new Proxy(target, {}); console.log(proxy instanceof Date); // true  proxy.getDate(); // TypeError: \u0026#39;this\u0026#39; is not a Date object "},{"id":6,"href":"/docs/javascript/4/4.1/","title":"原始值与引用值","section":"变量、作用域与内存","content":"原始值与引用值 #  ECMAScript 变量可以包含两种不同类型的数据：原始值和引用值。原始值（primitive value）就是最简单的数据，引用值（reference value）则是由多个值构成的对象。\n在把一个值赋给变量时，JavaScript 引擎必须确定这个值是原始值还是引用值。上一章讨论了 6 种原始值：Undefined、Null、Boolean、Number、String 和 Symbol。保存原始值的变量是按值（by value）访问的，因为我们操作的就是存储在变量中的实际值。\n引用值是保存在内存中的对象。与其他语言不同，JavaScript 不允许直接访问内存位置，因此也就不能直接操作对象所在的内存空间。在操作对象时，实际上操作的是对该对象的引用（reference）而非实际的对象本身。为此，保存引用值的变量是按引用（by reference）访问的。\n注意 在很多语言中，字符串是使用对象表示的，因此被认为是引用类型。ECMAScript 打破了这个惯例。  动态属性 #  原始值和引用值的定义方式很类似，都是创建一个变量，然后给它赋一个值。不过，在变量保存了这个值之后，可以对这个值做什么，则大有不同。对于引用值而言，可以随时添加、修改和删除其属性和方法。比如，看下面的例子：\nlet person = new Object(); person.name = \u0026#34;Nicholas\u0026#34;; console.log(person.name); // \u0026#34;Nicholas\u0026#34; 这里，首先创建了一个对象，并把它保存在变量 person 中。然后，给这个对象添加了一个名为 name 的属性，并给这个属性赋值了一个字符串\u0026quot;Nicholas\u0026quot;。在此之后，就可以访问这个新属性，直到对象被销毁或属性被显式地删除。\n原始值不能有属性，尽管尝试给原始值添加属性不会报错。比如：\nlet name = \u0026#34;Nicholas\u0026#34;; name.age = 27; console.log(name.age); // undefined 在此，代码想给字符串 name 定义一个 age 属性并给该属性赋值 27。紧接着在下一行，属性不见了。记住，只有引用值可以动态添加后面可以使用的属性。\n注意，原始类型的初始化可以只使用原始字面量形式。如果使用的是 new 关键字，则 JavaScript 会创建一个 Object 类型的实例，但其行为类似原始值。下面来看看这两种初始化方式的差异：\nlet name1 = \u0026#34;Nicholas\u0026#34;; let name2 = new String(\u0026#34;Matt\u0026#34;); name1.age = 27; name2.age = 26; console.log(name1.age); // undefined console.log(name2.age); // 26 console.log(typeof name1); // string console.log(typeof name2); // object 复制值 #  除了存储方式不同，原始值和引用值在通过变量复制时也有所不同。在通过变量把一个原始值赋值到另一个变量时，原始值会被复制到新变量的位置。请看下面的例子：\nlet num1 = 5; let num2 = num1; 这里，num1 包含数值 5。当把 num2 初始化为 num1 时，num2 也会得到数值 5。这个值跟存储在 num1 中的 5 是完全独立的，因为它是那个值的副本。\n这两个变量可以独立使用，互不干扰。这个过程如图 4-1 所示。\n在把引用值从一个变量赋给另一个变量时，存储在变量中的值也会被复制到新变量所在的位置。区别在于，这里复制的值实际上是一个指针，它指向存储在堆内存中的对象。操作完成后，两个变量实际上指向同一个对象，因此一个对象上面的变化会在另一个对象上反映出来，如下面的例子所示：\nlet obj1 = new Object(); let obj2 = obj1; obj1.name = \u0026#34;Nicholas\u0026#34;; console.log(obj2.name); // \u0026#34;Nicholas\u0026#34; 在这个例子中，变量 obj1 保存了一个新对象的实例。然后，这个值被复制到 obj2，此时两个变量都指向了同一个对象。在给 obj1 创建属性 name 并赋值后，通过 obj2 也可以访问这个属性，因为它们都指向同一个对象。图 4-2 展示了变量与堆内存中对象之间的关系。\n传递参数 #  ECMAScript 中所有函数的参数都是按值传递的。这意味着函数外的值会被复制到函数内部的参数中，就像从一个变量复制到另一个变量一样。如果是原始值，那么就跟原始值变量的复制一样，如果是引用值，那么就跟引用值变量的复制一样。对很多开发者来说，这一块可能会不好理解，毕竟变量有按值和按引用访问，而传参则只有按值传递。\n在按值传递参数时，值会被复制到一个局部变量（即一个命名参数，或者用 ECMAScript 的话说，就是 arguments 对象中的一个槽位）。在按引用传递参数时，值在内存中的位置会被保存在一个局部变量，这意味着对本地变量的修改会反映到函数外部。（这在 ECMAScript 中是不可能的。）来看下面这个例子：\nfunction addTen(num) { num += 10; return num; } let count = 20; let result = addTen(count); console.log(count); // 20，没有变化 console.log(result); // 30 这里，函数 addTen()有一个参数 num，它其实是一个局部变量。在调用时，变量 count 作为参数传入。count 的值是 20，这个值被复制到参数 num 以便在 addTen()内部使用。在函数内部，参数 num 的值被加上了 10，但这不会影响函数外部的原始变量 count。参数 num 和变量 count 互不干扰，它们只不过碰巧保存了一样的值。如果 num 是按引用传递的，那么 count 的值也会被修改为 30。这个事实在使用数值这样的原始值时是非常明显的。但是，如果变量中传递的是对象，就没那么清楚了。比如，再看这个例子：\nfunction setName(obj) { obj.name = \u0026#34;Nicholas\u0026#34;; } let person = new Object(); setName(person); console.log(person.name); // \u0026#34;Nicholas\u0026#34; 这一次，我们创建了一个对象并把它保存在变量 person 中。然后，这个对象被传给 setName()方法，并被复制到参数 obj 中。在函数内部，obj 和 person 都指向同一个对象。结果就是，即使对象是按值传进函数的，obj 也会通过引用访问对象。当函数内部给 obj 设置了 name 属性时，函数外部的对象也会反映这个变化，因为 obj 指向的对象保存在全局作用域的堆内存上。很多开发者错误地认为，当在局部作用域中修改对象而变化反映到全局时，就意味着参数是按引用传递的。为证明对象是按值传递的，我们再来看看下面这个修改后的例子：\nfunction setName(obj) { obj.name = \u0026#34;Nicholas\u0026#34;; obj = new Object(); obj.name = \u0026#34;Greg\u0026#34;; } let person = new Object(); setName(person); console.log(person.name); // \u0026#34;Nicholas\u0026#34; 这个例子前后唯一的变化就是 setName()中多了两行代码，将 obj 重新定义为一个有着不同 name 的新对象。当 person 传入 setName()时，其 name 属性被设置为\u0026quot;Nicholas\u0026quot;。然后变量 obj 被设置为一个新对象且 name 属性被设置为\u0026quot;Greg\u0026quot;。如果 person 是按引用传递的，那么 person 应该自动将指针改为指向 name 为\u0026quot;Greg\u0026quot;的对象。可是，当我们再次访问 person.name 时，它的值是\u0026quot;Nicholas\u0026quot;，这表明函数中参数的值改变之后，原始的引用仍然没变。当 obj 在函数内部被重写时，它变成了一个指向本地对象的指针。而那个本地对象在函数执行结束时就被销毁了。\n注意 ECMAScript 中函数的参数就是局部变量。  确定类型 #  前一章提到的 typeof 操作符最适合用来判断一个变量是否为原始类型。更确切地说，它是判断一个变量是否为字符串、数值、布尔值或 undefined 的最好方式。如果值是对象或 null，那么 typeof 返回\u0026quot;object\u0026quot;，如下面的例子所示：\nlet s = \u0026#34;Nicholas\u0026#34;; let b = true; let i = 22; let u; let n = null; let o = new Object(); console.log(typeof s); // string console.log(typeof i); // number console.log(typeof b); // boolean console.log(typeof u); // undefined console.log(typeof n); // object console.log(typeof o); // object typeof 虽然对原始值很有用，但它对引用值的用处不大。我们通常不关心一个值是不是对象，而是想知道它是什么类型的对象。为了解决这个问题，ECMAScript 提供了 instanceof 操作符，语法如下：\nresult = variable instanceof constructor; 如果变量是给定引用类型（由其原型链决定，将在第 8 章详细介绍）的实例，则 instanceof 操作符返回 true。来看下面的例子：\nconsole.log(person instanceof Object); // 变量person是Object吗？ console.log(colors instanceof Array); // 变量colors是Array吗？ console.log(pattern instanceof RegExp); // 变量pattern是RegExp吗？ 按照定义，所有引用值都是 Object 的实例，因此通过 instanceof 操作符检测任何引用值和 Object 构造函数都会返回 true。类似地，如果用 instanceof 检测原始值，则始终会返回 false，因为原始值不是对象。\n注意 typeof 操作符在用于检测函数时也会返回\u0026quot;function\u0026quot;。当在 Safari（直到 Safari 5）和 Chrome（直到 Chrome 7）中用于检测正则表达式时，由于实现细节的原因，typeof 也会返回\u0026quot;function\u0026quot;。ECMA-262 规定，任何实现内部[[Call]]方法的对象都应该在 typeof 检测时返回\u0026quot;function\u0026quot;。因为上述浏览器中的正则表达式实现了这个方法，所以 typeof 对正则表达式也返回\u0026quot;function\u0026quot;。在 IE 和 Firefox 中，typeof 对正则表达式返回\u0026quot;object\u0026quot;。  "},{"id":7,"href":"/docs/javascript/8/8.1/","title":"理解对象","section":"对象、类与面向对象编程","content":"理解对象 #  创建自定义对象的通常方式是创建 Object 的一个新实例，然后再给它添加属性和方法，如下例所示：\nlet person = new Object(); person.name = \u0026#34;Nicholas\u0026#34;; person.age = 29; person.job = \u0026#34;Software Engineer\u0026#34;; person.sayName = function () { console.log(this.name); }; 这个例子创建了一个名为 person 的对象，而且有三个属性（name、age 和 job）和一个方法（sayName()）。sayName()方法会显示 this.name 的值，这个属性会解析为 person.name。早期 JavaScript 开发者频繁使用这种方式创建新对象。几年后，对象字面量变成了更流行的方式。前面的例子如果使用对象字面量则可以这样写：\nlet person = { name: \u0026#34;Nicholas\u0026#34;, age: 29, job: \u0026#34;Software Engineer\u0026#34;, sayName() { console.log(this.name); }, }; 这个例子中的 person 对象跟前面例子中的 person 对象是等价的，它们的属性和方法都一样。这些属性都有自己的特征，而这些特征决定了它们在 JavaScript 中的行为。\n属性的类型 #  ECMA-262 使用一些内部特性来描述属性的特征。这些特性是由为 JavaScript 实现引擎的规范定义的。因此，开发者不能在 JavaScript 中直接访问这些特性。为了将某个特性标识为内部特性，规范会用两个中括号把特性的名称括起来，比如[[Enumerable]]。\n属性分两种：数据属性和访问器属性。\n数据属性 #  数据属性包含一个保存数据值的位置。值会从这个位置读取，也会写入到这个位置。数据属性有 4 个特性描述它们的行为。\n [[Configurable]]：表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特性，以及是否可以把它改为访问器属性。默认情况下，所有直接定义在对象上的属性的这个特性都是 true，如前面的例子所示。 [[Enumerable]]：表示属性是否可以通过 for-in 循环返回。默认情况下，所有直接定义在对象上的属性的这个特性都是 true，如前面的例子所示。 [[Writable]]：表示属性的值是否可以被修改。默认情况下，所有直接定义在对象上的属性的这个特性都是 true，如前面的例子所示。 [[Value]]：包含属性实际的值。这就是前面提到的那个读取和写入属性值的位置。这个特性的默认值为 undefined。  在像前面例子中那样将属性显式添加到对象之后，[[Configurable]]、[[Enumerable]]和[[Writable]]都会被设置为 true，而[[Value]]特性会被设置为指定的值。比如：\nlet person = { name: \u0026#34;Nicholas\u0026#34;, }; 这里，我们创建了一个名为 name 的属性，并给它赋予了一个值\u0026quot;Nicholas\u0026quot;。这意味着[[Value]]特性会被设置为\u0026quot;Nicholas\u0026quot;，之后对这个值的任何修改都会保存这个位置。\n要修改属性的默认特性，就必须使用 Object.defineProperty()方法。这个方法接收 3 个参数：要给其添加属性的对象、属性的名称和一个描述符对象。最后一个参数，即描述符对象上的属性可以包含：configurable、enumerable、writable 和 value，跟相关特性的名称一一对应。根据要修改的特性，可以设置其中一个或多个值。比如：\nlet person = {}; Object.defineProperty(person, \u0026#34;name\u0026#34;, { writable: false, value: \u0026#34;Nicholas\u0026#34;, }); console.log(person.name); // \u0026#34;Nicholas\u0026#34; person.name = \u0026#34;Greg\u0026#34;; console.log(person.name); // \u0026#34;Nicholas\u0026#34; 这个例子创建了一个名为 name 的属性并给它赋予了一个只读的值\u0026quot;Nicholas\u0026quot;。这个属性的值就不能再修改了，在非严格模式下尝试给这个属性重新赋值会被忽略。在严格模式下，尝试修改只读属性的值会抛出错误。\n类似的规则也适用于创建不可配置的属性。比如：\nlet person = {}; Object.defineProperty(person, \u0026#34;name\u0026#34;, { configurable: false, value: \u0026#34;Nicholas\u0026#34;, }); console.log(person.name); // \u0026#34;Nicholas\u0026#34; delete person.name; console.log(person.name); // \u0026#34;Nicholas\u0026#34; 这个例子把 configurable 设置为 false，意味着这个属性不能从对象上删除。非严格模式下对这个属性调用 delete 没有效果，严格模式下会抛出错误。此外，一个属性被定义为不可配置之后，就不能再变回可配置的了。再次调用 Object.defineProperty()并修改任何非 writable 属性会导致错误：\nlet person = {}; Object.defineProperty(person, \u0026#34;name\u0026#34;, { configurable: false, value: \u0026#34;Nicholas\u0026#34;, }); // 抛出错误 Object.defineProperty(person, \u0026#34;name\u0026#34;, { configurable: true, value: \u0026#34;Nicholas\u0026#34;, }); 因此，虽然可以对同一个属性多次调用 Object.defineProperty()，但在把 configurable 设置为 false 之后就会受限制了。\n在调用 Object.defineProperty()时，configurable、enumerable 和 writable 的值如果不指定，则都默认为 false。多数情况下，可能都不需要 Object.defineProperty()提供的这些强大的设置，但要理解 JavaScript 对象，就要理解这些概念。\n访问器属性 #  访问器属性不包含数据值。相反，它们包含一个获取（getter）函数和一个设置（setter）函数，不过这两个函数不是必需的。在读取访问器属性时，会调用获取函数，这个函数的责任就是返回一个有效的值。在写入访问器属性时，会调用设置函数并传入新值，这个函数必须决定对数据做出什么修改。访问器属性有 4 个特性描述它们的行为。\n [[Configurable]]：表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特性，以及是否可以把它改为数据属性。默认情况下，所有直接定义在对象上的属性的这个特性都是 true。 [[Enumerable]]：表示属性是否可以通过 for-in 循环返回。默认情况下，所有直接定义在对象上的属性的这个特性都是 true。 [[Get]]：获取函数，在读取属性时调用。默认值为 undefined。 [[Set]]：设置函数，在写入属性时调用。默认值为 undefined。  访问器属性是不能直接定义的，必须使用 Object.defineProperty()。下面是一个例子：\n// 定义一个对象，包含伪私有成员year_和公共成员edition let book = { year_: 2017, edition: 1, }; Object.defineProperty(book, \u0026#34;year\u0026#34;, { get() { return this.year_; }, set(newValue) { if (newValue \u0026gt; 2017) { this.year_ = newValue; this.edition += newValue - 2017; } }, }); book.year = 2018; console.log(book.edition); // 2 在这个例子中，对象 book 有两个默认属性：year_ 和 edition。year_ 中的下划线常用来表示该属性并不希望在对象方法的外部被访问。另一个属性 year 被定义为一个访问器属性，其中获取函数简单地返回 year_ 的值，而设置函数会做一些计算以决定正确的版本（edition）。因此，把 year 属性修改为 2018 会导致 year_ 变成 2018，edition 变成 2。这是访问器属性的典型使用场景，即设置一个属性值会导致一些其他变化发生。\n获取函数和设置函数不一定都要定义。只定义获取函数意味着属性是只读的，尝试修改属性会被忽略。在严格模式下，尝试写入只定义了获取函数的属性会抛出错误。类似地，只有一个设置函数的属性是不能读取的，非严格模式下读取会返回 undefined，严格模式下会抛出错误。\n在不支持 Object.defineProperty()的浏览器中没有办法修改 [[Configurable]] 或 [[Enumerable]]。\n注意 在 ECMAScript 5 以前，开发者会使用两个非标准的访问创建访问器属性：__defineGetter__() 和 __defineSetter__()。这两个方法最早是 Firefox 引入的，后来 Safari、Chrome 和 Opera 也实现了。  定义多个属性 #  在一个对象上同时定义多个属性的可能性是非常大的。为此，ECMAScript 提供了 Object.defineProperties() 方法。这个方法可以通过多个描述符一次性定义多个属性。它接收两个参数：要为之添加或修改属性的对象和另一个描述符对象，其属性与要添加或修改的属性一一对应。比如：\nlet book = {}; Object.defineProperties(book, { year_: { value: 2017, }, edition: { value: 1, }, year: { get() { return this.year_; }, set(newValue) { if (newValue \u0026gt; 2017) { this.year_ = newValue; this.edition += newValue - 2017; } }, }, }); 这段代码在 book 对象上定义了两个数据属性 year_ 和 edition，还有一个访问器属性 year。最终的对象跟上一节示例中的一样。唯一的区别是所有属性都是同时定义的，并且数据属性的 configurable、enumerable 和 writable 特性值都是 false。\n读取属性的特性 #  使用 Object.getOwnPropertyDescriptor() 方法可以取得指定属性的属性描述符。这个方法接收两个参数：属性所在的对象和要取得其描述符的属性名。返回值是一个对象，对于访问器属性包含 configurable、enumerable、get 和 set 属性，对于数据属性包含 configurable、enumerable、writable 和 value 属性。比如：\nlet book = {}; Object.defineProperties(book, { year_: { value: 2017, }, edition: { value: 1, }, year: { get: function () { return this.year_; }, set: function (newValue) { if (newValue \u0026gt; 2017) { this.year_ = newValue; this.edition += newValue - 2017; } }, }, }); let descriptor = Object.getOwnPropertyDescriptor(book, \u0026#34;year_\u0026#34;); console.log(descriptor.value); // 2017 console.log(descriptor.configurable); // false console.log(typeof descriptor.get); // \u0026#34;undefined\u0026#34; let descriptor = Object.getOwnPropertyDescriptor(book, \u0026#34;year\u0026#34;); console.log(descriptor.value); // undefined console.log(descriptor.enumerable); // false console.log(typeof descriptor.get); // \u0026#34;function\u0026#34; 对于数据属性 year_，value 等于原来的值，configurable 是 false，get 是 undefined。对于访问器属性 year，value 是 undefined，enumerable 是 false，get 是一个指向获取函数的指针。\nECMAScript 2017 新增了 Object.getOwnPropertyDescriptors() 静态方法。这个方法实际上会在每个自有属性上调用 Object.getOwnPropertyDescriptor() 并在一个新对象中返回它们。对于前面的例子，使用这个静态方法会返回如下对象：\nlet book = {}; Object.defineProperties(book, { year_: { value: 2017, }, edition: { value: 1, }, year: { get: function () { return this.year_; }, set: function (newValue) { if (newValue \u0026gt; 2017) { this.year_ = newValue; this.edition += newValue - 2017; } }, }, }); console.log(Object.getOwnPropertyDescriptors(book)); // { // edition: { // configurable: false, // enumerable: false, // value: 1, // writable: false // }, // year: { // configurable: false, // enumerable: false, // get: f(), // set: f(newValue), // }, // year_: { // configurable: false, // enumerable: false, // value: 2017, // writable: false // } // } 合并对象 #  JavaScript 开发者经常觉得“合并”（merge）两个对象很有用。更具体地说，就是把源对象所有的本地属性一起复制到目标对象上。有时候这种操作也被称为“混入”（mixin），因为目标对象通过混入源对象的属性得到了增强。\nECMAScript 6 专门为合并对象提供了 Object.assign() 方法。这个方法接收一个目标对象和一个或多个源对象作为参数，然后将每个源对象中可枚举（Object.propertyIsEnumerable() 返回 true）和自有（Object.hasOwnProperty() 返回 true）属性复制到目标对象。以字符串和符号为键的属性会被复制。对每个符合条件的属性，这个方法会使用源对象上的 [[Get]] 取得属性的值，然后使用目标对象上的 [[Set]] 设置属性的值。\nlet dest, src, result; /** * 简单复制 */ dest = {}; src = { id: \u0026#34;src\u0026#34; }; result = Object.assign(dest, src); // Object.assign修改目标对象 // 也会返回修改后的目标对象 console.log(dest === result); // true console.log(dest !== src); // true console.log(result); // { id: src } console.log(dest); // { id: src }  /** * 多个源对象 */ dest = {}; result = Object.assign(dest, { a: \u0026#34;foo\u0026#34; }, { b: \u0026#34;bar\u0026#34; }); console.log(result); // { a: foo, b: bar }  /** * 获取函数与设置函数 */ dest = { set a(val) { console.log(`Invoked dest setter with param ${val}`); }, }; src = { get a() { console.log(\u0026#34;Invoked src getter\u0026#34;); return \u0026#34;foo\u0026#34;; }, }; Object.assign(dest, src); // 调用src的获取方法 // 调用dest的设置方法并传入参数\u0026#34;foo\u0026#34; // 因为这里的设置函数不执行赋值操作 // 所以实际上并没有把值转移过来 console.log(dest); // { set a(val) {...} } Object.assign() 实际上对每个源对象执行的是浅复制。如果多个源对象都有相同的属性，则使用最后一个复制的值。此外，从源对象访问器属性取得的值，比如获取函数，会作为一个静态值赋给目标对象。换句话说，不能在两个对象间转移获取函数和设置函数。\nlet dest, src, result; /** * 覆盖属性 */ dest = { id: \u0026#34;dest\u0026#34; }; result = Object.assign( dest, { id: \u0026#34;src1\u0026#34;, a: \u0026#34;foo\u0026#34; }, { id: \u0026#34;src2\u0026#34;, b: \u0026#34;bar\u0026#34; } ); // Object.assign会覆盖重复的属性 console.log(result); // { id: src2, a: foo, b: bar }  // 可以通过目标对象上的设置函数观察到覆盖的过程： dest = { set id(x) { console.log(x); }, }; Object.assign(dest, { id: \u0026#34;first\u0026#34; }, { id: \u0026#34;second\u0026#34; }, { id: \u0026#34;third\u0026#34; }); // first // second // third  /** * 对象引用 */ dest = {}; src = { a: {} }; Object.assign(dest, src); // 浅复制意味着只会复制对象的引用 console.log(dest); // { a :{} } console.log(dest.a === src.a); // true 如果赋值期间出错，则操作会中止并退出，同时抛出错误。Object.assign() 没有“回滚”之前赋值的概念，因此它是一个尽力而为、可能只会完成部分复制的方法。\nlet dest, src, result; /** * 错误处理 */ dest = {}; src = { a: \u0026#34;foo\u0026#34;, get b() { // Object.assign()在调用这个获取函数时会抛出错误  throw new Error(); }, c: \u0026#34;bar\u0026#34;, }; try { Object.assign(dest, src); } catch (e) {} // Object.assign()没办法回滚已经完成的修改 // 因此在抛出错误之前，目标对象上已经完成的修改会继续存在： console.log(dest); // { a: foo } 对象标识及相等判定 #  在 ECMAScript 6 之前，有些特殊情况即使是===操作符也无能为力：\n// 这些是===符合预期的情况 console.log(true === 1); // false console.log({} === {}); // false console.log(\u0026#34;2\u0026#34; === 2); // false  // 这些情况在不同JavaScript引擎中表现不同，但仍被认为相等 console.log(+0 === -0); // true console.log(+0 === 0); // true console.log(-0 === 0); // true  // 要确定NaN的相等性，必须使用极为讨厌的isNaN() console.log(NaN === NaN); // false console.log(isNaN(NaN)); // true 为改善这类情况，ECMAScript 6 规范新增了 Object.is()，这个方法与 === 很像，但同时也考虑到了上述边界情形。这个方法必须接收两个参数：\nconsole.log(Object.is(true, 1)); // false console.log(Object.is({}, {})); // false console.log(Object.is(\u0026#34;2\u0026#34;, 2)); // false  // 正确的0、-0、+0相等/不等判定 console.log(Object.is(+0, -0)); // false console.log(Object.is(+0, 0)); // true console.log(Object.is(-0, 0)); // false  // 正确的NaN相等判定 console.log(Object.is(NaN, NaN)); // true 要检查超过两个值，递归地利用相等性传递即可：\nfunction recursivelyCheckEqual(x, ...rest) { return ( Object.is(x, rest[0]) \u0026amp;\u0026amp; (rest.length \u0026lt; 2 || recursivelyCheckEqual(...rest)) ); } 增强的对象语法 #  ECMAScript 6 为定义和操作对象新增了很多极其有用的语法糖特性。这些特性都没有改变现有引擎的行为，但极大地提升了处理对象的方便程度。\n本节介绍的所有对象语法同样适用于 ECMAScript 6 的类，本篇后面会讨论。\n注意 相比于以往的替代方案，本节介绍的增强对象语法可以说是一骑绝尘。因此后面会默认使用这些新语法特性。  属性值简写 #  在给对象添加变量的时候，开发者经常会发现属性名和变量名是一样的。例如：\nlet name = \u0026#34;Matt\u0026#34;; let person = { name: name, }; console.log(person); // { name: \u0026#39;Matt\u0026#39; } 为此，简写属性名语法出现了。简写属性名只要使用变量名（不用再写冒号）就会自动被解释为同名的属性键。如果没有找到同名变量，则会抛出 ReferenceError。\n以下代码和之前的代码是等价的：\nlet name = \u0026#34;Matt\u0026#34;; let person = { name, }; console.log(person); // { name: \u0026#39;Matt\u0026#39; } 代码压缩程序会在不同作用域间保留属性名，以防止找不到引用。以下面的代码为例：\nfunction makePerson(name) { return { name, }; } let person = makePerson(\u0026#34;Matt\u0026#34;); console.log(person.name); // Matt 在这里，即使参数标识符只限定于函数作用域，编译器也会保留初始的 name 标识符。如果使用 Google Closure 编译器压缩，那么函数参数会被缩短，而属性名不变：\nfunction makePerson(a) { return { name: a, }; } var person = makePerson(\u0026#34;Matt\u0026#34;); console.log(person.name); // Matt 可计算属性 #  在引入可计算属性之前，如果想使用变量的值作为属性，那么必须先声明对象，然后使用中括号语法来添加属性。换句话说，不能在对象字面量中直接动态命名属性。比如：\nconst nameKey = \u0026#34;name\u0026#34;; const ageKey = \u0026#34;age\u0026#34;; const jobKey = \u0026#34;job\u0026#34;; let person = {}; person[nameKey] = \u0026#34;Matt\u0026#34;; person[ageKey] = 27; person[jobKey] = \u0026#34;Software engineer\u0026#34;; console.log(person); // { name: \u0026#39;Matt\u0026#39;, age: 27, job: \u0026#39;Software engineer\u0026#39; } 有了可计算属性，就可以在对象字面量中完成动态属性赋值。中括号包围的对象属性键告诉运行时将其作为 JavaScript 表达式而不是字符串来求值：\nconst nameKey = \u0026#34;name\u0026#34;; const ageKey = \u0026#34;age\u0026#34;; const jobKey = \u0026#34;job\u0026#34;; let person = { [nameKey]: \u0026#34;Matt\u0026#34;, [ageKey]: 27, [jobKey]: \u0026#34;Software engineer\u0026#34;, }; console.log(person); // { name: \u0026#39;Matt\u0026#39;, age: 27, job: \u0026#39;Software engineer\u0026#39; } 因为被当作 JavaScript 表达式求值，所以可计算属性本身可以是复杂的表达式，在实例化时再求值：\nconst nameKey = \u0026#34;name\u0026#34;; const ageKey = \u0026#34;age\u0026#34;; const jobKey = \u0026#34;job\u0026#34;; let uniqueToken = 0; function getUniqueKey(key) { return `${key}_${uniqueToken++}`; } let person = { [getUniqueKey(nameKey)]: \u0026#34;Matt\u0026#34;, [getUniqueKey(ageKey)]: 27, [getUniqueKey(jobKey)]: \u0026#34;Software engineer\u0026#34;, }; console.log(person); // { name_0: \u0026#39;Matt\u0026#39;, age_1: 27, job_2: \u0026#39;Software engineer\u0026#39; } 注意 可计算属性表达式中抛出任何错误都会中断对象创建。如果计算属性的表达式有副作用，那就要小心了，因为如果表达式抛出错误，那么之前完成的计算是不能回滚的。  简写方法名 #  在给对象定义方法时，通常都要写一个方法名、冒号，然后再引用一个匿名函数表达式，如下所示：\nlet person = { sayName: function (name) { console.log(`My name is ${name}`); }, }; person.sayName(\u0026#34;Matt\u0026#34;); // My name is Matt 新的简写方法的语法遵循同样的模式，但开发者要放弃给函数表达式命名（不过给作为方法的函数命名通常没什么用）。相应地，这样也可以明显缩短方法声明。\n以下代码和之前的代码在行为上是等价的：\nlet person = { sayName(name) { console.log(`My name is ${name}`); }, }; person.sayName(\u0026#34;Matt\u0026#34;); // My name is Matt 简写方法名对获取函数和设置函数也是适用的：\nlet person = { name_: \u0026#34;\u0026#34;, get name() { return this.name_; }, set name(name) { this.name_ = name; }, sayName() { console.log(`My name is ${this.name_}`); }, }; person.name = \u0026#34;Matt\u0026#34;; person.sayName(); // My name is Matt 简写方法名与可计算属性键相互兼容：\nconst methodKey = \u0026#34;sayName\u0026#34;; let person = { [methodKey](name) { console.log(`My name is ${name}`); }, }; person.sayName(\u0026#34;Matt\u0026#34;); // My name is Matt 注意 简写方法名对于本篇后面介绍的 ECMAScript 6 的类更有用。  对象解构 #  ECMAScript 6 新增了对象解构语法，可以在一条语句中使用嵌套数据实现一个或多个赋值操作。简单地说，对象解构就是使用与对象匹配的结构来实现对象属性赋值。\n下面的例子展示了两段等价的代码，首先是不使用对象解构的：\n// 不使用对象解构 let person = { name: \u0026#34;Matt\u0026#34;, age: 27, }; let personName = person.name, personAge = person.age; console.log(personName); // Matt console.log(personAge); // 27 然后，是使用对象解构的：\n// 使用对象解构 let person = { name: \u0026#34;Matt\u0026#34;, age: 27, }; let { name: personName, age: personAge } = person; console.log(personName); // Matt console.log(personAge); // 27 使用解构，可以在一个类似对象字面量的结构中，声明多个变量，同时执行多个赋值操作。如果想让变量直接使用属性的名称，那么可以使用简写语法，比如：\nlet person = { name: \u0026#34;Matt\u0026#34;, age: 27, }; let { name, age } = person; console.log(name); // Matt console.log(age); // 27 解构赋值不一定与对象的属性匹配。赋值的时候可以忽略某些属性，而如果引用的属性不存在，则该变量的值就是 undefined：\nlet person = { name: \u0026#34;Matt\u0026#34;, age: 27, }; let { name, job } = person; console.log(name); // Matt console.log(job); // undefined 也可以在解构赋值的同时定义默认值，这适用于前面刚提到的引用的属性不存在于源对象中的情况：\nlet person = { name: \u0026#34;Matt\u0026#34;, age: 27, }; let { name, job = \u0026#34;Software engineer\u0026#34; } = person; console.log(name); // Matt console.log(job); // Software engineer 解构在内部使用函数 ToObject()（不能在运行时环境中直接访问）把源数据结构转换为对象。这意味着在对象解构的上下文中，原始值会被当成对象。这也意味着（根据 ToObject()的定义），null 和 undefined 不能被解构，否则会抛出错误。\nlet { length } = \u0026#34;foobar\u0026#34;; console.log(length); // 6  let { constructor: c } = 4; console.log(c === Number); // true  let { _ } = null; // TypeError  let { _ } = undefined; // TypeError 解构并不要求变量必须在解构表达式中声明。不过，如果是给事先声明的变量赋值，则赋值表达式必须包含在一对括号中：\nlet personName, personAge; let person = { name: \u0026#34;Matt\u0026#34;, age: 27, }; ({ name: personName, age: personAge } = person); console.log(personName, personAge); // Matt, 27 嵌套解构 #  解构对于引用嵌套的属性或赋值目标没有限制。为此，可以通过解构来复制对象属性：\nlet person = { name: \u0026#34;Matt\u0026#34;, age: 27, job: { title: \u0026#34;Software engineer\u0026#34;, }, }; let personCopy = {}; ({ name: personCopy.name, age: personCopy.age, job: personCopy.job } = person); // 因为一个对象的引用被赋值给personCopy，所以修改 // person.job对象的属性也会影响personCopy person.job.title = \u0026#34;Hacker\u0026#34;; console.log(person); // { name: \u0026#39;Matt\u0026#39;, age: 27, job: { title: \u0026#39;Hacker\u0026#39; } }  console.log(personCopy); // { name: \u0026#39;Matt\u0026#39;, age: 27, job: { title: \u0026#39;Hacker\u0026#39; } } 解构赋值可以使用嵌套结构，以匹配嵌套的属性：\nlet person = { name: \u0026#34;Matt\u0026#34;, age: 27, job: { title: \u0026#34;Software engineer\u0026#34;, }, }; // 声明title变量并将person.job.title的值赋给它 let { job: { title }, } = person; console.log(title); // Software engineer 在外层属性没有定义的情况下不能使用嵌套解构。无论源对象还是目标对象都一样：\nlet person = { job: { title: \u0026#34;Software engineer\u0026#34;, }, }; let personCopy = {}; // foo在源对象上是undefined ({ foo: { bar: personCopy.bar }, } = person); // TypeError: Cannot destructure property \u0026#39;bar\u0026#39; of \u0026#39;undefined\u0026#39; or \u0026#39;null\u0026#39;.  // job在目标对象上是undefined ({ job: { title: personCopy.job.title }, } = person); // TypeError: Cannot set property \u0026#39;title\u0026#39; of undefined 部分解构 #  需要注意的是，涉及多个属性的解构赋值是一个输出无关的顺序化操作。如果一个解构表达式涉及多个赋值，开始的赋值成功而后面的赋值出错，则整个解构赋值只会完成一部分：\nlet person = { name: \u0026#34;Matt\u0026#34;, age: 27, }; let personName, personBar, personAge; try { // person.foo是undefined，因此会抛出错误  ({ name: personName, foo: { bar: personBar }, age: personAge, } = person); } catch (e) {} console.log(personName, personBar, personAge); // Matt, undefined, undefined 参数上下文匹配 #  在函数参数列表中也可以进行解构赋值。对参数的解构赋值不会影响 arguments 对象，但可以在函数签名中声明在函数体内使用局部变量：\nlet person = { name: \u0026#34;Matt\u0026#34;, age: 27, }; function printPerson(foo, { name, age }, bar) { console.log(arguments); console.log(name, age); } function printPerson2(foo, { name: personName, age: personAge }, bar) { console.log(arguments); console.log(personName, personAge); } printPerson(\u0026#34;1st\u0026#34;, person, \u0026#34;2nd\u0026#34;); // [\u0026#39;1st\u0026#39;, { name: \u0026#39;Matt\u0026#39;, age: 27 }, \u0026#39;2nd\u0026#39;] // \u0026#39;Matt\u0026#39;, 27  printPerson2(\u0026#34;1st\u0026#34;, person, \u0026#34;2nd\u0026#34;); // [\u0026#39;1st\u0026#39;, { name: \u0026#39;Matt\u0026#39;, age: 27 }, \u0026#39;2nd\u0026#39;] // \u0026#39;Matt\u0026#39;, 27 "},{"id":8,"href":"/docs/javascript/7/7.1/","title":"理解迭代","section":"迭代器与生成器","content":"理解迭代 #  在 JavaScript 中，计数循环就是一种最简单的迭代：\nfor (let i = 1; i \u0026lt;= 10; ++i) { console.log(i); } 循环是迭代机制的基础，这是因为它可以指定迭代的次数，以及每次迭代要执行什么操作。每次循环都会在下一次迭代开始之前完成，而每次迭代的顺序都是事先定义好的。\n迭代会在一个有序集合上进行。（“有序”可以理解为集合中所有项都可以按照既定的顺序被遍历到，特别是开始和结束项有明确的定义。）数组是 JavaScript 中有序集合的最典型例子。\nlet collection = [\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;, \u0026#34;baz\u0026#34;]; for (let index = 0; index \u0026lt; collection.length; ++index) { console.log(collection[index]); } 因为数组有已知的长度，且数组每一项都可以通过索引获取，所以整个数组可以通过递增索引来遍历。\n由于如下原因，通过这种循环来执行例程并不理想。\n 迭代之前需要事先知道如何使用数据结构。数组中的每一项都只能先通过引用取得数组对象，然后再通过[]操作符取得特定索引位置上的项。这种情况并不适用于所有数据结构。 遍历顺序并不是数据结构固有的。通过递增索引来访问数据是特定于数组类型的方式，并不适用于其他具有隐式顺序的数据结构。  ES5 新增了 Array.prototype.forEach()方法，向通用迭代需求迈进了一步（但仍然不够理想）：\nlet collection = [\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;, \u0026#34;baz\u0026#34;]; collection.forEach((item) =\u0026gt; console.log(item)); // foo // bar // baz 这个方法解决了单独记录索引和通过数组对象取得值的问题。不过，没有办法标识迭代何时终止。因此这个方法只适用于数组，而且回调结构也比较笨拙。\n在 ECMAScript 较早的版本中，执行迭代必须使用循环或其他辅助结构。随着代码量增加，代码会变得越发混乱。很多语言都通过原生语言结构解决了这个问题，开发者无须事先知道如何迭代就能实现迭代操作。这个解决方案就是迭代器模式。Python、Java、C++，还有其他很多语言都对这个模式提供了完备的支持。JavaScript 在 ECMAScript 6 以后也支持了迭代器模式。\n"},{"id":9,"href":"/docs/javascript/1/1.1/","title":"简短的历史回顾","section":"什么是 JavaScript","content":"简短的历史回顾 #  随着 Web 日益流行，对客户端脚本语言的需求也越来越强烈。当时，大多数用户使用 28.8kbit/s 的调制解调器上网，但网页变得越来越大、越来越复杂。为验证简单的表单而需要大量与服务器的往返通信成为用户的痛点。想象一下，你填写完表单，单击“提交”按钮，等 30 秒处理，然后看到一条消息，告诉你有一个必填字段没填。网景在当时是引领技术革新的公司，它将开发一个客户端脚本语言来处理这种简单的数据验证提上了日程。\n1995 年，网景公司一位名叫 Brendan Eich 的工程师，开始为即将发布的 Netscape Navigator 2 开发一个叫 Mocha（后来改名为 LiveScript）的脚本语言。当时的计划是在客户端和服务器端都使用它，它在服务器端叫 LiveWire。\n为了赶上发布时间，网景与 Sun 公司结为开发联盟，共同完成 LiveScript 的开发。就在 Netscape Navigator 2 正式发布前，网景把 LiveScript 改名为 JavaScript，以便搭上媒体当时热烈炒作 Java 的顺风车。\n由于 JavaScript 1.0 很成功，网景又在 Netscape Navigator 3 中发布了 1.1 版本。尚未成熟的 Web 的受欢迎程度创造了历史新高，而网景则稳居市场领导者的位置。这时候，微软决定向 IE 投入更多资源。就在 Netscape Navigator 3 发布后不久，微软发布了 IE3，其中包含自己名为 JScript（叫这个名字是为了避免与网景发生许可纠纷）的 JavaScript 实现。1996 年 8 月，微软重磅进入 Web 浏览器领域，这是网景永远的痛，但它代表 JavaScript 作为一门语言向前迈进了一大步。\n微软的 JavaScript 实现意味着出现了两个版本的 JavaScript：Netscape Navigator 中的 JavaScript，以及 IE 中的 JScript。与 C 语言以及很多其他编程语言不同，JavaScript 还没有规范其语法或特性的标准，两个版本并存让这个问题更加突出了。随着业界担忧日甚，JavaScript 终于踏上了标准化的征程。\n1997 年，JavaScript 1.1 作为提案被提交给欧洲计算机制造商协会（Ecma）。第 39 技术委员会（TC39）承担了“标准化一门通用、跨平台、厂商中立的脚本语言的语法和语义”的任务（参见 TC39-ECMAScript）。TC39 委员会由来自网景、Sun、微软、Borland、Nombas 和其他对这门脚本语言有兴趣的公司的工程师组成。他们花了数月时间打造出 ECMA-262，也就是 ECMAScript（发音为“ek-ma-script”）这个新的脚本语言标准。\n1998 年，国际标准化组织（ISO）和国际电工委员会（IEC）也将 ECMAScript 采纳为标准（ISO/IEC-16262）。自此以后，各家浏览器均以 ECMAScript 作为自己 JavaScript 实现的依据，虽然具体实现各有不同。\n"},{"id":10,"href":"/docs/javascript/3/3.1/","title":"语法","section":"语言基础","content":"语法 #  ECMAScript 的语法很大程度上借鉴了 C 语言和其他类 C 语言，如 Java 和 Perl。熟悉这些语言的开发者，应该很容易理解 ECMAScript 宽松的语法。\n区分大小写 #  首先要知道的是，ECMAScript 中一切都区分大小写。无论是变量、函数名还是操作符，都区分大小写。换句话说，变量 test 和变量 Test 是两个不同的变量。类似地，typeof 不能作为函数名，因为它是一个关键字（后面会介绍）。但 Typeof 是一个完全有效的函数名。\n标识符 #  所谓标识符，就是变量、函数、属性或函数参数的名称。标识符可以由一或多个下列字符组成：\n第一个字符必须是一个字母、下划线（_）或美元符号（$）；\n 剩下的其他字符可以是字母、下划线、美元符号或数字。 标识符中的字母可以是扩展 ASCII（Extended ASCII）中的字母，也可以是 Unicode 的字母字符，如 À 和 Æ（但不推荐使用）。  按照惯例，ECMAScript 标识符使用驼峰大小写形式，即第一个单词的首字母小写，后面每个单词的首字母大写，如：\nfirstSecond myCar doSomethingImportant 虽然这种写法并不是强制性的，但因为这种形式跟 ECMAScript 内置函数和对象的命名方式一致，所以算是最佳实践。\n注意 关键字、保留字、true、false 和 null 不能作为标识符。具体内容请参考 3.2 节。  注释 #  ECMAScript 采用 C 语言风格的注释，包括单行注释和块注释。单行注释以两个斜杠字符开头，如：\n// 单行注释 块注释以一个斜杠和一个星号（/）开头，以它们的反向组合（/）结尾，如：\n/* 这是多行 注释 */ 严格模式 #  ECMAScript 5 增加了严格模式（strict mode）的概念。严格模式是一种不同的 JavaScript 解析和执行模型，ECMAScript 3 的一些不规范写法在这种模式下会被处理，对于不安全的活动将抛出错误。要对整个脚本启用严格模式，在脚本开头加上这一行：\n\u0026#34;use strict\u0026#34;; 虽然看起来像个没有赋值给任何变量的字符串，但它其实是一个预处理指令。任何支持的 JavaScript 引擎看到它都会切换到严格模式。选择这种语法形式的目的是不破坏 ECMAScript 3 语法。\n也可以单独指定一个函数在严格模式下执行，只要把这个预处理指令放到函数体开头即可：\nfunction doSomething() { \u0026#34;use strict\u0026#34;; // 函数体 } 严格模式会影响 JavaScript 执行的很多方面，因此后面文章中在用到它时会明确指出来。所有现代浏览器都支持严格模式。\n语句 #  ECMAScript 中的语句以分号结尾。省略分号意味着由解析器确定语句在哪里结尾，如下面的例子所示：\nlet sum = a + b; // 没有分号也有效，但不推荐 let diff = a - b; // 加分号有效，推荐 即使语句末尾的分号不是必需的，也应该加上。记着加分号有助于防止省略造成的问题，比如可以避免输入内容不完整。此外，加分号也便于开发者通过删除空行来压缩代码（如果没有结尾的分号，只删除空行，则会导致语法错误）。加分号也有助于在某些情况下提升性能，因为解析器会尝试在合适的位置补上分号以纠正语法错误。\n多条语句可以合并到一个 C 语言风格的代码块中。代码块由一个左花括号（{）标识开始，一个右花括号（}）标识结束：\nif (test) { test = false; console.log(test); } if 之类的控制语句只在执行多条语句时要求必须有代码块。不过，最佳实践是始终在控制语句中使用代码块，即使要执行的只有一条语句，如下例所示：\n// 有效，但容易导致错误，应该避免 if (test) console.log(test); // 推荐 if (test) { console.log(test); } 在控制语句中使用代码块可以让内容更清晰，在需要修改代码时也可以减少出错的可能性。\n"},{"id":11,"href":"/docs/javascript/2/","title":"HTML 中的 JavaScript","section":"Javascript","content":"HTML 中的 JavaScript #  将 JavaScript 引入网页，首先要解决它与网页的主导语言 HTML 的关系问题。在 JavaScript 早期，网景公司的工作人员希望在将 JavaScript 引入 HTML 页面的同时，不会导致页面在其他浏览器中渲染出问题。通过反复试错和讨论，他们最终做出了一些决定，并达成了向网页中引入通用脚本能力的共识。当初他们的很多工作得到了保留，并且最终形成了 HTML 规范。\n"},{"id":12,"href":"/docs/javascript/1/1.2/","title":"JavaScript 实现","section":"什么是 JavaScript","content":"JavaScript 实现 #  虽然 JavaScript 和 ECMAScript 基本上是同义词，但 JavaScript 远远不限于 ECMA-262 所定义的那样。没错，完整的 JavaScript 实现包含以下几个部分（见图 1-1）：\n 核心（ECMAScript） 文档对象模型（DOM） 浏览器对象模型（BOM）  ECMAScript #  ECMAScript，即 ECMA-262 定义的语言，并不局限于 Web 浏览器。事实上，这门语言没有输入和输出之类的方法。ECMA-262 将这门语言作为一个基准来定义，以便在它之上再构建更稳健的脚本语言。Web 浏览器只是 ECMAScript 实现可能存在的一种宿主环境（host environment）。宿主环境提供 ECMAScript 的基准实现和与环境自身交互必需的扩展。扩展（比如 DOM）使用 ECMAScript 核心类型和语法，提供特定于环境的额外功能。其他宿主环境还有服务器端 JavaScript 平台 Node.js 和即将被淘汰的 Adobe Flash。\n如果不涉及浏览器的话，ECMA-262 到底定义了什么？在基本的层面，它描述这门语言的如下部分：\n 语法 类型 语句 关键字 保留字 操作符 全局对象  ECMAScript 只是对实现这个规范描述的所有方面的一门语言的称呼。JavaScript 实现了 ECMAScript，而 Adobe ActionScript 同样也实现了 ECMAScript。\nECMAScript 版本 #  ECMAScript 不同的版本以“edition”表示（也就是描述特定实现的 ECMA-262 的版本）。ECMA-262 最近的版本是第 10 版，发布于 2019 年 6 月。ECMA-262 的第 1 版本质上跟网景的 JavaScript 1.1 相同，只不过删除了所有浏览器特定的代码，外加少量细微的修改。ECMA-262 要求支持 Unicode 标准（以支持多语言），而且对象要与平台无关（Netscape JavaScript 1.1 的对象不是这样，比如它的 Date 对象就依赖平台）。这也是 JavaScript 1.1 和 JavaScript 1.2 不符合 ECMA-262 第 1 版要求的原因。\nECMA-262 第 2 版只是做了一些编校工作，主要是为了更新之后严格符合 ISO/IEC-16262 的要求，并没有增减或改变任何特性。ECMAScript 实现通常不使用第 2 版来衡量符合性（conformance）。\nECMA-262 第 3 版第一次真正对这个标准进行更新，更新了字符串处理、错误定义和数值输出。此外还增加了对正则表达式、新的控制语句、try/catch 异常处理的支持，以及为了更好地让标准国际化所做的少量修改。对很多人来说，这标志着 ECMAScript 作为一门真正的编程语言的时代终于到来了。\nECMA-262 第 4 版是对这门语言的一次彻底修订。作为对 JavaScript 在 Web 上日益成功的回应，开发者开始修订 ECMAScript 以满足全球 Web 开发日益增长的需求。为此，Ecma T39 再次被召集起来，以决定这门语言的未来。结果，他们制定的规范几乎在第 3 版基础上完全定义了一门新语言。第 4 版包括强类型变量、新语句和数据结构、真正的类和经典的继承，以及操作数据的新手段。\n与此同时，TC39 委员会的一个子委员会也提出了另外一份提案，叫作“ECMAScript 3.1”，只对这门语言进行了较少的改进。这个子委员会的人认为第 4 版对这门语言来说跳跃太大了。因此，他们提出了一个改动较小的提案，只要在现有 JavaScript 引擎基础上做一些增改就可以实现。最终，ES3.1 子委员会赢得了 TC39 委员会的支持，ECMA-262 第 4 版在正式发布之前被放弃。\nECMAScript 3.1 变成了 ECMA-262 的第 5 版，于 2009 年 12 月 3 日正式发布。第 5 版致力于厘清第 3 版存在的歧义，也增加了新功能。新功能包括原生的解析和序列化 JSON 数据的 JSON 对象、方便继承和高级属性定义的方法，以及新的增强 ECMAScript 引擎解释和执行代码能力的严格模式。第 5 版在 2011 年 6 月发布了一个维护性修订版，这个修订版只更正了规范中的错误，并未增加任何新的语言或库特性。\nECMA-262 第 6 版，俗称 ES6、ES2015 或 ES Harmony（和谐版），于 2015 年 6 月发布。这一版包含了大概这个规范有史以来最重要的一批增强特性。ES6 正式支持了类、模块、迭代器、生成器、箭头函数、期约、反射、代理和众多新的数据类型。\nECMA-262 第 7 版，也称为 ES7 或 ES2016，于 2016 年 6 月发布。这次修订只包含少量语法层面的增强，如 Array.prototype.includes 和指数操作符。\nECMA-262 第 8 版，也称为 ES8、ES2017，完成于 2017 年 6 月。这一版主要增加了异步函数（async/await）、SharedArrayBuffer 及 Atomics API，以及 Object.values() / Object.entries() / Object.getOwnPropertyDescriptors() 和字符串填充方法，另外明确支持对象字面量最后的逗号。\nECMA-262 第 9 版，也称为 ES9、ES2018，发布于 2018 年 6 月。这次修订包括异步迭代、剩余和扩展属性、一组新的正则表达式特性、Promise finally()，以及模板字面量修订。\nECMA-262 第 10 版，也称为 ES10、ES2019，发布于 2019 年 6 月。这次修订增加了 Array.prototype.flat()/flatMap()、String.prototype.trimStart()/trimEnd()、Object.fromEntries()方法，以及 Symbol.prototype.description 属性，明确定义了 Function.prototype.toString()的返回值并固定了 Array.prototype.sort()的顺序。另外，这次修订解决了与 JSON 字符串兼容的问题，并定义了 catch 子句的可选绑定。\nECMAScript 符合性是什么意思 #  ECMA-262 阐述了什么是 ECMAScript 符合性。要成为 ECMAScript 实现，必须满足下列条件：\n 支持 ECMA-262 中描述的所有“类型、值、对象、属性、函数，以及程序语法与语义”； 支持 Unicode 字符标准。  此外，符合性实现还可以满足下列要求。\n 增加 ECMA-262 中未提及的“额外的类型、值、对象、属性和函数”。ECMA-262 所说的这些额外内容主要指规范中未给出的新对象或对象的新属性。 支持 ECMA-262 中没有定义的“程序和正则表达式语法”（意思是允许修改和扩展内置的正则表达式特性）。 以上条件为实现开发者基于 ECMAScript 开发语言提供了极大的权限和灵活度，也是其广受欢迎的原因之一。  浏览器对 ECMAScript 的支持 #  1996 年，Netscape Navigator 3 发布时包含了 JavaScript 1.1。JavaScript 1.1 规范随后被提交给 Ecma，作为对新的 ECMA-262 标准的建议。随着 JavaScript 迅速走红，网景非常愿意开发 1.2 版。可是有个问题：Ecma 尚未接受网景的建议。\nNetscape Navigator 3 发布后不久，微软推出了 IE3。IE 的这个版本包含了 JScript 1.0，本意是提供与 JavaScript 1.1 相同的功能。不过，由于缺少很多文档，而且还有不少重复性功能，JScript 1.0 远远没有 JavaScript 1.1 那么强大。\nJScript 的再次更新出现在 IE4 中的 JScript 3.0（2.0 版是在 Microsoft Internet Information Server 3.0 中发布的，但从未包含在浏览器中）。微软发新闻稿称 JScript 3.0 是世界上第一门真正兼容 Ecma 标准的脚本语言。当时 ECMA-262 还没制定完成，因此 JScript 3.0 遭受了与 JavaScript 1.2 同样的命运，它同样没有遵守最终的 ECMAScript 标准。\n网景又在 Netscape Navigator 4.06 中将其 JavaScript 版本升级到 1.3，因此做到了与 ECMA-262 第 1 版完全兼容。JavaScript 1.3 增加了对 Unicode 标准的支持，并做到了所有对象都与平台无关，同时保留了 JavaScript 1.2 所有的特性。\n后来，当网景以 Mozilla 项目的名义向公众发布其源代码时，人们都期待 Netscape Navigator 5 中会包含 JavaScript 1.4。可是，一个完全重新设计网景代码的激进决定导致了人们的希望落空。JavaScript 1.4 只在 Netscape Enterprise Server 中作为服务器端语言发布了，从来就没有进入浏览器。\n到了 2008 年，五大浏览器（IE、Firefox、Safari、Chrome 和 Opera）全部兼容 ECMA-262 第 3 版。IE8 率先实现 ECMA-262 第 5 版，并在 IE9 中完整支持。Firefox 4 很快也做到了。下表列出了主要的浏览器版本对 ECMAScript 的支持情况。\n   浏览器 ECMAScript 符合性     Netscape Navigator 2 —   Netscape Navigator 3 —   Netscape Navigator 4~4.05 —   Netscape Navigator 4.06~4.79 第 1 版   Netscape 6+（Mozilla 0.6.0+） 第 3 版   IE3 —   IE4 —   IE5 第 1 版   IE5.5~8 第 3 版   IE9 第 5 版（部分）   IE10~11 第 5 版   Edge 12+ 第 6 版   Opera 6~7.1 第 2 版   Opera 7.2+ 第 3 版   Opera 15~28 第 5 版   Opera 29~35 第 6 版（部分）   Opera 36+ 第 6 版   Safari 1~2.0.x 第 3 版（部分）   Safari 3.1~5.1 第 5 版（部分）   Safari 6~8 第 5 版   Safari 9+ 第 6 版   iOS Safari 3.2~5.1 第 5 版（部分）   iOS Safari 6~8.4 第 5 版   iOS Safari 9.2+ 第 6 版   Chrome 1~3 第 3 版   Chrome 4~22 第 5 版（部分）   Chrome 23+ 第 5 版   Chrome 42~48 第 6 版（部分）   Chrome 49+ 第 6 版   Firefox 1~2 第 3 版   Firefox 3.0.x~20 第 5 版（部分）   Firefox 21~44 第 5 版   Firefox 45+ 第 6 版    DOM #  文档对象模型（DOM，Document Object Model）是一个应用编程接口（API），用于在 HTML 中使用扩展的 XML。DOM 将整个页面抽象为一组分层节点。HTML 或 XML 页面的每个组成部分都是一种节点，包含不同的数据。比如下面的 HTML 页面：\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Sample Page\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Hello World!\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 这些代码通过 DOM 可以表示为一组分层节点，如图 1-2 所示。\nDOM 通过创建表示文档的树，让开发者可以随心所欲地控制网页的内容和结构。使用 DOM API，可以轻松地删除、添加、替换、修改节点。\n为什么 DOM 是必需的 #  在 IE4 和 Netscape Navigator 4 支持不同形式的动态 HTML（DHTML）的情况下，开发者首先可以做到不刷新页面而修改页面外观和内容。这代表了 Web 技术的一个巨大进步，但也暴露了很大的问题。由于网景和微软采用不同思路开发 DHTML，开发者写一个 HTML 页面就可以在任何浏览器中运行的好日子就此终结。\n为了保持 Web 跨平台的本性，必须要做点什么。人们担心如果无法控制网景和微软各行其是，那么 Web 就会发生分裂，导致人们面向浏览器开发网页。就在这时，万维网联盟（W3C，World Wide Web Consortium）开始了制定 DOM 标准的进程。\nDOM 级别 #  1998 年 10 月，DOM Level 1 成为 W3C 的推荐标准。这个规范由两个模块组成：DOM Core 和 DOM HTML。前者提供了一种映射 XML 文档，从而方便访问和操作文档任意部分的方式；后者扩展了前者，并增加了特定于 HTML 的对象和方法。\n注意\nDOM 并非只能通过 JavaScript 访问，而且确实被其他很多语言实现了。不过对于浏览器来说，DOM 就是使用 ECMAScript 实现的，如今已经成为 JavaScript 语言的一大组成部分。  DOM Level 1 的目标是映射文档结构，而 DOM Level 2 的目标则宽泛得多。这个对最初 DOM 的扩展增加了对（DHTML 早就支持的）鼠标和用户界面事件、范围、遍历（迭代 DOM 节点的方法）的支持，而且通过对象接口支持了层叠样式表（CSS）。另外，DOM Level 1 中的 DOM Core 也被扩展以包含对 XML 命名空间的支持。\nDOM Level 2 新增了以下模块，以支持新的接口。\n DOM 视图：描述追踪文档不同视图（如应用 CSS 样式前后的文档）的接口。 DOM 事件：描述事件及事件处理的接口。 DOM 样式：描述处理元素 CSS 样式的接口。 DOM 遍历和范围：描述遍历和操作 DOM 树的接口。  DOM Level 3 进一步扩展了 DOM，增加了以统一的方式加载和保存文档的方法（包含在一个叫 DOM Load and Save 的新模块中），还有验证文档的方法（DOM Validation）。在 Level 3 中，DOM Core 经过扩展支持了所有 XML 1.0 的特性，包括 XML Infoset、XPath 和 XML Base。\n目前，W3C 不再按照 Level 来维护 DOM 了，而是作为 DOM Living Standard 来维护，其快照称为 DOM4。DOM4 新增的内容包括替代 Mutation Events 的 Mutation Observers。\n注意\n在阅读关于 DOM 的资料时，你可能会看到 DOM Level 0 的说法。注意，并没有一个标准叫“DOM Level 0”，这只是 DOM 历史中的一个参照点。DOM Level 0 可以看作 IE4 和 Netscape Navigator 4 中最初支持的 DHTML。  其他 DOM #  除了 DOM Core 和 DOM HTML 接口，有些其他语言也发布了自己的 DOM 标准。下面列出的语言是基于 XML 的，每一种都增加了该语言独有的 DOM 方法和接口：\n 可伸缩矢量图（SVG，Scalable Vector Graphics） 数学标记语言（MathML，Mathematical Markup Language） 同步多媒体集成语言（SMIL，Synchronized Multimedia Integration Language）  此外，还有一些语言开发了自己的 DOM 实现，比如 Mozilla 的 XML 用户界面语言（XUL，XML User Interface Language）。不过，只有前面列表中的语言是 W3C 推荐标准。\nWeb 浏览器对 DOM 的支持情况 #  DOM 标准在 Web 浏览器实现它之前就已经作为标准发布了。IE 在第 5 版中尝试支持 DOM，但直到 5.5 版才开始真正支持，该版本实现了 DOM Level 1 的大部分。IE 在第 6 版和第 7 版中都没有实现新特性，第 8 版中修复了一些问题。\n网景在 Netscape 6（Mozilla 0.6.0）之前都不支持 DOM。Netscape 7 之后，Mozilla 把开发资源转移到开发 Firefox 浏览器上。Firefox 3+支持全部的 Level 1、几乎全部的 Level 2，以及 Level 3 的某些部分。（Mozilla 开发团队的目标是打造百分之百兼容标准的浏览器，他们的工作也得到了应有的回报。）\n支持 DOM 是浏览器厂商的重中之重，每个版本发布都会改进支持度。下表展示了主流浏览器支持 DOM 的情况。\n   浏览器 DOM 兼容     Netscape Navigator 1~4.x —   Netscape 6+（Mozilla 0.6.0+） Level 1、Level 2（几乎全部）、Level 3（部分）   IE2~4.x —   IE5 Level 1（很少）   IE5.5~8 Level 1（几乎全部）   IE9+ Level 1、Level 2、Level 3   Edge Level 1、Level 2、Level 3   Opera 1~6 —   Opera 7~8.x Level 1（几乎全部）、Level 2（部分）   Opera 9~9.9 Level 1、Level 2（几乎全部）、Level 3（部分）   Opera 10+ Level 1、Level 2、Level 3（部分）   Safari 1.0.x Level 1   Safari 2+ Level 1、Level 2（部分）、Level 3（部分）   iOS Safari 3.2+ Level 1、Level 2（部分）、Level 3（部分）   Chrome 1+ Level 1、Level 2（部分）、Level 3（部分）   Firefox 1+ Level 1、Level 2（几乎全部）、Level 3（部分）    注意 上表中兼容性的状态会随时间而变化，其中的内容仅反映本文写作时的状态。  BOM #  IE3 和 Netscape Navigator 3 提供了浏览器对象模型（BOM） API，用于支持访问和操作浏览器的窗口。使用 BOM，开发者可以操控浏览器显示页面之外的部分。而 BOM 真正独一无二的地方，当然也是问题最多的地方，就是它是唯一一个没有相关标准的 JavaScript 实现。HTML5 改变了这个局面，这个版本的 HTML 以正式规范的形式涵盖了尽可能多的 BOM 特性。由于 HTML5 的出现，之前很多与 BOM 有关的问题都迎刃而解了。\n总体来说，BOM 主要针对浏览器窗口和子窗口（frame），不过人们通常会把任何特定于浏览器的扩展都归在 BOM 的范畴内。比如，下面就是这样一些扩展：\n 弹出新浏览器窗口的能力； 移动、缩放和关闭浏览器窗口的能力； navigator 对象，提供关于浏览器的详尽信息； location 对象，提供浏览器加载页面的详尽信息； screen 对象，提供关于用户屏幕分辨率的详尽信息； performance 对象，提供浏览器内存占用、导航行为和时间统计的详尽信息； 对 cookie 的支持； 其他自定义对象，如 XMLHttpRequest 和 IE 的 ActiveXObject。  因为在很长时间内都没有标准，所以每个浏览器实现的都是自己的 BOM。有一些所谓的事实标准，比如对于 window 对象和 navigator 对象，每个浏览器都会给它们定义自己的属性和方法。现在有了 HTML5，BOM 的实现细节应该会日趋一致。要查阅关于 BOM 的详细介绍，请移步这里。\n"},{"id":13,"href":"/docs/javascript/2/2.2/","title":"行内代码与外部文件","section":"HTML 中的 JavaScript","content":"行内代码与外部文件 #  虽然可以直接在 HTML 文件中嵌入 JavaScript 代码，但通常认为最佳实践是尽可能将 JavaScript 代码放在外部文件中。不过这个最佳实践并不是明确的强制性规则。推荐使用外部文件的理由如下。\n 可维护性。JavaScript 代码如果分散到很多 HTML 页面，会导致维护困难。而用一个目录保存所有 JavaScript 文件，则更容易维护，这样开发者就可以独立于使用它们的 HTML 页面来编辑代码。 缓存。浏览器会根据特定的设置缓存所有外部链接的 JavaScript 文件，这意味着如果两个页面都用到同一个文件，则该文件只需下载一次。这最终意味着页面加载更快。 适应未来。通过把 JavaScript 放到外部文件中，就不必考虑用 XHTML 或前面提到的注释黑科技。包含外部 JavaScript 文件的语法在 HTML 和 XHTML 中是一样的。  在配置浏览器请求外部文件时，要重点考虑的一点是它们会占用多少带宽。在 SPDY/HTTP2 中，预请求的消耗已显著降低，以轻量、独立 JavaScript 组件形式向客户端送达脚本更具优势。\n比如，第一个页面包含如下脚本：\n\u0026lt;script src=\u0026#34;mainA.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;component1.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;component2.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;component3.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; ... 后续页面可能包含如下脚本：\n\u0026lt;script src=\u0026#34;mainB.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;component3.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;component4.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;component5.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; ... 在初次请求时，如果浏览器支持 SPDY/HTTP2，就可以从同一个地方取得一批文件，并将它们逐个放到浏览器缓存中。从浏览器角度看，通过 SPDY/HTTP2 获取所有这些独立的资源与获取一个大 JavaScript 文件的延迟差不多。\n在第二个页面请求时，由于你已经把应用程序切割成了轻量可缓存的文件，第二个页面也依赖的某些组件此时已经存在于浏览器缓存中了。\n当然，这里假设浏览器支持 SPDY/HTTP2，只有比较新的浏览器才满足。如果你还想支持那些比较老的浏览器，可能还是用一个大文件更合适。\n"},{"id":14,"href":"/docs/javascript/1/1.3/","title":"JavaScript 版本","section":"什么是 JavaScript","content":"JavaScript 版本 #  作为网景的继承者，Mozilla 是唯一仍在延续最初 JavaScript 版本编号的浏览器厂商。当初网景在将其源代码开源时（项目名为 Mozilla Project），JavaScript 在其浏览器中最后的版本是 1.3。（前面提到过，1.4 版是专门为服务器实现的。）因为 Mozilla Foundation 在持续开发 JavaScript，为它增加新特性、关键字和语法，所以 JavaScript 的版本号也在不断递增。下表展示了 Netscape/Mozilla 浏览器发布的历代 JavaScript 版本。\n   浏览器 JavaScript 版本     Netscape Navigator 2 1.0   Netscape Navigator 3 1.1   Netscape Navigator 4 1.2   Netscape Navigator 4.06 1.3   Netscape 6+（Mozilla 0.6.0+） 1.5   Firefox 1 1.5   Firefox 1.5 1.6   Firefox 2 1.7   Firefox 3 1.8   Firefox 3.5 1.8.1   Firefox 3.6 1.8.2   Firefox 4 1.8.5    这种版本编号方式是根据 Firefox 4 要发布 JavaScript 2.0 决定的，在此之前版本号的每次递增，反映的是 JavaScript 实现逐渐接近 2.0 建议。虽然这是最初的计划，但 JavaScript 的发展让这个计划变得不可能。JavaScript 2.0 作为一个目标已经不存在了，而这种版本号编排方式在 Firefox 4 发布后就终止了。\n注意 Netscape/Mozilla 仍然沿用这种版本方案。而 IE 的 JScript 有不同的版本号规则。这些 JScript 版本与上表提到的 JavaScript 版本并不对应。此外，多数浏览器对 JavaScript 的支持，指的是实现 ECMAScript 和 DOM 的程度。  "},{"id":15,"href":"/docs/javascript/2/2.3/","title":"文档模式","section":"HTML 中的 JavaScript","content":"文档模式 #  IE5.5 发明了文档模式的概念，即可以使用 doctype 切换文档模式。最初的文档模式有两种：混杂模式（quirks mode）和标准模式（standards mode）。前者让 IE 像 IE5 一样（支持一些非标准的特性），后者让 IE 具有兼容标准的行为。虽然这两种模式的主要区别只体现在通过 CSS 渲染的内容方面，但对 JavaScript 也有一些关联影响，或称为副作用。\nIE 初次支持文档模式切换以后，其他浏览器也跟着实现了。随着浏览器的普遍实现，又出现了第三种文档模式：准标准模式（almost standards mode）。这种模式下的浏览器支持很多标准的特性，但是没有标准规定得那么严格。主要区别在于如何对待图片元素周围的空白（在表格中使用图片时最明显）。\n混杂模式在所有浏览器中都以省略文档开头的 doctype 声明作为开关。这种约定并不合理，因为混杂模式在不同浏览器中的差异非常大，不使用黑科技基本上就没有浏览器一致性可言。\n标准模式通过下列几种文档类型声明开启：\n\u0026lt;!-- HTML 4.01 Strict --\u0026gt; \u0026lt;!DOCTYPE html PUBLIC \u0026#34;-//W3C//DTD HTML 4.01//EN\u0026#34; \u0026#34;http://www.w3.org/TR/html4/strict.dtd\u0026#34;\u0026gt; \u0026lt;!-- XHTML 1.0 Strict --\u0026gt; \u0026lt;!DOCTYPE html PUBLIC \u0026#34;-//W3C//DTD XHTML 1.0 Strict//EN\u0026#34; \u0026#34;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\u0026#34;\u0026gt; \u0026lt;!-- HTML5 --\u0026gt; \u0026lt;!DOCTYPE html\u0026gt; 准标准模式通过过渡性文档类型（Transitional）和框架集文档类型（Frameset）来触发：\n\u0026lt;!-- HTML 4.01 Transitional --\u0026gt; \u0026lt;!DOCTYPE html PUBLIC \u0026#34;-//W3C//DTD HTML 4.01 Transitional//EN\u0026#34; \u0026#34;http://www.w3.org/TR/html4/loose.dtd\u0026#34;\u0026gt; \u0026lt;!-- HTML 4.01 Frameset --\u0026gt; \u0026lt;!DOCTYPE html PUBLIC \u0026#34;-//W3C//DTD HTML 4.01 Frameset//EN\u0026#34; \u0026#34;http://www.w3.org/TR/html4/frameset.dtd\u0026#34;\u0026gt; \u0026lt;!-- XHTML 1.0 Transitional --\u0026gt; \u0026lt;!DOCTYPE html PUBLIC \u0026#34;-//W3C//DTD XHTML 1.0 Transitional//EN\u0026#34; \u0026#34;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\u0026#34;\u0026gt; \u0026lt;!-- XHTML 1.0 Frameset --\u0026gt; \u0026lt;!DOCTYPE html PUBLIC \u0026#34;-//W3C//DTD XHTML 1.0 Frameset//EN\u0026#34; \u0026#34;http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd\u0026#34;\u0026gt; 准标准模式与标准模式非常接近，很少需要区分。人们在说到“标准模式”时，可能指其中任何一个。而对文档模式的检测也不会区分它们。本系列后面所说的标准模式，指的就是除混杂模式以外的模式。\n"},{"id":16,"href":"/docs/javascript/3/","title":"语言基础","section":"Javascript","content":"语言基础 #  任何语言的核心所描述的都是这门语言在最基本的层面上如何工作，涉及语法、操作符、数据类型以及内置功能，在此基础之上才可以构建复杂的解决方案。如前所述，ECMA-262 以一个名为 ECMAScript 的伪语言的形式，定义了 JavaScript 的所有这些方面。\nECMA-262 第 5 版（ES5）定义的 ECMAScript，是目前为止实现得最为广泛（即受浏览器支持最好）的一个版本。第 6 版（ES6）在浏览器中的实现（即受支持）程度次之。到 2017 年底，大多数主流浏览器几乎或全部实现了这一版的规范。为此，本篇接下来的内容主要基于 ECMAScript 第 6 版。\n"},{"id":17,"href":"/docs/javascript/2/2.4/","title":"\u003cnoscript\u003e 元素","section":"HTML 中的 JavaScript","content":"\u0026lt;noscript\u0026gt; 元素 #  针对早期浏览器不支持 JavaScript 的问题，需要一个页面优雅降级的处理方案。最终，\u0026lt;noscript\u0026gt; 元素出现，被用于给不支持 JavaScript 的浏览器提供替代内容。虽然如今的浏览器已经 100%支持 JavaScript，但对于禁用 JavaScript 的浏览器来说，这个元素仍然有它的用处。\n\u0026lt;noscript\u0026gt; 元素可以包含任何可以出现在 \u0026lt;body\u0026gt; 中的 HTML 元素，\u0026lt;script\u0026gt; 除外。在下列两种情况下，浏览器将显示包含在 \u0026lt;noscript\u0026gt; 中的内容：\n 浏览器不支持脚本； 浏览器对脚本的支持被关闭。  任何一个条件被满足，包含在 \u0026lt;noscript\u0026gt; 中的内容就会被渲染。否则，浏览器不会渲染 \u0026lt;noscript\u0026gt; 中的内容。\n下面是一个例子：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Example HTML Page\u0026lt;/title\u0026gt; \u0026lt;script defer=\u0026#34;defer\u0026#34; src=\u0026#34;example1.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script defer=\u0026#34;defer\u0026#34; src=\u0026#34;example2.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;noscript\u0026gt; \u0026lt;p\u0026gt;This page requires a JavaScript-enabled browser.\u0026lt;/p\u0026gt; \u0026lt;/noscript\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 这个例子是在脚本不可用时让浏览器显示一段话。如果浏览器支持脚本，则用户永远不会看到它。\n"},{"id":18,"href":"/docs/javascript/4/","title":"变量、作用域与内存","section":"Javascript","content":"变量、作用域与内存 #  相比于其他语言，JavaScript 中的变量可谓独树一帜。正如 ECMA-262 所规定的，JavaScript 变量是松散类型的，而且变量不过就是特定时间点一个特定值的名称而已。由于没有规则定义变量必须包含什么数据类型，变量的值和数据类型在脚本生命期内可以改变。这样的变量很有意思，很强大，当然也有不少问题。本篇会剖析错综复杂的变量。\n"},{"id":19,"href":"/docs/javascript/1/1.4/","title":"小结","section":"什么是 JavaScript","content":"小结 #  JavaScript 是一门用来与网页交互的脚本语言，包含以下三个组成部分。\n ECMAScript：由 ECMA-262 定义并提供核心功能。 文档对象模型（DOM）：提供与网页内容交互的方法和接口。 浏览器对象模型（BOM）：提供与浏览器交互的方法和接口。  JavaScript 的这三个部分得到了五大 Web 浏览器（IE、Firefox、Chrome、Safari 和 Opera）不同程度的支持。所有浏览器基本上对 ES5（ECMAScript 5）提供了完善的支持，而对 ES6（ECMAScript 6）和 ES7（ECMAScript 7）的支持度也在不断提升。这些浏览器对 DOM 的支持各不相同，但对 Level 3 的支持日益趋于规范。HTML5 中收录的 BOM 会因浏览器而异，不过开发者仍然可以假定存在很大一部分公共特性。\n"},{"id":20,"href":"/docs/javascript/5/","title":"基本引用类型","section":"Javascript","content":"基本引用类型 #  引用值（或者对象）是某个特定引用类型的实例。在 ECMAScript 中，引用类型是把数据和功能组织到一起的结构，经常被人错误地称作“类”。虽然从技术上讲 JavaScript 是一门面向对象语言，但 ECMAScript 缺少传统的面向对象编程语言所具备的某些基本结构，包括类和接口。引用类型有时候也被称为对象定义，因为它们描述了自己的对象应有的属性和方法。\n对象被认为是某个特定引用类型的实例。新对象通过使用 new 操作符后跟一个构造函数（constructor）来创建。构造函数就是用来创建新对象的函数，比如下面这行代码：\nlet now = new Date(); 注意\n引用类型虽然有点像类，但跟类并不是一个概念。为避免混淆，本篇后面不会使用术语“类”。  这行代码创建了引用类型 Date 的一个新实例，并将它保存在变量 now 中。Date()在这里就是构造函数，它负责创建一个只有默认属性和方法的简单对象。ECMAScript 提供了很多像 Date 这样的原生引用类型，帮助开发者实现常见的任务。\n注意\n函数也是一种引用类型，但有关函数的内容太多了，一章放不下。要查阅函数相关内容请移步这里。  "},{"id":21,"href":"/docs/javascript/2/2.5/","title":"小结","section":"HTML 中的 JavaScript","content":"小结 #  JavaScript 是通过 \u0026lt;script\u0026gt; 元素插入到 HTML 页面中的。这个元素可用于把 JavaScript 代码嵌入到 HTML 页面中，跟其他标记混合在一起，也可用于引入保存在外部文件中的 JavaScript。本篇的重点可以总结如下。\n 要包含外部 JavaScript 文件，必须将 src 属性设置为要包含文件的 URL。文件可以跟网页在同一台服务器上，也可以位于完全不同的域。 所有 \u0026lt;script\u0026gt; 元素会依照它们在网页中出现的次序被解释。在不使用 defer 和 async 属性的情况下，包含在 \u0026lt;script\u0026gt; 元素中的代码必须严格按次序解释。 对不推迟执行的脚本，浏览器必须解释完位于 \u0026lt;script\u0026gt; 元素中的代码，然后才能继续渲染页面的剩余部分。为此，通常应该把 \u0026lt;script\u0026gt; 元素放到页面末尾，介于主内容之后及 \u0026lt;/body\u0026gt; 标签之前。 可以使用 defer 属性把脚本推迟到文档渲染完毕后再执行。推迟的脚本原则上按照它们被列出的次序执行。 可以使用 async 属性表示脚本不需要等待其他脚本，同时也不阻塞文档渲染，即异步加载。异步脚本不能保证按照它们在页面中出现的次序执行。 -通过使用 \u0026lt;noscript\u0026gt; 元素，可以指定在浏览器不支持脚本时显示的内容。如果浏览器支持并启用脚本，则 \u0026lt;noscript\u0026gt; 元素中的任何内容都不会被渲染。  "},{"id":22,"href":"/docs/javascript/6/","title":"集合引用类型","section":"Javascript","content":"集合引用类型 #  本篇内容：\n 对象 数组与定型数组 Map、WeakMap、Set 以及 WeakSet 类型  "},{"id":23,"href":"/docs/javascript/7/","title":"迭代器与生成器","section":"Javascript","content":"迭代器与生成器 #  迭代的英文“iteration”源自拉丁文 itero，意思是“重复”或“再来”。在软件开发领域，“迭代”的意思是按照顺序反复多次执行一段程序，通常会有明确的终止条件。ECMAScript 6 规范新增了两个高级特性：迭代器和生成器。使用这两个特性，能够更清晰、高效、方便地实现迭代。\n"},{"id":24,"href":"/docs/javascript/8/","title":"对象、类与面向对象编程","section":"Javascript","content":"对象、类与面向对象编程 #  ECMA-262 将对象定义为一组属性的无序集合。严格来说，这意味着对象就是一组没有特定顺序的值。对象的每个属性或方法都由一个名称来标识，这个名称映射到一个值。正因为如此（以及其他还未讨论的原因），可以把 ECMAScript 的对象想象成一张散列表，其中的内容就是一组名/值对，值可以是数据或者函数。\n"},{"id":25,"href":"/docs/javascript/9/","title":"代理与反射","section":"Javascript","content":"代理与反射 #  ECMAScript 6 新增的代理和反射为开发者提供了拦截并向基本操作嵌入额外行为的能力。具体地说，可以给目标对象定义一个关联的代理对象，而这个代理对象可以作为抽象的目标对象来使用。在对目标对象的各种操作影响目标对象之前，可以在代理对象中对这些操作加以控制。\n对刚刚接触这个主题的开发者而言，代理是一个比较模糊的概念，而且还夹杂着很多新术语。其实只要看几个例子，就很容易理解了。\n注意 在 ES6 之前，ECMAScript 中并没有类似代理的特性。由于代理是一种新的基础性语言能力，很多转译程序都不能把代理行为转换为之前的 ECMAScript 代码，因为代理的行为实际上是无可替代的。为此，代理和反射只在百分之百支持它们的平台上有用。可以检测代理是否存在，不存在则提供后备代码。不过这会导致代码冗余，因此并不推荐。  "},{"id":26,"href":"/docs/javascript/10/","title":"函数","section":"Javascript","content":"函数 #  函数是 ECMAScript 中最有意思的部分之一，这主要是因为函数实际上是对象。每个函数都是 Function 类型的实例，而 Function 也有属性和方法，跟其他引用类型一样。因为函数是对象，所以函数名就是指向函数对象的指针，而且不一定与函数本身紧密绑定。函数通常以函数声明的方式定义，比如：\nfunction sum(num1, num2) { return num1 + num2; } 注意函数定义最后没有加分号。\n另一种定义函数的语法是函数表达式。函数表达式与函数声明几乎是等价的：\nlet sum = function (num1, num2) { return num1 + num2; }; 这里，代码定义了一个变量 sum 并将其初始化为一个函数。注意 function 关键字后面没有名称，因为不需要。这个函数可以通过变量 sum 来引用。注意函数定义最后没有加分号。\n注意这里的函数末尾是有分号的，与任何变量初始化语句一样。\n还有一种定义函数的方式与函数表达式很像，叫作“箭头函数”（arrow function），如下所示：\nlet sum = (num1, num2) =\u0026gt; { return num1 + num2; }; 最后一种定义函数的方式是使用 Function 构造函数。这个构造函数接收任意多个字符串参数，最后一个参数始终会被当成函数体，而之前的参数都是新函数的参数。来看下面的例子：\nlet sum = new Function(\u0026#34;num1\u0026#34;, \u0026#34;num2\u0026#34;, \u0026#34;return num1 + num2\u0026#34;); // 不推荐 我们不推荐使用这种语法来定义函数，因为这段代码会被解释两次：第一次是将它当作常规 ECMAScript 代码，第二次是解释传给构造函数的字符串。这显然会影响性能。不过，把函数想象为对象，把函数名想象为指针是很重要的。而上面这种语法很好地诠释了这些概念。\n注意 这几种实例化函数对象的方式之间存在微妙但重要的差别，本篇后面会讨论。无论如何，通过其中任何一种方式都可以创建函数。  "},{"id":27,"href":"/docs/javascript/10/10.1/","title":"箭头函数","section":"函数","content":"箭头函数 #  ECMAScript 6 新增了使用胖箭头（=\u0026gt;）语法定义函数表达式的能力。很大程度上，箭头函数实例化的函数对象与正式的函数表达式创建的函数对象行为是相同的。任何可以使用函数表达式的地方，都可以使用箭头函数：\nlet arrowSum = (a, b) =\u0026gt; { return a + b; }; let functionExpressionSum = function (a, b) { return a + b; }; console.log(arrowSum(5, 8)); // 13 console.log(functionExpressionSum(5, 8)); // 13 箭头函数简洁的语法非常适合嵌入函数的场景：\nlet ints = [1, 2, 3]; console.log( ints.map(function (i) { return i + 1; }) ); // [2, 3, 4] console.log( ints.map((i) =\u0026gt; { return i + 1; }) ); // [2, 3, 4] 如果只有一个参数，那也可以不用括号。只有没有参数，或者多个参数的情况下，才需要使用括号：\n// 以下两种写法都有效 let double = (x) =\u0026gt; { return 2 * x; }; let triple = x =\u0026gt; { return 3 * x; }; // 没有参数需要括号 let getRandom = () =\u0026gt; { return Math.random(); }; // 多个参数需要括号 let sum = (a, b) =\u0026gt; { return a + b; }; // 无效的写法： let multiply = a, b =\u0026gt; { return a * b; }; 箭头函数也可以不用大括号，但这样会改变函数的行为。使用大括号就说明包含“函数体”，可以在一个函数中包含多条语句，跟常规的函数一样。如果不使用大括号，那么箭头后面就只能有一行代码，比如一个赋值操作，或者一个表达式。而且，省略大括号会隐式返回这行代码的值：\n// 以下两种写法都有效，而且返回相应的值 let double = (x) =\u0026gt; { return 2 * x; }; let triple = (x) =\u0026gt; 3 * x; // 可以赋值 let value = {}; let setName = (x) =\u0026gt; x.name = \u0026#34;Matt\u0026#34;; setName(value); console.log(value.name); // \u0026#34;Matt\u0026#34;  // 无效的写法： let multiply = (a, b) =\u0026gt; return a * b; 箭头函数虽然语法简洁，但也有很多场合不适用。箭头函数不能使用 arguments、super 和 new.target，也不能用作构造函数。此外，箭头函数也没有 prototype 属性。\n"},{"id":28,"href":"/docs/javascript/11/11.1/","title":"异步编程","section":"期约与异步函数","content":"异步编程 #  同步行为和异步行为的对立统一是计算机科学的一个基本概念。特别是在 JavaScript 这种单线程事件循环模型中，同步操作与异步操作更是代码所要依赖的核心机制。异步行为是为了优化因计算量大而时间长的操作。如果在等待其他操作完成的同时，即使运行其他指令，系统也能保持稳定，那么这样做就是务实的。\n重要的是，异步操作并不一定计算量大或要等很长时间。只要你不想为等待某个异步操作而阻塞线程执行，那么任何时候都可以使用。\n同步与异步 #  同步行为对应内存中顺序执行的处理器指令。每条指令都会严格按照它们出现的顺序来执行，而每条指令执行后也能立即获得存储在系统本地（如寄存器或系统内存）的信息。这样的执行流程容易分析程序在执行到代码任意位置时的状态（比如变量的值）。\n同步操作的例子可以是执行一次简单的数学计算：\nlet x = 3; x = x + 4; 在程序执行的每一步，都可以推断出程序的状态。这是因为后面的指令总是在前面的指令完成后才会执行。等到最后一条指定执行完毕，存储在 x 的值就立即可以使用。\n这两行 JavaScript 代码对应的低级指令（从 JavaScript 到 x86）并不难想象。首先，操作系统会在栈内存上分配一个存储浮点数值的空间，然后针对这个值做一次数学计算，再把计算结果写回之前分配的内存中。所有这些指令都是在单个线程中按顺序执行的。在低级指令的层面，有充足的工具可以确定系统状态。\n相对地，异步行为类似于系统中断，即当前进程外部的实体可以触发代码执行。异步操作经常是必要的，因为强制进程等待一个长时间的操作通常是不可行的（同步操作则必须要等）。如果代码要访问一些高延迟的资源，比如向远程服务器发送请求并等待响应，那么就会出现长时间的等待。\n异步操作的例子可以是在定时回调中执行一次简单的数学计算：\nlet x = 3; setTimeout(() =\u0026gt; (x = x + 4), 1000); 这段程序最终与同步代码执行的任务一样，都是把两个数加在一起，但这一次执行线程不知道 x 值何时会改变，因为这取决于回调何时从消息队列出列并执行。\n异步代码不容易推断。虽然这个例子对应的低级代码最终跟前面的例子没什么区别，但第二个指令块（加操作及赋值操作）是由系统计时器触发的，这会生成一个入队执行的中断。到底什么时候会触发这个中断，这对 JavaScript 运行时来说是一个黑盒，因此实际上无法预知（尽管可以保证这发生在当前线程的同步代码执行之后，否则回调都没有机会出列被执行）。无论如何，在排定回调以后基本没办法知道系统状态何时变化。\n为了让后续代码能够使用 x，异步执行的函数需要在更新 x 的值以后通知其他代码。如果程序不需要这个值，那么就只管继续执行，不必等待这个结果了。\n设计一个能够知道 x 什么时候可以读取的系统是非常难的。JavaScript 在实现这样一个系统的过程中也经历了几次迭代。\n以往的异步编程模式 #  异步行为是 JavaScript 的基础，但以前的实现不理想。在早期的 JavaScript 中，只支持定义回调函数来表明异步操作完成。串联多个异步操作是一个常见的问题，通常需要深度嵌套的回调函数（俗称“回调地狱”）来解决。\n假设有以下异步函数，使用了 setTimeout 在一秒钟之后执行某些操作：\nfunction double(value) { setTimeout(() =\u0026gt; setTimeout(console.log, 0, value * 2), 1000); } double(3); // 6（大约1000毫秒之后） 这里的代码没什么神秘的，但关键是理解为什么说它是一个异步函数。setTimeout 可以定义一个在指定时间之后会被调度执行的回调函数。对这个例子而言，1000 毫秒之后，JavaScript 运行时会把回调函数推到自己的消息队列上去等待执行。推到队列之后，回调什么时候出列被执行对 JavaScript 代码就完全不可见了。还有一点，double()函数在 setTimeout 成功调度异步操作之后会立即退出。\n异步返回值 #  假设 setTimeout 操作会返回一个有用的值。有什么好办法把这个值传给需要它的地方？广泛接受的一个策略是给异步操作提供一个回调，这个回调中包含要使用异步返回值的代码（作为回调的参数）。\nfunction double(value, callback) { setTimeout(() =\u0026gt; callback(value * 2), 1000); } double(3, (x) =\u0026gt; console.log(`I was given: ${x}`)); // I was given: 6（大约1000毫秒之后） 这里的 setTimeout 调用告诉 JavaScript 运行时在 1000 毫秒之后把一个函数推到消息队列上。这个函数会由运行时负责异步调度执行。而位于函数闭包中的回调及其参数在异步执行时仍然是可用的。\n失败处理 #  异步操作的失败处理在回调模型中也要考虑，因此自然就出现了成功回调和失败回调：\nfunction double(value, success, failure) { setTimeout(() =\u0026gt; { try { if (typeof value !== \u0026#34;number\u0026#34;) { throw \u0026#34;Must provide number as first argument\u0026#34;; } success(2 * value); } catch (e) { failure(e); } }, 1000); } const successCallback = (x) =\u0026gt; console.log(`Success: ${x}`); const failureCallback = (e) =\u0026gt; console.log(`Failure: ${e}`); double(3, successCallback, failureCallback); double(\u0026#34;b\u0026#34;, successCallback, failureCallback); // Success: 6（大约1000毫秒之后） // Failure: Must provide number as first argument（大约1000毫秒之后） 这种模式已经不可取了，因为必须在初始化异步操作时定义回调。异步函数的返回值只在短时间内存在，只有预备好将这个短时间内存在的值作为参数的回调才能接收到它。\n嵌套异步回调 #  如果异步返值又依赖另一个异步返回值，那么回调的情况还会进一步变复杂。在实际的代码中，这就要求嵌套回调：\nfunction double(value, success, failure) { setTimeout(() =\u0026gt; { try { if (typeof value !== \u0026#34;number\u0026#34;) { throw \u0026#34;Must provide number as first argument\u0026#34;; } success(2 * value); } catch (e) { failure(e); } }, 1000); } const successCallback = (x) =\u0026gt; { double(x, (y) =\u0026gt; console.log(`Success: ${y}`)); }; const failureCallback = (e) =\u0026gt; console.log(`Failure: ${e}`); double(3, successCallback, failureCallback); // Success: 12（大约1000毫秒之后） 显然，随着代码越来越复杂，回调策略是不具有扩展性的。“回调地狱”这个称呼可谓名至实归。嵌套回调的代码维护起来就是噩梦。\n"},{"id":29,"href":"/docs/javascript/11/","title":"期约与异步函数","section":"Javascript","content":"期约与异步函数 #  ECMAScript 6 及之后的几个版本逐步加大了对异步编程机制的支持，提供了令人眼前一亮的新特性。ECMAScript 6 新增了正式的 Promise（期约）引用类型，支持优雅地定义和组织异步逻辑。接下来几个版本增加了使用 async 和 await 关键字定义异步函数的机制。\n注意 本篇示例将大量使用异步日志输出的方式 setTimeout(console.log, 0, .. params)，旨在演示执行顺序及其他异步行为。异步输出的内容看起来虽然像是同步输出的，但实际上是异步打印的。这样可以让期约等返回的值达到其最终状态。\n此外，浏览器控制台的输出经常能打印出 JavaScript 运行中无法获取的对象信息（比如期约的状态）。这个特性在示例中广泛使用，以便辅助读者理解相关概念。\n "},{"id":30,"href":"/docs/javascript/12/","title":"BOM","section":"Javascript","content":"BOM #  虽然 ECMAScript 把浏览器对象模型（BOM，Browser Object Model）描述为 JavaScript 的核心，但实际上 BOM 是使用 JavaScript 开发 Web 应用程序的核心。BOM 提供了与网页无关的浏览器功能对象。多年来，BOM 是在缺乏规范的背景下发展起来的，因此既充满乐趣又问题多多。毕竟，浏览器开发商都按照自己的意愿来为它添砖加瓦。最终，浏览器实现之间共通的部分成为了事实标准，为 Web 开发提供了浏览器间互操作的基础。HTML5 规范中有一部分涵盖了 BOM 的主要内容，因为 W3C 希望将 JavaScript 在浏览器中最基础的部分标准化。\n"},{"id":31,"href":"/docs/javascript/12/12.1/","title":"window 对象","section":"BOM","content":"window 对象 #  BOM 的核心是 window 对象，表示浏览器的实例。window 对象在浏览器中有两重身份，一个是 ECMAScript 中的 Global 对象，另一个就是浏览器窗口的 JavaScript 接口。这意味着网页中定义的所有对象、变量和函数都以 window 作为其 Global 对象，都可以访问其上定义的 parseInt()等全局方法。\n注意 因为 window 对象的属性在全局作用域中有效，所以很多浏览器 API 及相关构造函数都以 window 对象属性的形式暴露出来。这些 API 将在全书各章中介绍，特别是第 20 章。\n另外，由于实现不同，某些 window 对象的属性在不同浏览器间可能差异很大。本篇不会介绍已经废弃的、非标准化或特定于浏览器的 window 属性。\n Global 作用域 #  因为 window 对象被复用为 ECMAScript 的 Global 对象，所以通过 var 声明的所有全局变量和函数都会变成 window 对象的属性和方法。比如：\nvar age = 29; var sayAge = () =\u0026gt; alert(this.age); alert(window.age); // 29 sayAge(); // 29 window.sayAge(); // 29 这里，变量 age 和函数 sayAge()被定义在全局作用域中，它们自动成为了 window 对象的成员。因此，变量 age 可以通过 window.age 来访问，而函数 sayAge()也可以通过 window.sayAge()来访问。因为 sayAge()存在于全局作用域，this.age 映射到 window.age，所以就可以显示正确的结果了。\n如果在这里使用 let 或 const 替代 var，则不会把变量添加给全局对象：\nlet age = 29; const sayAge = () =\u0026gt; alert(this.age); alert(window.age); // undefined sayAge(); // undefined window.sayAge(); // TypeError: window.sayAge is not a function 另外，访问未声明的变量会抛出错误，但是可以在 window 对象上查询是否存在可能未声明的变量。比如：\n// 这会导致抛出错误，因为oldValue没有声明 var newValue = oldValue; // 这不会抛出错误，因为这里是属性查询 // newValue会被设置为undefined var newValue = window.oldValue; 记住，JavaScript 中有很多对象都暴露在全局作用域中，比如 location 和 navigator（本篇后面都会讨论），因而它们也是 window 对象的属性。\n窗口关系 #  top 对象始终指向最上层（最外层）窗口，即浏览器窗口本身。而 parent 对象则始终指向当前窗口的父窗口。如果当前窗口是最上层窗口，则 parent 等于 top（都等于 window）。最上层的 window 如果不是通过 window.open()打开的，那么其 name 属性就不会包含值，本篇后面会讨论。\n还有一个 self 对象，它是终极 window 属性，始终会指向 window。实际上，self 和 window 就是同一个对象。之所以还要暴露 self，就是为了和 top、parent 保持一致。\n这些属性都是 window 对象的属性，因此访问 window.parent、window.top 和 window.self 都可以。这意味着可以把访问多个窗口的 window 对象串联起来，比如 window.parent.parent。\n窗口位置与像素比 #  window 对象的位置可以通过不同的属性和方法来确定。现代浏览器提供了 screenLeft 和 screenTop 属性，用于表示窗口相对于屏幕左侧和顶部的位置 ，返回值的单位是 CSS 像素。\n可以使用 moveTo()和 moveBy()方法移动窗口。这两个方法都接收两个参数，其中 moveTo()接收要移动到的新位置的绝对坐标 x 和 y；而 moveBy()则接收相对当前位置在两个方向上移动的像素数。比如：\n// 把窗口移动到左上角 window.moveTo(0, 0); // 把窗口向下移动100像素 window.moveBy(0, 100); // 把窗口移动到坐标位置(200, 300) window.moveTo(200, 300); // 把窗口向左移动50像素 window.moveBy(-50, 0); 依浏览器而定，以上方法可能会被部分或全部禁用。\n像素比\nCSS 像素是 Web 开发中使用的统一像素单位。这个单位的背后其实是一个角度：0.0213°。如果屏幕距离人眼是一臂长，则以这个角度计算的 CSS 像素大小约为 1/96 英寸。这样定义像素大小是为了在不同设备上统一标准。比如，低分辨率平板设备上 12 像素（CSS 像素）的文字应该与高清 4K 屏幕下 12 像素（CSS 像素）的文字具有相同大小。这就带来了一个问题，不同像素密度的屏幕下就会有不同的缩放系数，以便把物理像素（屏幕实际的分辨率）转换为 CSS 像素（浏览器报告的虚拟分辨率）。\n举个例子，手机屏幕的物理分辨率可能是 1920×1080，但因为其像素可能非常小，所以浏览器就需要将其分辨率降为较低的逻辑分辨率，比如 640×320。这个物理像素与 CSS 像素之间的转换比率由 window.devicePixelRatio 属性提供。对于分辨率从 1920×1080 转换为 640×320 的设备，window.devicePixelRatio 的值就是 3。这样一来，12 像素（CSS 像素）的文字实际上就会用 36 像素的物理像素来显示。\nwindow.devicePixelRatio 实际上与每英寸像素数（DPI，dots per inch）是对应的。DPI 表示单位像素密度，而 window.devicePixelRatio 表示物理像素与逻辑像素之间的缩放系数。\n窗口大小 #  在不同浏览器中确定浏览器窗口大小没有想象中那么容易。所有现代浏览器都支持 4 个属性：innerWidth、innerHeight、outerWidth 和 outerHeight。outerWidth 和 outerHeight 返回浏览器窗口自身的大小（不管是在最外层 window 上使用，还是在窗格中使用）。innerWidth 和 innerHeight 返回浏览器窗口中页面视口的大小（不包含浏览器边框和工具栏）。\ndocument.documentElement.clientWidth 和 document.documentElement.clientHeight 返回页面视口的宽度和高度。\n浏览器窗口自身的精确尺寸不好确定，但可以确定页面视口的大小，如下所示：\nlet pageWidth = window.innerWidth, pageHeight = window.innerHeight; if (typeof pageWidth != \u0026#34;number\u0026#34;) { if (document.compatMode == \u0026#34;CSS1Compat\u0026#34;) { pageWidth = document.documentElement.clientWidth; pageHeight = document.documentElement.clientHeight; } else { pageWidth = document.body.clientWidth; pageHeight = document.body.clientHeight; } } 这里，先将 pageWidth 和 pageHeight 的值分别设置为 window.innerWidth 和 window.innerHeight。然后，检查 pageWidth 是不是一个数值，如果不是则通过 document.compatMode 来检查页面是否处于标准模式。如果是，则使用 document.documentElement.clientWidth 和 document.documentElement.clientHeight；否则，就使用 document.body.clientWidth 和 document.body.clientHeight。\n在移动设备上，window.innerWidth 和 window.innerHeight 返回视口的大小，也就是屏幕上页面可视区域的大小。Mobile Internet Explorer 支持这些属性，但在 document.documentElement.clientWidth 和 document.documentElement.clientHeight 中提供了相同的信息。在放大或缩小页面时，这些值也会相应变化。\n在其他移动浏览器中，document.documentElement.clientWidth 和 document.documentElement.clientHeight 返回的布局视口的大小，即渲染页面的实际大小。布局视口是相对于可见视口的概念，可见视口只能显示整个页面的一小部分。Mobile Internet Explorer 把布局视口的信息保存在 document.body.clientWidth 和 document.body.clientHeight 中。在放大或缩小页面时，这些值也会相应变化。\n因为桌面浏览器的差异，所以需要先确定用户是不是在使用移动设备，然后再决定使用哪个属性。\n注意　手机视口的概念比较复杂，有各种各样的问题。如果读者在做移动开发，推荐阅读 Peter-Paul Koch 发表在 QuirksMode 网站上的文章“A Tale of Two Viewports— Part Two”。  可以使用 resizeTo()和 resizeBy()方法调整窗口大小。这两个方法都接收两个参数，resizeTo()接收新的宽度和高度值，而 resizeBy()接收宽度和高度各要缩放多少。下面看个例子：\n// 缩放到100×100 window.resizeTo(100, 100); // 缩放到200×150 window.resizeBy(100, 50); // 缩放到300×300 window.resizeTo(300, 300); 与移动窗口的方法一样，缩放窗口的方法可能会被浏览器禁用，而且在某些浏览器中默认是禁用的。同样，缩放窗口的方法只能应用到最上层的 window 对象。\n视口位置 #  浏览器窗口尺寸通常无法满足完整显示整个页面，为此用户可以通过滚动在有限的视口中查看文档。度量文档相对于视口滚动距离的属性有两对，返回相等的值：window.pageXoffset/window.scrollX 和 window.pageYoffset/window.scrollY。\n可以使用 scroll()、scrollTo()和 scrollBy()方法滚动页面。这 3 个方法都接收表示相对视口距离的 x 和 y 坐标，这两个参数在前两个方法中表示要滚动到的坐标，在最后一个方法中表示滚动的距离。\n// 相对于当前视口向下滚动100像素 window.scrollBy(0, 100); // 相对于当前视口向右滚动40像素 window.scrollBy(40, 0); // 滚动到页面左上角 window.scrollTo(0, 0); // 滚动到距离屏幕左边及顶边各100像素的位置 window.scrollTo(100, 100); 这几个方法也都接收一个 ScrollToOptions 字典，除了提供偏移值，还可以通过 behavior 属性告诉浏览器是否平滑滚动。\n// 正常滚动 window.scrollTo({ left: 100, top: 100, behavior: \u0026#34;auto\u0026#34;, }); // 平滑滚动 window.scrollTo({ left: 100, top: 100, behavior: \u0026#34;smooth\u0026#34;, }); 导航与打开新窗口 #  window.open()方法可以用于导航到指定 URL，也可以用于打开新浏览器窗口。这个方法接收 4 个参数：要加载的 URL、目标窗口、特性字符串和表示新窗口在浏览器历史记录中是否替代当前加载页面的布尔值。通常，调用这个方法时只传前 3 个参数，最后一个参数只有在不打开新窗口时才会使用。\n如果 window.open()的第二个参数是一个已经存在的窗口或窗格（frame）的名字，则会在对应的窗口或窗格中打开 URL。下面是一个例子：\n// 与\u0026lt;a href=\u0026#34;http://www.wrox.com\u0026#34; target=\u0026#34;topFrame\u0026#34;/\u0026gt;相同 window.open(\u0026#34;http://www.wrox.com/\u0026#34;, \u0026#34;topFrame\u0026#34;); 执行这行代码的结果就如同用户点击了一个 href 属性为\u0026quot;http://www.wrox.com\u0026quot;，target属性为\u0026quot;topFrame\u0026quot;的链接。如果有一个窗口名叫\u0026quot;topFrame\u0026quot;，则这个窗口就会打开这个URL；否则就会打开一个新窗口并将其命名为\u0026quot;topFrame\u0026quot;。第二个参数也可以是一个特殊的窗口名，比如_self、_parent、_top或_blank。\n弹出窗口 #  如果 window.open()的第二个参数不是已有窗口，则会打开一个新窗口或标签页。第三个参数，即特性字符串，用于指定新窗口的配置。如果没有传第三个参数，则新窗口（或标签页）会带有所有默认的浏览器特性（工具栏、地址栏、状态栏等都是默认配置）。如果打开的不是新窗口，则忽略第三个参数。\n特性字符串是一个逗号分隔的设置字符串，用于指定新窗口包含的特性。下表列出了一些选项。\n   设置 值 说明     fullscreen \u0026ldquo;yes\u0026quot;或\u0026quot;no\u0026rdquo; 表示新窗口是否最大化。仅限 IE 支持   height 数值 新窗口高度。这个值不能小于 100   left 数值 新窗口的 x 轴坐标。这个值不能是负值   location \u0026ldquo;yes\u0026quot;或\u0026quot;no\u0026rdquo; 表示是否显示地址栏。不同浏览器的默认值也不一样。在设置为\u0026quot;no\u0026quot;时，地址栏可能隐藏或禁用（取决于浏览器）   Menubar \u0026ldquo;yes\u0026quot;或\u0026quot;no\u0026rdquo; 表示是否显示菜单栏。默认为\u0026quot;no\u0026quot;   resizable \u0026ldquo;yes\u0026quot;或\u0026quot;no\u0026rdquo; 表示是否可以拖动改变新窗口大小。默认为\u0026quot;no\u0026quot;   scrollbars \u0026ldquo;yes\u0026quot;或\u0026quot;no\u0026rdquo; 表示是否可以在内容过长时滚动。默认为\u0026quot;no\u0026quot;   status \u0026ldquo;yes\u0026quot;或\u0026quot;no\u0026rdquo; 表示是否显示状态栏。不同浏览器的默认值也不一样   toolbar \u0026ldquo;yes\u0026quot;或\u0026quot;no\u0026rdquo; 表示是否显示工具栏。默认为\u0026quot;no\u0026quot;   top 数值 新窗口的 y 轴坐标。这个值不能是负值   width 数值 新窗口的宽度。这个值不能小于 100    这些设置需要以逗号分隔的名值对形式出现，其中名值对以等号连接。（特性字符串中不能包含空格。）来看下面的例子：\nwindow.open( \u0026#34;http://www.wrox.com/\u0026#34;, \u0026#34;wroxWindow\u0026#34;, \u0026#34;height=400,width=400,top=10,left=10,resizable=yes\u0026#34; ); 这行代码会打开一个可缩放的新窗口，大小为 400 像素 ×400 像素，位于离屏幕左边及顶边各 10 像素的位置。\nwindow.open()方法返回一个对新建窗口的引用。这个对象与普通 window 对象没有区别，只是为控制新窗口提供了方便。例如，某些浏览器默认不允许缩放或移动主窗口，但可能允许缩放或移动通过 window.open()创建的窗口。跟使用任何 window 对象一样，可以使用这个对象操纵新打开的窗口。\nlet wroxWin = window.open( \u0026#34;http://www.wrox.com/\u0026#34;, \u0026#34;wroxWindow\u0026#34;, \u0026#34;height=400,width=400,top=10,left=10,resizable=yes\u0026#34; ); // 缩放 wroxWin.resizeTo(500, 500); // 移动 wroxWin.moveTo(100, 100); 还可以使用 close()方法像这样关闭新打开的窗口：\nwroxWin.close(); 这个方法只能用于 window.open()创建的弹出窗口。虽然不可能不经用户确认就关闭主窗口，但弹出窗口可以调用 top.close()来关闭自己。关闭窗口以后，窗口的引用虽然还在，但只能用于检查其 closed 属性了：\nwroxWin.close(); alert(wroxWin.closed); // true 新创建窗口的 window 对象有一个属性 opener，指向打开它的窗口。这个属性只在弹出窗口的最上层 window 对象（top）有定义，是指向调用 window.open()打开它的窗口或窗格的指针。例如：\nlet wroxWin = window.open( \u0026#34;http://www.wrox.com/\u0026#34;, \u0026#34;wroxWindow\u0026#34;, \u0026#34;height=400,width=400,top=10,left=10,resizable=yes\u0026#34; ); alert(wroxWin.opener === window); // true 虽然新建窗口中有指向打开它的窗口的指针，但反之则不然。窗口不会跟踪记录自己打开的新窗口，因此开发者需要自己记录。\n在某些浏览器中，每个标签页会运行在独立的进程中。如果一个标签页打开了另一个，而 window 对象需要跟另一个标签页通信，那么标签便不能运行在独立的进程中。在这些浏览器中，可以将新打开的标签页的 opener 属性设置为 null，表示新打开的标签页可以运行在独立的进程中。比如：\nlet wroxWin = window.open( \u0026#34;http://www.wrox.com/\u0026#34;, \u0026#34;wroxWindow\u0026#34;, \u0026#34;height=400,width=400,top=10,left=10,resizable=yes\u0026#34; ); wroxWin.opener = null; 把 opener 设置为 null 表示新打开的标签页不需要与打开它的标签页通信，因此可以在独立进程中运行。这个连接一旦切断，就无法恢复了。\n安全限制 #  弹出窗口有段时间被在线广告用滥了。很多在线广告会把弹出窗口伪装成系统对话框，诱导用户点击。因为长得像系统对话框，所以用户很难分清这些弹窗的来源。为了让用户能够区分清楚，浏览器开始对弹窗施加限制。\nIE 的早期版本实现针对弹窗的多重安全限制，包括不允许创建弹窗或把弹窗移出屏幕之外，以及不允许隐藏状态栏等。从 IE7 开始，地址栏也不能隐藏了，而且弹窗默认是不能移动或缩放的。Firefox 1 禁用了隐藏状态栏的功能，因此无论 window.open()的特性字符串是什么，都不会隐藏弹窗的状态栏。Firefox 3 强制弹窗始终显示地址栏。Opera 只会在主窗口中打开新窗口，但不允许它们出现在系统对话框的位置。\n此外，浏览器会在用户操作下才允许创建弹窗。在网页加载过程中调用 window.open()没有效果，而且还可能导致向用户显示错误。弹窗通常可能在鼠标点击或按下键盘中某个键的情况下才能打开。\n注意 IE 对打开本地网页的窗口再弹窗解除了某些限制。同样的代码如果来自服务器，则会施加弹窗限制。  弹窗屏蔽程序 #  所有现代浏览器都内置了屏蔽弹窗的程序，因此大多数意料之外的弹窗都会被屏蔽。在浏览器屏蔽弹窗时，可能会发生一些事。如果浏览器内置的弹窗屏蔽程序阻止了弹窗，那么 window.open()很可能会返回 null。此时，只要检查这个方法的返回值就可以知道弹窗是否被屏蔽了，比如：\nlet wroxWin = window.open(\u0026#34;http://www.wrox.com\u0026#34;, \u0026#34;_blank\u0026#34;); if (wroxWin == null) { alert(\u0026#34;The popup was blocked!\u0026#34;); } 在浏览器扩展或其他程序屏蔽弹窗时，window.open()通常会抛出错误。因此要准确检测弹窗是否被屏蔽，除了检测 window.open()的返回值，还要把它用 try/catch 包装起来，像这样：\nlet blocked = false; try { let wroxWin = window.open(\u0026#34;http://www.wrox.com\u0026#34;, \u0026#34;_blank\u0026#34;); if (wroxWin == null) { blocked = true; } } catch (ex) { blocked = true; } if (blocked) { alert(\u0026#34;The popup was blocked!\u0026#34;); } 无论弹窗是用什么方法屏蔽的，以上代码都可以准确判断调用 window.open()的弹窗是否被屏蔽了。\n注意 检查弹窗是否被屏蔽，不影响浏览器显示关于弹窗被屏蔽的消息。  定时器 #  JavaScript 在浏览器中是单线程执行的，但允许使用定时器指定在某个时间之后或每隔一段时间就执行相应的代码。setTimeout()用于指定在一定时间后执行某些代码，而 setInterval()用于指定每隔一段时间执行某些代码。\nsetTimeout()方法通常接收两个参数：要执行的代码和在执行回调函数前等待的时间（毫秒）。第一个参数可以是包含 JavaScript 代码的字符串（类似于传给 eval()的字符串）或者一个函数，比如：\n// 在1秒后显示警告框 setTimeout(() =\u0026gt; alert(\u0026#34;Hello world!\u0026#34;), 1000); 第二个参数是要等待的毫秒数，而不是要执行代码的确切时间。JavaScript 是单线程的，所以每次只能执行一段代码。为了调度不同代码的执行，JavaScript 维护了一个任务队列。其中的任务会按照添加到队列的先后顺序执行。setTimeout()的第二个参数只是告诉 JavaScript 引擎在指定的毫秒数过后把任务添加到这个队列。如果队列是空的，则会立即执行该代码。如果队列不是空的，则代码必须等待前面的任务执行完才能执行。\n调用 setTimeout()时，会返回一个表示该超时排期的数值 ID。这个超时 ID 是被排期执行代码的唯一标识符，可用于取消该任务。要取消等待中的排期任务，可以调用 clearTimeout()方法并传入超时 ID，如下面的例子所示：\n// 设置超时任务 let timeoutId = setTimeout(() =\u0026gt; alert(\u0026#34;Hello world!\u0026#34;), 1000); // 取消超时任务 clearTimeout(timeoutId); 只要是在指定时间到达之前调用 clearTimeout()，就可以取消超时任务。在任务执行后再调用 clearTimeout()没有效果。\n注意 所有超时执行的代码（函数）都会在全局作用域中的一个匿名函数中运行，因此函数中的 this 值在非严格模式下始终指向 window，而在严格模式下是 undefined。如果给 setTimeout()提供了一个箭头函数，那么 this 会保留为定义它时所在的词汇作用域。  setInterval()与 setTimeout()的使用方法类似，只不过指定的任务会每隔指定时间就执行一次，直到取消循环定时或者页面卸载。setInterval()同样可以接收两个参数：要执行的代码（字符串或函数），以及把下一次执行定时代码的任务添加到队列要等待的时间（毫秒）。下面是一个例子：\nsetInterval(() =\u0026gt; alert(\u0026#34;Hello world!\u0026#34;), 10000); 注意 这里的关键点是，第二个参数，也就是间隔时间，指的是向队列添加新任务之前等待的时间。比如，调用 setInterval()的时间为 01:00:00，间隔时间为 3000 毫秒。这意味着 01:00:03 时，浏览器会把任务添加到执行队列。浏览器不关心这个任务什么时候执行或者执行要花多长时间。因此，到了 01:00:06，它会再向队列中添加一个任务。由此可看出，执行时间短、非阻塞的回调函数比较适合 setInterval()。  setInterval()方法也会返回一个循环定时 ID，可以用于在未来某个时间点上取消循环定时。要取消循环定时，可以调用 clearInterval()并传入定时 ID。相对于 setTimeout()而言，取消定时的能力对 setInterval()更加重要。毕竟，如果一直不管它，那么定时任务会一直执行到页面卸载。下面是一个常见的例子：\nlet num = 0, intervalId = null; let max = 10; let incrementNumber = function () { num++; // 如果达到最大值，则取消所有未执行的任务  if (num == max) { clearInterval(intervalId); alert(\u0026#34;Done\u0026#34;); } }; intervalId = setInterval(incrementNumber, 500); 在这个例子中，变量 num 会每半秒递增一次，直至达到最大限制值。此时循环定时会被取消。这个模式也可以使用 setTimeout()来实现，比如：\nlet num = 0; let max = 10; let incrementNumber = function () { num++; // 如果还没有达到最大值，再设置一个超时任务  if (num \u0026lt; max) { setTimeout(incrementNumber, 500); } else { alert(\u0026#34;Done\u0026#34;); } }; setTimeout(incrementNumber, 500); 注意在使用 setTimeout()时，不一定要记录超时 ID，因为它会在条件满足时自动停止，否则会自动设置另一个超时任务。这个模式是设置循环任务的推荐做法。setInterval()在实践中很少会在生产环境下使用，因为一个任务结束和下一个任务开始之间的时间间隔是无法保证的，有些循环定时任务可能会因此而被跳过。而像前面这个例子中一样使用 setTimeout()则能确保不会出现这种情况。一般来说，最好不要使用 setInterval()。\n系统对话框 #  使用 alert()、confirm()和 prompt()方法，可以让浏览器调用系统对话框向用户显示消息。这些对话框与浏览器中显示的网页无关，而且也不包含 HTML。它们的外观由操作系统或者浏览器决定，无法使用 CSS 设置。此外，这些对话框都是同步的模态对话框，即在它们显示的时候，代码会停止执行，在它们消失以后，代码才会恢复执行。\nalert()方法在本系列示例中经常用到。它接收一个要显示给用户的字符串。与 console.log 可以接收任意数量的参数且能一次性打印这些参数不同，alert()只接收一个参数。调用 alert()时，传入的字符串会显示在一个系统对话框中。对话框只有一个“OK”（确定）按钮。如果传给 alert()的参数不是一个原始字符串，则会调用这个值的 toString()方法将其转换为字符串。\n警告框（alert）通常用于向用户显示一些他们无法控制的消息，比如报错。用户唯一的选择就是在看到警告框之后把它关闭。图 12-1 展示了一个警告框。\n第二种对话框叫确认框，通过调用 confirm()来显示。确认框跟警告框类似，都会向用户显示消息。但不同之处在于，确认框有两个按钮：“Cancel”（取消）和“OK”（确定）。用户通过单击不同的按钮表明希望接下来执行什么操作。比如，confirm(\u0026ldquo;Are you sure?\u0026quot;)会显示图 12-2 所示的确认框。\n要知道用户单击了 OK 按钮还是 Cancel 按钮，可以判断 confirm()方法的返回值：true 表示单击了 OK 按钮，false 表示单击了 Cancel 按钮或者通过单击某一角上的 X 图标关闭了确认框。确认框的典型用法如下所示：\nif (confirm(\u0026#34;Are you sure?\u0026#34;)) { alert(\u0026#34;I\u0026#39;m so glad you\u0026#39;re sure!\u0026#34;); } else { alert(\u0026#34;I\u0026#39;m sorry to hear you\u0026#39;re not sure.\u0026#34;); } 在这个例子中，第一行代码向用户显示了确认框，也就是 if 语句的条件。如果用户单击了 OK 按钮，则会弹出警告框显示\u0026quot;I\u0026rsquo;m so glad you\u0026rsquo;re sure!\u0026quot;。如果单击了 Cancel，则会显示\u0026quot;I\u0026rsquo;m sorry to hear you\u0026rsquo;re not sure.\u0026quot;。确认框通常用于让用户确认执行某个操作，比如删除邮件等。因为这种对话框会完全打断正在浏览网页的用户，所以应该在必要时再使用。\n最后一种对话框是提示框，通过调用 prompt()方法来显示。提示框的用途是提示用户输入消息。除了 OK 和 Cancel 按钮，提示框还会显示一个文本框，让用户输入内容。prompt()方法接收两个参数：要显示给用户的文本，以及文本框的默认值（可以是空字符串）。调用 prompt(\u0026ldquo;What is your name?\u0026rdquo;, \u0026ldquo;Jake\u0026rdquo;)会显示图 12-3 所示的提示框。\n如果用户单击了 OK 按钮，则 prompt()会返回文本框中的值。如果用户单击了 Cancel 按钮，或者对话框被关闭，则 prompt()会返回 null。下面是一个例子：\nlet result = prompt(\u0026#34;What is your name? \u0026#34;, \u0026#34;\u0026#34;); if (result !== null) { alert(\u0026#34;Welcome, \u0026#34; + result); } 这些系统对话框可以向用户显示消息、确认操作和获取输入。由于不需要 HTML 和 CSS，所以系统对话框是 Web 应用程序最简单快捷的沟通手段。\n很多浏览器针对这些系统对话框添加了特殊功能。如果网页中的脚本生成了两个或更多系统对话框，则除第一个之外所有后续的对话框上都会显示一个复选框，如果用户选中则会禁用后续的弹框，直到页面刷新。\n如果用户选中了复选框并关闭了对话框，在页面刷新之前，所有系统对话框（警告框、确认框、提示框）都会被屏蔽。开发者无法获悉这些对话框是否显示了。对话框计数器会在浏览器空闲时重置，因此如果两次独立的用户操作分别产生了两个警告框，则两个警告框上都不会显示屏蔽复选框。如果一次独立的用户操作连续产生了两个警告框，则第二个警告框会显示复选框。\nJavaScript 还可以显示另外两种对话框：find()和 print()。这两种对话框都是异步显示的，即控制权会立即返回给脚本。用户在浏览器菜单上选择“查找”（find）和“打印”（print）时显示的就是这两种对话框。通过在 window 对象上调用 find()和 print()可以显示它们，比如：\n// 显示打印对话框 window.print(); // 显示查找对话框 window.find(); 这两个方法不会返回任何有关用户在对话框中执行了什么操作的信息，因此很难加以利用。此外，因为这两种对话框是异步的，所以浏览器的对话框计数器不会涉及它们，而且用户选择禁用对话框对它们也没有影响。\n"}]