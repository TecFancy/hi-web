<!doctype html><html lang=zh dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="JavaScript 实现 #  虽然 JavaScript 和 ECMAScript 基本上是同义词，但 JavaScript 远远不限于 ECMA-262 所定义的那样。没错，完整的 JavaScript 实现包含以下几个部分（见图 1-1）：
 核心（ECMAScript） 文档对象模型（DOM） 浏览器对象模型（BOM）  ECMAScript #  ECMAScript，即 ECMA-262 定义的语言，并不局限于 Web 浏览器。事实上，这门语言没有输入和输出之类的方法。ECMA-262 将这门语言作为一个基准来定义，以便在它之上再构建更稳健的脚本语言。Web 浏览器只是 ECMAScript 实现可能存在的一种宿主环境（host environment）。宿主环境提供 ECMAScript 的基准实现和与环境自身交互必需的扩展。扩展（比如 DOM）使用 ECMAScript 核心类型和语法，提供特定于环境的额外功能。其他宿主环境还有服务器端 JavaScript 平台 Node.js 和即将被淘汰的 Adobe Flash。
如果不涉及浏览器的话，ECMA-262 到底定义了什么？在基本的层面，它描述这门语言的如下部分：
 语法 类型 语句 关键字 保留字 操作符 全局对象  ECMAScript 只是对实现这个规范描述的所有方面的一门语言的称呼。JavaScript 实现了 ECMAScript，而 Adobe ActionScript 同样也实现了 ECMAScript。
ECMAScript 版本 #  ECMAScript 不同的版本以“edition”表示（也就是描述特定实现的 ECMA-262 的版本）。ECMA-262 最近的版本是第 10 版，发布于 2019 年 6 月。ECMA-262 的第 1 版本质上跟网景的 JavaScript 1."><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="JavaScript 实现"><meta property="og:description" content="JavaScript 实现 #  虽然 JavaScript 和 ECMAScript 基本上是同义词，但 JavaScript 远远不限于 ECMA-262 所定义的那样。没错，完整的 JavaScript 实现包含以下几个部分（见图 1-1）：
 核心（ECMAScript） 文档对象模型（DOM） 浏览器对象模型（BOM）  ECMAScript #  ECMAScript，即 ECMA-262 定义的语言，并不局限于 Web 浏览器。事实上，这门语言没有输入和输出之类的方法。ECMA-262 将这门语言作为一个基准来定义，以便在它之上再构建更稳健的脚本语言。Web 浏览器只是 ECMAScript 实现可能存在的一种宿主环境（host environment）。宿主环境提供 ECMAScript 的基准实现和与环境自身交互必需的扩展。扩展（比如 DOM）使用 ECMAScript 核心类型和语法，提供特定于环境的额外功能。其他宿主环境还有服务器端 JavaScript 平台 Node.js 和即将被淘汰的 Adobe Flash。
如果不涉及浏览器的话，ECMA-262 到底定义了什么？在基本的层面，它描述这门语言的如下部分：
 语法 类型 语句 关键字 保留字 操作符 全局对象  ECMAScript 只是对实现这个规范描述的所有方面的一门语言的称呼。JavaScript 实现了 ECMAScript，而 Adobe ActionScript 同样也实现了 ECMAScript。
ECMAScript 版本 #  ECMAScript 不同的版本以“edition”表示（也就是描述特定实现的 ECMA-262 的版本）。ECMA-262 最近的版本是第 10 版，发布于 2019 年 6 月。ECMA-262 的第 1 版本质上跟网景的 JavaScript 1."><meta property="og:type" content="article"><meta property="og:url" content="https://hi-web.io/docs/javascript/1/1.2/"><meta property="article:section" content="docs"><title>JavaScript 实现 | Hi Web</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.3e90539cf7130f0a89ba2f8b9f54ac5e5ecdd1fa345b6c8e3e5a83ec6f19ec8e.css integrity="sha256-PpBTnPcTDwqJui+Ln1SsXl7N0fo0W2yOPlqD7G8Z7I4=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script><script defer src=/zh.search.min.a53f7096b2565476c1928b72df9484e169e2a670b1e3747ea341515c4930413f.js integrity="sha256-pT9wlrJWVHbBkoty35SE4WnipnCx43R+o0FRXEkwQT8=" crossorigin=anonymous></script><script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a href=/><span>Hi Web</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li class=book-section-flat><a href=https://hi-web.io/docs/javascript/>Javascript</a><ul><li><input type=checkbox id=section-a98eae978127bafe5d9b0cc6fcfe8d1b class=toggle checked>
<label for=section-a98eae978127bafe5d9b0cc6fcfe8d1b class="flex justify-between"><a href=https://hi-web.io/docs/javascript/1/>什么是 JavaScript</a></label><ul><li><a href=https://hi-web.io/docs/javascript/1/1.1/>简短的历史回顾</a></li><li><a href=https://hi-web.io/docs/javascript/1/1.2/ class=active>JavaScript 实现</a></li><li><a href=https://hi-web.io/docs/javascript/1/1.3/>JavaScript 版本</a></li><li><a href=https://hi-web.io/docs/javascript/1/1.4/>小结</a></li></ul></li><li><input type=checkbox id=section-13c960072f37f61a8695a75afa03bfa5 class=toggle>
<label for=section-13c960072f37f61a8695a75afa03bfa5 class="flex justify-between"><a href=https://hi-web.io/docs/javascript/2/>HTML 中的 JavaScript</a></label><ul><li><a href=https://hi-web.io/docs/javascript/2/2.1/>&lt;script> 元素</a></li><li><a href=https://hi-web.io/docs/javascript/2/2.2/>行内代码与外部文件</a></li><li><a href=https://hi-web.io/docs/javascript/2/2.3/>文档模式</a></li><li><a href=https://hi-web.io/docs/javascript/2/2.4/>&lt;noscript> 元素</a></li><li><a href=https://hi-web.io/docs/javascript/2/2.5/>小结</a></li></ul></li><li><input type=checkbox id=section-6aa73d0047b6c4a47e48010e1ab6843e class=toggle>
<label for=section-6aa73d0047b6c4a47e48010e1ab6843e class="flex justify-between"><a href=https://hi-web.io/docs/javascript/3/>语言基础</a></label><ul><li><a href=https://hi-web.io/docs/javascript/3/3.1/>语法</a></li></ul></li><li><input type=checkbox id=section-0517b866fbc9f4a1231cd89e84602147 class=toggle>
<label for=section-0517b866fbc9f4a1231cd89e84602147 class="flex justify-between"><a href=https://hi-web.io/docs/javascript/4/>变量、作用域与内存</a></label><ul><li><a href=https://hi-web.io/docs/javascript/4/4.1/>原始值与引用值</a></li></ul></li><li><input type=checkbox id=section-f0099a2820f72b7cbd5e830b9a6f653e class=toggle>
<label for=section-f0099a2820f72b7cbd5e830b9a6f653e class="flex justify-between"><a href=https://hi-web.io/docs/javascript/5/>基本引用类型</a></label><ul><li><a href=https://hi-web.io/docs/javascript/5/5.1/>Date</a></li></ul></li><li><input type=checkbox id=section-e50f1bea1c6f86dc765d50c5836823cb class=toggle>
<label for=section-e50f1bea1c6f86dc765d50c5836823cb class="flex justify-between"><a href=https://hi-web.io/docs/javascript/6/>集合引用类型</a></label><ul><li><a href=https://hi-web.io/docs/javascript/6/6.1/>Object</a></li></ul></li><li><input type=checkbox id=section-7e9f9df9783a9fed06a027def220f1c5 class=toggle>
<label for=section-7e9f9df9783a9fed06a027def220f1c5 class="flex justify-between"><a href=https://hi-web.io/docs/javascript/7/>迭代器与生成器</a></label><ul><li><a href=https://hi-web.io/docs/javascript/7/7.1/>理解迭代</a></li></ul></li><li><input type=checkbox id=section-ce2e75ee3c4bd5b8fcad41ee49cf5a84 class=toggle>
<label for=section-ce2e75ee3c4bd5b8fcad41ee49cf5a84 class="flex justify-between"><a href=https://hi-web.io/docs/javascript/8/>对象、类与面向对象编程</a></label><ul><li><a href=https://hi-web.io/docs/javascript/8/8.1/>理解对象</a></li></ul></li><li><input type=checkbox id=section-0c16022b762653ac1125e9cf6c7eab01 class=toggle>
<label for=section-0c16022b762653ac1125e9cf6c7eab01 class="flex justify-between"><a href=https://hi-web.io/docs/javascript/9/>代理与反射</a></label><ul><li><a href=https://hi-web.io/docs/javascript/9/9.1/>代理基础</a></li></ul></li><li><input type=checkbox id=section-d15886a42b556e7006a9b0ee252baf12 class=toggle>
<label for=section-d15886a42b556e7006a9b0ee252baf12 class="flex justify-between"><a href=https://hi-web.io/docs/javascript/10/>函数</a></label><ul><li><a href=https://hi-web.io/docs/javascript/10/10.1/>箭头函数</a></li></ul></li><li><input type=checkbox id=section-fa5c8de9ea31d3b55b3ecfdc90271591 class=toggle>
<label for=section-fa5c8de9ea31d3b55b3ecfdc90271591 class="flex justify-between"><a href=https://hi-web.io/docs/javascript/11/>期约与异步函数</a></label><ul><li><a href=https://hi-web.io/docs/javascript/11/11.1/>异步编程</a></li></ul></li><li><input type=checkbox id=section-d963f2603cce19cfc287fc10ec5a749b class=toggle>
<label for=section-d963f2603cce19cfc287fc10ec5a749b class="flex justify-between"><a href=https://hi-web.io/docs/javascript/12/>BOM</a></label><ul><li><a href=https://hi-web.io/docs/javascript/12/12.1/>window 对象</a></li></ul></li></ul></li></ul></nav><script>(function(){var a=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(b){localStorage.setItem("menu.scrollTop",a.scrollTop)}),a.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>JavaScript 实现</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#ecmascript>ECMAScript</a><ul><li><a href=#ecmascript-版本>ECMAScript 版本</a></li><li><a href=#ecmascript-符合性是什么意思>ECMAScript 符合性是什么意思</a></li><li><a href=#浏览器对-ecmascript-的支持>浏览器对 ECMAScript 的支持</a></li></ul></li><li><a href=#dom>DOM</a><ul><li><a href=#为什么-dom-是必需的>为什么 DOM 是必需的</a></li><li><a href=#dom-级别>DOM 级别</a></li><li><a href=#其他-dom>其他 DOM</a></li><li><a href=#web-浏览器对-dom-的支持情况>Web 浏览器对 DOM 的支持情况</a></li></ul></li><li><a href=#bom>BOM</a></li></ul></nav></aside></header><article class=markdown><h1 id=javascript-实现>JavaScript 实现
<a class=anchor href=#javascript-%e5%ae%9e%e7%8e%b0>#</a></h1><p>虽然 JavaScript 和 ECMAScript 基本上是同义词，但 JavaScript 远远不限于 ECMA-262 所定义的那样。没错，完整的 JavaScript 实现包含以下几个部分（见图 1-1）：</p><ul><li>核心（ECMAScript）</li><li>文档对象模型（DOM）</li><li>浏览器对象模型（BOM）</li></ul><p><img src=/images/javascript/1-1.png alt="图 1.1"></p><h2 id=ecmascript>ECMAScript
<a class=anchor href=#ecmascript>#</a></h2><p><strong>ECMAScript</strong>，即 ECMA-262 定义的语言，并不局限于 Web 浏览器。事实上，这门语言没有输入和输出之类的方法。ECMA-262 将这门语言作为一个基准来定义，以便在它之上再构建更稳健的脚本语言。Web 浏览器只是 ECMAScript 实现可能存在的一种<strong>宿主环境</strong>（host environment）。宿主环境提供 ECMAScript 的基准实现和与环境自身交互必需的扩展。扩展（比如 DOM）使用 ECMAScript 核心类型和语法，提供特定于环境的额外功能。其他宿主环境还有服务器端 JavaScript 平台 Node.js 和即将被淘汰的 Adobe Flash。</p><p>如果不涉及浏览器的话，ECMA-262 到底定义了什么？在基本的层面，它描述这门语言的如下部分：</p><ul><li>语法</li><li>类型</li><li>语句</li><li>关键字</li><li>保留字</li><li>操作符</li><li>全局对象</li></ul><p>ECMAScript 只是对实现这个规范描述的所有方面的一门语言的称呼。JavaScript 实现了 ECMAScript，而 Adobe ActionScript 同样也实现了 ECMAScript。</p><h3 id=ecmascript-版本>ECMAScript 版本
<a class=anchor href=#ecmascript-%e7%89%88%e6%9c%ac>#</a></h3><p>ECMAScript 不同的版本以“edition”表示（也就是描述特定实现的 ECMA-262 的版本）。ECMA-262 最近的版本是第 10 版，发布于 2019 年 6 月。ECMA-262 的第 1 版本质上跟网景的 JavaScript 1.1 相同，只不过删除了所有浏览器特定的代码，外加少量细微的修改。ECMA-262 要求支持 Unicode 标准（以支持多语言），而且对象要与平台无关（Netscape JavaScript 1.1 的对象不是这样，比如它的 Date 对象就依赖平台）。这也是 JavaScript 1.1 和 JavaScript 1.2 不符合 ECMA-262 第 1 版要求的原因。</p><p>ECMA-262 第 2 版只是做了一些编校工作，主要是为了更新之后严格符合 ISO/IEC-16262 的要求，并没有增减或改变任何特性。ECMAScript 实现通常不使用第 2 版来衡量符合性（conformance）。</p><p>ECMA-262 第 3 版第一次真正对这个标准进行更新，更新了字符串处理、错误定义和数值输出。此外还增加了对正则表达式、新的控制语句、try/catch 异常处理的支持，以及为了更好地让标准国际化所做的少量修改。对很多人来说，这标志着 ECMAScript 作为一门真正的编程语言的时代终于到来了。</p><p>ECMA-262 第 4 版是对这门语言的一次彻底修订。作为对 JavaScript 在 Web 上日益成功的回应，开发者开始修订 ECMAScript 以满足全球 Web 开发日益增长的需求。为此，Ecma T39 再次被召集起来，以决定这门语言的未来。结果，他们制定的规范几乎在第 3 版基础上完全定义了一门新语言。第 4 版包括强类型变量、新语句和数据结构、真正的类和经典的继承，以及操作数据的新手段。</p><p>与此同时，TC39 委员会的一个子委员会也提出了另外一份提案，叫作“ECMAScript 3.1”，只对这门语言进行了较少的改进。这个子委员会的人认为第 4 版对这门语言来说跳跃太大了。因此，他们提出了一个改动较小的提案，只要在现有 JavaScript 引擎基础上做一些增改就可以实现。最终，ES3.1 子委员会赢得了 TC39 委员会的支持，ECMA-262 第 4 版在正式发布之前被放弃。</p><p>ECMAScript 3.1 变成了 ECMA-262 的第 5 版，于 2009 年 12 月 3 日正式发布。第 5 版致力于厘清第 3 版存在的歧义，也增加了新功能。新功能包括原生的解析和序列化 JSON 数据的 JSON 对象、方便继承和高级属性定义的方法，以及新的增强 ECMAScript 引擎解释和执行代码能力的严格模式。第 5 版在 2011 年 6 月发布了一个维护性修订版，这个修订版只更正了规范中的错误，并未增加任何新的语言或库特性。</p><p>ECMA-262 第 6 版，俗称 ES6、ES2015 或 ES Harmony（和谐版），于 2015 年 6 月发布。这一版包含了大概这个规范有史以来最重要的一批增强特性。ES6 正式支持了类、模块、迭代器、生成器、箭头函数、期约、反射、代理和众多新的数据类型。</p><p>ECMA-262 第 7 版，也称为 ES7 或 ES2016，于 2016 年 6 月发布。这次修订只包含少量语法层面的增强，如 Array.prototype.includes 和指数操作符。</p><p>ECMA-262 第 8 版，也称为 ES8、ES2017，完成于 2017 年 6 月。这一版主要增加了异步函数（async/await）、SharedArrayBuffer 及 Atomics API，以及 Object.values() / Object.entries() / Object.getOwnPropertyDescriptors() 和字符串填充方法，另外明确支持对象字面量最后的逗号。</p><p>ECMA-262 第 9 版，也称为 ES9、ES2018，发布于 2018 年 6 月。这次修订包括异步迭代、剩余和扩展属性、一组新的正则表达式特性、Promise finally()，以及模板字面量修订。</p><p>ECMA-262 第 10 版，也称为 ES10、ES2019，发布于 2019 年 6 月。这次修订增加了 Array.prototype.flat()/flatMap()、String.prototype.trimStart()/trimEnd()、Object.fromEntries()方法，以及 Symbol.prototype.description 属性，明确定义了 Function.prototype.toString()的返回值并固定了 Array.prototype.sort()的顺序。另外，这次修订解决了与 JSON 字符串兼容的问题，并定义了 catch 子句的可选绑定。</p><h3 id=ecmascript-符合性是什么意思>ECMAScript 符合性是什么意思
<a class=anchor href=#ecmascript-%e7%ac%a6%e5%90%88%e6%80%a7%e6%98%af%e4%bb%80%e4%b9%88%e6%84%8f%e6%80%9d>#</a></h3><p>ECMA-262 阐述了什么是 ECMAScript 符合性。要成为 ECMAScript 实现，必须满足下列条件：</p><ul><li>支持 ECMA-262 中描述的所有“类型、值、对象、属性、函数，以及程序语法与语义”；</li><li>支持 Unicode 字符标准。</li></ul><p>此外，符合性实现还可以满足下列要求。</p><ul><li>增加 ECMA-262 中未提及的“额外的类型、值、对象、属性和函数”。ECMA-262 所说的这些额外内容主要指规范中未给出的新对象或对象的新属性。</li><li>支持 ECMA-262 中没有定义的“程序和正则表达式语法”（意思是允许修改和扩展内置的正则表达式特性）。
以上条件为实现开发者基于 ECMAScript 开发语言提供了极大的权限和灵活度，也是其广受欢迎的原因之一。</li></ul><h3 id=浏览器对-ecmascript-的支持>浏览器对 ECMAScript 的支持
<a class=anchor href=#%e6%b5%8f%e8%a7%88%e5%99%a8%e5%af%b9-ecmascript-%e7%9a%84%e6%94%af%e6%8c%81>#</a></h3><p>1996 年，Netscape Navigator 3 发布时包含了 JavaScript 1.1。JavaScript 1.1 规范随后被提交给 Ecma，作为对新的 ECMA-262 标准的建议。随着 JavaScript 迅速走红，网景非常愿意开发 1.2 版。可是有个问题：Ecma 尚未接受网景的建议。</p><p>Netscape Navigator 3 发布后不久，微软推出了 IE3。IE 的这个版本包含了 JScript 1.0，本意是提供与 JavaScript 1.1 相同的功能。不过，由于缺少很多文档，而且还有不少重复性功能，JScript 1.0 远远没有 JavaScript 1.1 那么强大。</p><p>JScript 的再次更新出现在 IE4 中的 JScript 3.0（2.0 版是在 Microsoft Internet Information Server 3.0 中发布的，但从未包含在浏览器中）。微软发新闻稿称 JScript 3.0 是世界上第一门真正兼容 Ecma 标准的脚本语言。当时 ECMA-262 还没制定完成，因此 JScript 3.0 遭受了与 JavaScript 1.2 同样的命运，它同样没有遵守最终的 ECMAScript 标准。</p><p>网景又在 Netscape Navigator 4.06 中将其 JavaScript 版本升级到 1.3，因此做到了与 ECMA-262 第 1 版完全兼容。JavaScript 1.3 增加了对 Unicode 标准的支持，并做到了所有对象都与平台无关，同时保留了 JavaScript 1.2 所有的特性。</p><p>后来，当网景以 Mozilla 项目的名义向公众发布其源代码时，人们都期待 Netscape Navigator 5 中会包含 JavaScript 1.4。可是，一个完全重新设计网景代码的激进决定导致了人们的希望落空。JavaScript 1.4 只在 Netscape Enterprise Server 中作为服务器端语言发布了，从来就没有进入浏览器。</p><p>到了 2008 年，五大浏览器（IE、Firefox、Safari、Chrome 和 Opera）全部兼容 ECMA-262 第 3 版。IE8 率先实现 ECMA-262 第 5 版，并在 IE9 中完整支持。Firefox 4 很快也做到了。下表列出了主要的浏览器版本对 ECMAScript 的支持情况。</p><table><thead><tr><th>浏览器</th><th>ECMAScript 符合性</th></tr></thead><tbody><tr><td>Netscape Navigator 2</td><td>—</td></tr><tr><td>Netscape Navigator 3</td><td>—</td></tr><tr><td>Netscape Navigator 4~4.05</td><td>—</td></tr><tr><td>Netscape Navigator 4.06~4.79</td><td>第 1 版</td></tr><tr><td>Netscape 6+（Mozilla 0.6.0+）</td><td>第 3 版</td></tr><tr><td>IE3</td><td>—</td></tr><tr><td>IE4</td><td>—</td></tr><tr><td>IE5</td><td>第 1 版</td></tr><tr><td>IE5.5~8</td><td>第 3 版</td></tr><tr><td>IE9</td><td>第 5 版（部分）</td></tr><tr><td>IE10~11</td><td>第 5 版</td></tr><tr><td>Edge 12+</td><td>第 6 版</td></tr><tr><td>Opera</td><td>6~7.1 第 2 版</td></tr><tr><td>Opera</td><td>7.2+ 第 3 版</td></tr><tr><td>Opera</td><td>15~28 第 5 版</td></tr><tr><td>Opera</td><td>29~35 第 6 版（部分）</td></tr><tr><td>Opera</td><td>36+ 第 6 版</td></tr><tr><td>Safari</td><td>1~2.0.x 第 3 版（部分）</td></tr><tr><td>Safari</td><td>3.1~5.1 第 5 版（部分）</td></tr><tr><td>Safari</td><td>6~8 第 5 版</td></tr><tr><td>Safari</td><td>9+ 第 6 版</td></tr><tr><td>iOS Safari</td><td>3.2~5.1 第 5 版（部分）</td></tr><tr><td>iOS Safari</td><td>6~8.4 第 5 版</td></tr><tr><td>iOS Safari</td><td>9.2+ 第 6 版</td></tr><tr><td>Chrome</td><td>1~3 第 3 版</td></tr><tr><td>Chrome</td><td>4~22 第 5 版（部分）</td></tr><tr><td>Chrome</td><td>23+ 第 5 版</td></tr><tr><td>Chrome</td><td>42~48 第 6 版（部分）</td></tr><tr><td>Chrome</td><td>49+ 第 6 版</td></tr><tr><td>Firefox</td><td>1~2 第 3 版</td></tr><tr><td>Firefox</td><td>3.0.x~20 第 5 版（部分）</td></tr><tr><td>Firefox</td><td>21~44 第 5 版</td></tr><tr><td>Firefox</td><td>45+ 第 6 版</td></tr></tbody></table><h2 id=dom>DOM
<a class=anchor href=#dom>#</a></h2><p><strong>文档对象模型</strong>（DOM，Document Object Model）是一个应用编程接口（API），用于在 HTML 中使用扩展的 XML。DOM 将整个页面抽象为一组分层节点。HTML 或 XML 页面的每个组成部分都是一种节点，包含不同的数据。比如下面的 HTML 页面：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html>&lt;<span style=color:#f92672>html</span>&gt;
  &lt;<span style=color:#f92672>head</span>&gt;
    &lt;<span style=color:#f92672>title</span>&gt;Sample Page&lt;/<span style=color:#f92672>title</span>&gt;
  &lt;/<span style=color:#f92672>head</span>&gt;
  &lt;<span style=color:#f92672>body</span>&gt;
    &lt;<span style=color:#f92672>p</span>&gt;Hello World!&lt;/<span style=color:#f92672>p</span>&gt;
  &lt;/<span style=color:#f92672>body</span>&gt;
&lt;/<span style=color:#f92672>html</span>&gt;
</code></pre></div><p>这些代码通过 DOM 可以表示为一组分层节点，如图 1-2 所示。</p><p><img src=/images/javascript/1-2.png alt="图 1.2"></p><p>DOM 通过创建表示文档的树，让开发者可以随心所欲地控制网页的内容和结构。使用 DOM API，可以轻松地删除、添加、替换、修改节点。</p><h3 id=为什么-dom-是必需的>为什么 DOM 是必需的
<a class=anchor href=#%e4%b8%ba%e4%bb%80%e4%b9%88-dom-%e6%98%af%e5%bf%85%e9%9c%80%e7%9a%84>#</a></h3><p>在 IE4 和 Netscape Navigator 4 支持不同形式的动态 HTML（DHTML）的情况下，开发者首先可以做到不刷新页面而修改页面外观和内容。这代表了 Web 技术的一个巨大进步，但也暴露了很大的问题。由于网景和微软采用不同思路开发 DHTML，开发者写一个 HTML 页面就可以在任何浏览器中运行的好日子就此终结。</p><p>为了保持 Web 跨平台的本性，必须要做点什么。人们担心如果无法控制网景和微软各行其是，那么 Web 就会发生分裂，导致人们面向浏览器开发网页。就在这时，万维网联盟（W3C，World Wide Web Consortium）开始了制定 DOM 标准的进程。</p><h3 id=dom-级别>DOM 级别
<a class=anchor href=#dom-%e7%ba%a7%e5%88%ab>#</a></h3><p>1998 年 10 月，DOM Level 1 成为 W3C 的推荐标准。这个规范由两个模块组成：DOM Core 和 DOM HTML。前者提供了一种映射 XML 文档，从而方便访问和操作文档任意部分的方式；后者扩展了前者，并增加了特定于 HTML 的对象和方法。</p><blockquote class="book-hint warning"><strong>注意</strong><br>DOM 并非只能通过 JavaScript 访问，而且确实被其他很多语言实现了。不过对于浏览器来说，DOM 就是使用 ECMAScript 实现的，如今已经成为 JavaScript 语言的一大组成部分。</blockquote><p>DOM Level 1 的目标是映射文档结构，而 DOM Level 2 的目标则宽泛得多。这个对最初 DOM 的扩展增加了对（DHTML 早就支持的）鼠标和用户界面事件、范围、遍历（迭代 DOM 节点的方法）的支持，而且通过对象接口支持了层叠样式表（CSS）。另外，DOM Level 1 中的 DOM Core 也被扩展以包含对 XML 命名空间的支持。</p><p>DOM Level 2 新增了以下模块，以支持新的接口。</p><ul><li><strong>DOM 视图</strong>：描述追踪文档不同视图（如应用 CSS 样式前后的文档）的接口。</li><li><strong>DOM 事件</strong>：描述事件及事件处理的接口。</li><li><strong>DOM 样式</strong>：描述处理元素 CSS 样式的接口。</li><li><strong>DOM 遍历和范围</strong>：描述遍历和操作 DOM 树的接口。</li></ul><p>DOM Level 3 进一步扩展了 DOM，增加了以统一的方式加载和保存文档的方法（包含在一个叫 DOM Load and Save 的新模块中），还有验证文档的方法（DOM Validation）。在 Level 3 中，DOM Core 经过扩展支持了所有 XML 1.0 的特性，包括 XML Infoset、XPath 和 XML Base。</p><p>目前，W3C 不再按照 Level 来维护 DOM 了，而是作为 DOM Living Standard 来维护，其快照称为 DOM4。DOM4 新增的内容包括替代 Mutation Events 的 Mutation Observers。</p><blockquote class="book-hint warning"><strong>注意</strong><br>在阅读关于 DOM 的资料时，你可能会看到 DOM Level 0 的说法。注意，并没有一个标准叫“DOM Level 0”，这只是 DOM 历史中的一个参照点。DOM Level 0 可以看作 IE4 和 Netscape Navigator 4 中最初支持的 DHTML。</blockquote><h3 id=其他-dom>其他 DOM
<a class=anchor href=#%e5%85%b6%e4%bb%96-dom>#</a></h3><p>除了 DOM Core 和 DOM HTML 接口，有些其他语言也发布了自己的 DOM 标准。下面列出的语言是基于 XML 的，每一种都增加了该语言独有的 DOM 方法和接口：</p><ul><li>可伸缩矢量图（SVG，Scalable Vector Graphics）</li><li>数学标记语言（MathML，Mathematical Markup Language）</li><li>同步多媒体集成语言（SMIL，Synchronized Multimedia Integration Language）</li></ul><p>此外，还有一些语言开发了自己的 DOM 实现，比如 Mozilla 的 XML 用户界面语言（XUL，XML User Interface Language）。不过，只有前面列表中的语言是 W3C 推荐标准。</p><h3 id=web-浏览器对-dom-的支持情况>Web 浏览器对 DOM 的支持情况
<a class=anchor href=#web-%e6%b5%8f%e8%a7%88%e5%99%a8%e5%af%b9-dom-%e7%9a%84%e6%94%af%e6%8c%81%e6%83%85%e5%86%b5>#</a></h3><p>DOM 标准在 Web 浏览器实现它之前就已经作为标准发布了。IE 在第 5 版中尝试支持 DOM，但直到 5.5 版才开始真正支持，该版本实现了 DOM Level 1 的大部分。IE 在第 6 版和第 7 版中都没有实现新特性，第 8 版中修复了一些问题。</p><p>网景在 Netscape 6（Mozilla 0.6.0）之前都不支持 DOM。Netscape 7 之后，Mozilla 把开发资源转移到开发 Firefox 浏览器上。Firefox 3+支持全部的 Level 1、几乎全部的 Level 2，以及 Level 3 的某些部分。（Mozilla 开发团队的目标是打造百分之百兼容标准的浏览器，他们的工作也得到了应有的回报。）</p><p>支持 DOM 是浏览器厂商的重中之重，每个版本发布都会改进支持度。下表展示了主流浏览器支持 DOM 的情况。</p><table><thead><tr><th>浏览器</th><th>DOM 兼容</th></tr></thead><tbody><tr><td>Netscape Navigator 1~4.x</td><td>—</td></tr><tr><td>Netscape 6+（Mozilla 0.6.0+）</td><td>Level 1、Level 2（几乎全部）、Level 3（部分）</td></tr><tr><td>IE2~4.x</td><td>—</td></tr><tr><td>IE5</td><td>Level 1（很少）</td></tr><tr><td>IE5.5~8</td><td>Level 1（几乎全部）</td></tr><tr><td>IE9+</td><td>Level 1、Level 2、Level 3</td></tr><tr><td>Edge</td><td>Level 1、Level 2、Level 3</td></tr><tr><td>Opera 1~6</td><td>—</td></tr><tr><td>Opera 7~8.x</td><td>Level 1（几乎全部）、Level 2（部分）</td></tr><tr><td>Opera 9~9.9</td><td>Level 1、Level 2（几乎全部）、Level 3（部分）</td></tr><tr><td>Opera 10+</td><td>Level 1、Level 2、Level 3（部分）</td></tr><tr><td>Safari 1.0.x</td><td>Level 1</td></tr><tr><td>Safari 2+</td><td>Level 1、Level 2（部分）、Level 3（部分）</td></tr><tr><td>iOS Safari 3.2+</td><td>Level 1、Level 2（部分）、Level 3（部分）</td></tr><tr><td>Chrome 1+</td><td>Level 1、Level 2（部分）、Level 3（部分）</td></tr><tr><td>Firefox 1+</td><td>Level 1、Level 2（几乎全部）、Level 3（部分）</td></tr></tbody></table><blockquote class="book-hint warning"><strong>注意</strong>
上表中兼容性的状态会随时间而变化，其中的内容仅反映本文写作时的状态。</blockquote><h2 id=bom>BOM
<a class=anchor href=#bom>#</a></h2><p>IE3 和 Netscape Navigator 3 提供了浏览器对象模型（BOM） API，用于支持访问和操作浏览器的窗口。使用 BOM，开发者可以操控浏览器显示页面之外的部分。而 BOM 真正独一无二的地方，当然也是问题最多的地方，就是它是唯一一个没有相关标准的 JavaScript 实现。HTML5 改变了这个局面，这个版本的 HTML 以正式规范的形式涵盖了尽可能多的 BOM 特性。由于 HTML5 的出现，之前很多与 BOM 有关的问题都迎刃而解了。</p><p>总体来说，BOM 主要针对浏览器窗口和子窗口（frame），不过人们通常会把任何特定于浏览器的扩展都归在 BOM 的范畴内。比如，下面就是这样一些扩展：</p><ul><li>弹出新浏览器窗口的能力；</li><li>移动、缩放和关闭浏览器窗口的能力；</li><li>navigator 对象，提供关于浏览器的详尽信息；</li><li>location 对象，提供浏览器加载页面的详尽信息；</li><li>screen 对象，提供关于用户屏幕分辨率的详尽信息；</li><li>performance 对象，提供浏览器内存占用、导航行为和时间统计的详尽信息；</li><li>对 cookie 的支持；</li><li>其他自定义对象，如 XMLHttpRequest 和 IE 的 ActiveXObject。</li></ul><p>因为在很长时间内都没有标准，所以每个浏览器实现的都是自己的 BOM。有一些所谓的事实标准，比如对于 window 对象和 navigator 对象，每个浏览器都会给它们定义自己的属性和方法。现在有了 HTML5，BOM 的实现细节应该会日趋一致。要查阅关于 BOM 的详细介绍，请移步<a href=/docs/javascript/12/>这里</a>。</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function a(c){const a=window.getSelection(),b=document.createRange();b.selectNodeContents(c),a.removeAllRanges(),a.addRange(b)}document.querySelectorAll("pre code").forEach(b=>{b.addEventListener("click",function(c){a(b.parentElement),navigator.clipboard&&navigator.clipboard.writeText(b.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#ecmascript>ECMAScript</a><ul><li><a href=#ecmascript-版本>ECMAScript 版本</a></li><li><a href=#ecmascript-符合性是什么意思>ECMAScript 符合性是什么意思</a></li><li><a href=#浏览器对-ecmascript-的支持>浏览器对 ECMAScript 的支持</a></li></ul></li><li><a href=#dom>DOM</a><ul><li><a href=#为什么-dom-是必需的>为什么 DOM 是必需的</a></li><li><a href=#dom-级别>DOM 级别</a></li><li><a href=#其他-dom>其他 DOM</a></li><li><a href=#web-浏览器对-dom-的支持情况>Web 浏览器对 DOM 的支持情况</a></li></ul></li><li><a href=#bom>BOM</a></li></ul></nav></div></aside></main></body></html>