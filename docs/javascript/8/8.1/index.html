<!doctype html><html lang=zh dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="理解对象 #  创建自定义对象的通常方式是创建 Object 的一个新实例，然后再给它添加属性和方法，如下例所示：
let person = new Object(); person.name = &#34;Nicholas&#34;; person.age = 29; person.job = &#34;Software Engineer&#34;; person.sayName = function () { console.log(this.name); }; 这个例子创建了一个名为 person 的对象，而且有三个属性（name、age 和 job）和一个方法（sayName()）。sayName()方法会显示 this.name 的值，这个属性会解析为 person.name。早期 JavaScript 开发者频繁使用这种方式创建新对象。几年后，对象字面量变成了更流行的方式。前面的例子如果使用对象字面量则可以这样写：
let person = { name: &#34;Nicholas&#34;, age: 29, job: &#34;Software Engineer&#34;, sayName() { console.log(this.name); }, }; 这个例子中的 person 对象跟前面例子中的 person 对象是等价的，它们的属性和方法都一样。这些属性都有自己的特征，而这些特征决定了它们在 JavaScript 中的行为。
属性的类型 #  ECMA-262 使用一些内部特性来描述属性的特征。这些特性是由为 JavaScript 实现引擎的规范定义的。因此，开发者不能在 JavaScript 中直接访问这些特性。为了将某个特性标识为内部特性，规范会用两个中括号把特性的名称括起来，比如[[Enumerable]]。"><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="理解对象"><meta property="og:description" content="理解对象 #  创建自定义对象的通常方式是创建 Object 的一个新实例，然后再给它添加属性和方法，如下例所示：
let person = new Object(); person.name = &#34;Nicholas&#34;; person.age = 29; person.job = &#34;Software Engineer&#34;; person.sayName = function () { console.log(this.name); }; 这个例子创建了一个名为 person 的对象，而且有三个属性（name、age 和 job）和一个方法（sayName()）。sayName()方法会显示 this.name 的值，这个属性会解析为 person.name。早期 JavaScript 开发者频繁使用这种方式创建新对象。几年后，对象字面量变成了更流行的方式。前面的例子如果使用对象字面量则可以这样写：
let person = { name: &#34;Nicholas&#34;, age: 29, job: &#34;Software Engineer&#34;, sayName() { console.log(this.name); }, }; 这个例子中的 person 对象跟前面例子中的 person 对象是等价的，它们的属性和方法都一样。这些属性都有自己的特征，而这些特征决定了它们在 JavaScript 中的行为。
属性的类型 #  ECMA-262 使用一些内部特性来描述属性的特征。这些特性是由为 JavaScript 实现引擎的规范定义的。因此，开发者不能在 JavaScript 中直接访问这些特性。为了将某个特性标识为内部特性，规范会用两个中括号把特性的名称括起来，比如[[Enumerable]]。"><meta property="og:type" content="article"><meta property="og:url" content="https://hi-web.io/docs/javascript/8/8.1/"><meta property="article:section" content="docs"><title>理解对象 | Hi Web</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.3e90539cf7130f0a89ba2f8b9f54ac5e5ecdd1fa345b6c8e3e5a83ec6f19ec8e.css integrity="sha256-PpBTnPcTDwqJui+Ln1SsXl7N0fo0W2yOPlqD7G8Z7I4=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script><script defer src=/zh.search.min.a53f7096b2565476c1928b72df9484e169e2a670b1e3747ea341515c4930413f.js integrity="sha256-pT9wlrJWVHbBkoty35SE4WnipnCx43R+o0FRXEkwQT8=" crossorigin=anonymous></script><script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-156423980-1','auto'),ga('send','pageview'))</script><script async src=https://www.google-analytics.com/analytics.js></script><script data-ad-client=ca-pub-6487844781006261 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a href=/><span>Hi Web</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li class=book-section-flat><a href=https://hi-web.io/docs/javascript/>Javascript</a><ul><li><input type=checkbox id=section-a98eae978127bafe5d9b0cc6fcfe8d1b class=toggle>
<label for=section-a98eae978127bafe5d9b0cc6fcfe8d1b class="flex justify-between"><a href=https://hi-web.io/docs/javascript/1/>什么是 JavaScript</a></label><ul><li><a href=https://hi-web.io/docs/javascript/1/1.1/>简短的历史回顾</a></li><li><a href=https://hi-web.io/docs/javascript/1/1.2/>JavaScript 实现</a></li><li><a href=https://hi-web.io/docs/javascript/1/1.3/>JavaScript 版本</a></li><li><a href=https://hi-web.io/docs/javascript/1/1.4/>小结</a></li></ul></li><li><input type=checkbox id=section-13c960072f37f61a8695a75afa03bfa5 class=toggle>
<label for=section-13c960072f37f61a8695a75afa03bfa5 class="flex justify-between"><a href=https://hi-web.io/docs/javascript/2/>HTML 中的 JavaScript</a></label><ul><li><a href=https://hi-web.io/docs/javascript/2/2.1/>&lt;script> 元素</a></li><li><a href=https://hi-web.io/docs/javascript/2/2.2/>行内代码与外部文件</a></li><li><a href=https://hi-web.io/docs/javascript/2/2.3/>文档模式</a></li><li><a href=https://hi-web.io/docs/javascript/2/2.4/>&lt;noscript> 元素</a></li><li><a href=https://hi-web.io/docs/javascript/2/2.5/>小结</a></li></ul></li><li><input type=checkbox id=section-6aa73d0047b6c4a47e48010e1ab6843e class=toggle>
<label for=section-6aa73d0047b6c4a47e48010e1ab6843e class="flex justify-between"><a href=https://hi-web.io/docs/javascript/3/>语言基础</a></label><ul><li><a href=https://hi-web.io/docs/javascript/3/3.1/>语法</a></li></ul></li><li><input type=checkbox id=section-0517b866fbc9f4a1231cd89e84602147 class=toggle>
<label for=section-0517b866fbc9f4a1231cd89e84602147 class="flex justify-between"><a href=https://hi-web.io/docs/javascript/4/>变量、作用域与内存</a></label><ul><li><a href=https://hi-web.io/docs/javascript/4/4.1/>原始值与引用值</a></li></ul></li><li><input type=checkbox id=section-f0099a2820f72b7cbd5e830b9a6f653e class=toggle>
<label for=section-f0099a2820f72b7cbd5e830b9a6f653e class="flex justify-between"><a href=https://hi-web.io/docs/javascript/5/>基本引用类型</a></label><ul><li><a href=https://hi-web.io/docs/javascript/5/5.1/>Date</a></li></ul></li><li><input type=checkbox id=section-e50f1bea1c6f86dc765d50c5836823cb class=toggle>
<label for=section-e50f1bea1c6f86dc765d50c5836823cb class="flex justify-between"><a href=https://hi-web.io/docs/javascript/6/>集合引用类型</a></label><ul><li><a href=https://hi-web.io/docs/javascript/6/6.1/>Object</a></li></ul></li><li><input type=checkbox id=section-7e9f9df9783a9fed06a027def220f1c5 class=toggle>
<label for=section-7e9f9df9783a9fed06a027def220f1c5 class="flex justify-between"><a href=https://hi-web.io/docs/javascript/7/>迭代器与生成器</a></label><ul><li><a href=https://hi-web.io/docs/javascript/7/7.1/>理解迭代</a></li></ul></li><li><input type=checkbox id=section-ce2e75ee3c4bd5b8fcad41ee49cf5a84 class=toggle checked>
<label for=section-ce2e75ee3c4bd5b8fcad41ee49cf5a84 class="flex justify-between"><a href=https://hi-web.io/docs/javascript/8/>对象、类与面向对象编程</a></label><ul><li><a href=https://hi-web.io/docs/javascript/8/8.1/ class=active>理解对象</a></li></ul></li><li><input type=checkbox id=section-0c16022b762653ac1125e9cf6c7eab01 class=toggle>
<label for=section-0c16022b762653ac1125e9cf6c7eab01 class="flex justify-between"><a href=https://hi-web.io/docs/javascript/9/>代理与反射</a></label><ul><li><a href=https://hi-web.io/docs/javascript/9/9.1/>代理基础</a></li></ul></li><li><input type=checkbox id=section-d15886a42b556e7006a9b0ee252baf12 class=toggle>
<label for=section-d15886a42b556e7006a9b0ee252baf12 class="flex justify-between"><a href=https://hi-web.io/docs/javascript/10/>函数</a></label><ul><li><a href=https://hi-web.io/docs/javascript/10/10.1/>箭头函数</a></li></ul></li><li><input type=checkbox id=section-fa5c8de9ea31d3b55b3ecfdc90271591 class=toggle>
<label for=section-fa5c8de9ea31d3b55b3ecfdc90271591 class="flex justify-between"><a href=https://hi-web.io/docs/javascript/11/>期约与异步函数</a></label><ul><li><a href=https://hi-web.io/docs/javascript/11/11.1/>异步编程</a></li></ul></li><li><input type=checkbox id=section-d963f2603cce19cfc287fc10ec5a749b class=toggle>
<label for=section-d963f2603cce19cfc287fc10ec5a749b class="flex justify-between"><a href=https://hi-web.io/docs/javascript/12/>BOM</a></label><ul><li><a href=https://hi-web.io/docs/javascript/12/12.1/>window 对象</a></li></ul></li></ul></li></ul></nav><script>(function(){var a=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(b){localStorage.setItem("menu.scrollTop",a.scrollTop)}),a.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>理解对象</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#属性的类型>属性的类型</a><ul><li><a href=#数据属性>数据属性</a></li><li><a href=#访问器属性>访问器属性</a></li></ul></li><li><a href=#定义多个属性>定义多个属性</a></li><li><a href=#读取属性的特性>读取属性的特性</a></li><li><a href=#合并对象>合并对象</a></li><li><a href=#对象标识及相等判定>对象标识及相等判定</a></li><li><a href=#增强的对象语法>增强的对象语法</a><ul><li><a href=#属性值简写>属性值简写</a></li><li><a href=#可计算属性>可计算属性</a></li><li><a href=#简写方法名>简写方法名</a></li></ul></li><li><a href=#对象解构>对象解构</a><ul><li><a href=#嵌套解构>嵌套解构</a></li><li><a href=#部分解构>部分解构</a></li><li><a href=#参数上下文匹配>参数上下文匹配</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=理解对象>理解对象
<a class=anchor href=#%e7%90%86%e8%a7%a3%e5%af%b9%e8%b1%a1>#</a></h1><p>创建自定义对象的通常方式是创建 Object 的一个新实例，然后再给它添加属性和方法，如下例所示：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>person</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Object();
<span style=color:#a6e22e>person</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Nicholas&#34;</span>;
<span style=color:#a6e22e>person</span>.<span style=color:#a6e22e>age</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>29</span>;
<span style=color:#a6e22e>person</span>.<span style=color:#a6e22e>job</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Software Engineer&#34;</span>;
<span style=color:#a6e22e>person</span>.<span style=color:#a6e22e>sayName</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span> () {
  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span>);
};
</code></pre></div><p>这个例子创建了一个名为 person 的对象，而且有三个属性（name、age 和 job）和一个方法（sayName()）。sayName()方法会显示 this.name 的值，这个属性会解析为 person.name。早期 JavaScript 开发者频繁使用这种方式创建新对象。几年后，对象字面量变成了更流行的方式。前面的例子如果使用对象字面量则可以这样写：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>person</span> <span style=color:#f92672>=</span> {
  <span style=color:#a6e22e>name</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;Nicholas&#34;</span>,
  <span style=color:#a6e22e>age</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>29</span>,
  <span style=color:#a6e22e>job</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;Software Engineer&#34;</span>,
  <span style=color:#a6e22e>sayName</span>() {
    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span>);
  },
};
</code></pre></div><p>这个例子中的 person 对象跟前面例子中的 person 对象是等价的，它们的属性和方法都一样。这些属性都有自己的特征，而这些特征决定了它们在 JavaScript 中的行为。</p><h2 id=属性的类型>属性的类型
<a class=anchor href=#%e5%b1%9e%e6%80%a7%e7%9a%84%e7%b1%bb%e5%9e%8b>#</a></h2><p>ECMA-262 使用一些内部特性来描述属性的特征。这些特性是由为 JavaScript 实现引擎的规范定义的。因此，开发者不能在 JavaScript 中直接访问这些特性。为了将某个特性标识为内部特性，规范会用两个中括号把特性的名称括起来，比如[[Enumerable]]。</p><p>属性分两种：数据属性和访问器属性。</p><h3 id=数据属性>数据属性
<a class=anchor href=#%e6%95%b0%e6%8d%ae%e5%b1%9e%e6%80%a7>#</a></h3><p>数据属性包含一个保存数据值的位置。值会从这个位置读取，也会写入到这个位置。数据属性有 4 个特性描述它们的行为。</p><ul><li>[[Configurable]]：表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特性，以及是否可以把它改为访问器属性。默认情况下，所有直接定义在对象上的属性的这个特性都是 true，如前面的例子所示。</li><li>[[Enumerable]]：表示属性是否可以通过 for-in 循环返回。默认情况下，所有直接定义在对象上的属性的这个特性都是 true，如前面的例子所示。</li><li>[[Writable]]：表示属性的值是否可以被修改。默认情况下，所有直接定义在对象上的属性的这个特性都是 true，如前面的例子所示。</li><li>[[Value]]：包含属性实际的值。这就是前面提到的那个读取和写入属性值的位置。这个特性的默认值为 undefined。</li></ul><p>在像前面例子中那样将属性显式添加到对象之后，[[Configurable]]、[[Enumerable]]和[[Writable]]都会被设置为 true，而[[Value]]特性会被设置为指定的值。比如：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>person</span> <span style=color:#f92672>=</span> {
  <span style=color:#a6e22e>name</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;Nicholas&#34;</span>,
};
</code></pre></div><p>这里，我们创建了一个名为 name 的属性，并给它赋予了一个值"Nicholas"。这意味着[[Value]]特性会被设置为"Nicholas"，之后对这个值的任何修改都会保存这个位置。</p><p>要修改属性的默认特性，就必须使用 Object.defineProperty()方法。这个方法接收 3 个参数：要给其添加属性的对象、属性的名称和一个描述符对象。最后一个参数，即描述符对象上的属性可以包含：configurable、enumerable、writable 和 value，跟相关特性的名称一一对应。根据要修改的特性，可以设置其中一个或多个值。比如：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>person</span> <span style=color:#f92672>=</span> {};
Object.<span style=color:#a6e22e>defineProperty</span>(<span style=color:#a6e22e>person</span>, <span style=color:#e6db74>&#34;name&#34;</span>, {
  <span style=color:#a6e22e>writable</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>false</span>,
  <span style=color:#a6e22e>value</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;Nicholas&#34;</span>,
});
<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>person</span>.<span style=color:#a6e22e>name</span>); <span style=color:#75715e>// &#34;Nicholas&#34;
</span><span style=color:#75715e></span><span style=color:#a6e22e>person</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Greg&#34;</span>;
<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>person</span>.<span style=color:#a6e22e>name</span>); <span style=color:#75715e>// &#34;Nicholas&#34;
</span></code></pre></div><p>这个例子创建了一个名为 name 的属性并给它赋予了一个只读的值"Nicholas"。这个属性的值就不能再修改了，在非严格模式下尝试给这个属性重新赋值会被忽略。在严格模式下，尝试修改只读属性的值会抛出错误。</p><p>类似的规则也适用于创建不可配置的属性。比如：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>person</span> <span style=color:#f92672>=</span> {};
Object.<span style=color:#a6e22e>defineProperty</span>(<span style=color:#a6e22e>person</span>, <span style=color:#e6db74>&#34;name&#34;</span>, {
  <span style=color:#a6e22e>configurable</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>false</span>,
  <span style=color:#a6e22e>value</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;Nicholas&#34;</span>,
});
<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>person</span>.<span style=color:#a6e22e>name</span>); <span style=color:#75715e>// &#34;Nicholas&#34;
</span><span style=color:#75715e></span><span style=color:#66d9ef>delete</span> <span style=color:#a6e22e>person</span>.<span style=color:#a6e22e>name</span>;
<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>person</span>.<span style=color:#a6e22e>name</span>); <span style=color:#75715e>// &#34;Nicholas&#34;
</span></code></pre></div><p>这个例子把 configurable 设置为 false，意味着这个属性不能从对象上删除。非严格模式下对这个属性调用 delete 没有效果，严格模式下会抛出错误。此外，一个属性被定义为不可配置之后，就不能再变回可配置的了。再次调用 Object.defineProperty()并修改任何非 writable 属性会导致错误：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>person</span> <span style=color:#f92672>=</span> {};
Object.<span style=color:#a6e22e>defineProperty</span>(<span style=color:#a6e22e>person</span>, <span style=color:#e6db74>&#34;name&#34;</span>, {
  <span style=color:#a6e22e>configurable</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>false</span>,
  <span style=color:#a6e22e>value</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;Nicholas&#34;</span>,
});

<span style=color:#75715e>// 抛出错误
</span><span style=color:#75715e></span>Object.<span style=color:#a6e22e>defineProperty</span>(<span style=color:#a6e22e>person</span>, <span style=color:#e6db74>&#34;name&#34;</span>, {
  <span style=color:#a6e22e>configurable</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>true</span>,
  <span style=color:#a6e22e>value</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;Nicholas&#34;</span>,
});
</code></pre></div><p>因此，虽然可以对同一个属性多次调用 Object.defineProperty()，但在把 configurable 设置为 false 之后就会受限制了。</p><p>在调用 Object.defineProperty()时，configurable、enumerable 和 writable 的值如果不指定，则都默认为 false。多数情况下，可能都不需要 Object.defineProperty()提供的这些强大的设置，但要理解 JavaScript 对象，就要理解这些概念。</p><h3 id=访问器属性>访问器属性
<a class=anchor href=#%e8%ae%bf%e9%97%ae%e5%99%a8%e5%b1%9e%e6%80%a7>#</a></h3><p>访问器属性不包含数据值。相反，它们包含一个获取（getter）函数和一个设置（setter）函数，不过这两个函数不是必需的。在读取访问器属性时，会调用获取函数，这个函数的责任就是返回一个有效的值。在写入访问器属性时，会调用设置函数并传入新值，这个函数必须决定对数据做出什么修改。访问器属性有 4 个特性描述它们的行为。</p><ul><li><code>[[Configurable]]</code>：表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特性，以及是否可以把它改为数据属性。默认情况下，所有直接定义在对象上的属性的这个特性都是 true。</li><li><code>[[Enumerable]]</code>：表示属性是否可以通过 for-in 循环返回。默认情况下，所有直接定义在对象上的属性的这个特性都是 true。</li><li><code>[[Get]]</code>：获取函数，在读取属性时调用。默认值为 undefined。</li><li><code>[[Set]]</code>：设置函数，在写入属性时调用。默认值为 undefined。</li></ul><p>访问器属性是不能直接定义的，必须使用 Object.defineProperty()。下面是一个例子：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#75715e>// 定义一个对象，包含伪私有成员year_和公共成员edition
</span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>book</span> <span style=color:#f92672>=</span> {
  <span style=color:#a6e22e>year_</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>2017</span>,
  <span style=color:#a6e22e>edition</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>1</span>,
};

Object.<span style=color:#a6e22e>defineProperty</span>(<span style=color:#a6e22e>book</span>, <span style=color:#e6db74>&#34;year&#34;</span>, {
  <span style=color:#a6e22e>get</span>() {
    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>year_</span>;
  },
  <span style=color:#a6e22e>set</span>(<span style=color:#a6e22e>newValue</span>) {
    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>newValue</span> <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>2017</span>) {
      <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>year_</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>newValue</span>;
      <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>edition</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>newValue</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>2017</span>;
    }
  },
});
<span style=color:#a6e22e>book</span>.<span style=color:#a6e22e>year</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>2018</span>;
<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>book</span>.<span style=color:#a6e22e>edition</span>); <span style=color:#75715e>// 2
</span></code></pre></div><p>在这个例子中，对象 book 有两个默认属性：<code>year_</code> 和 <code>edition</code>。<code>year_</code> 中的下划线常用来表示该属性并不希望在对象方法的外部被访问。另一个属性 <code>year</code> 被定义为一个访问器属性，其中获取函数简单地返回 <code>year_</code> 的值，而设置函数会做一些计算以决定正确的版本（<code>edition</code>）。因此，把 <code>year</code> 属性修改为 2018 会导致 <code>year_</code> 变成 2018，<code>edition</code> 变成 2。这是访问器属性的典型使用场景，即设置一个属性值会导致一些其他变化发生。</p><p>获取函数和设置函数不一定都要定义。只定义获取函数意味着属性是只读的，尝试修改属性会被忽略。在严格模式下，尝试写入只定义了获取函数的属性会抛出错误。类似地，只有一个设置函数的属性是不能读取的，非严格模式下读取会返回 <code>undefined</code>，严格模式下会抛出错误。</p><p>在不支持 Object.defineProperty()的浏览器中没有办法修改 <code>[[Configurable]]</code> 或 <code>[[Enumerable]]</code>。</p><blockquote class="book-hint warning"><strong>注意</strong>
在 ECMAScript 5 以前，开发者会使用两个非标准的访问创建访问器属性：<code>__defineGetter__()</code> 和 <code>__defineSetter__()</code>。这两个方法最早是 Firefox 引入的，后来 Safari、Chrome 和 Opera 也实现了。</blockquote><h2 id=定义多个属性>定义多个属性
<a class=anchor href=#%e5%ae%9a%e4%b9%89%e5%a4%9a%e4%b8%aa%e5%b1%9e%e6%80%a7>#</a></h2><p>在一个对象上同时定义多个属性的可能性是非常大的。为此，ECMAScript 提供了 <code>Object.defineProperties()</code> 方法。这个方法可以通过多个描述符一次性定义多个属性。它接收两个参数：要为之添加或修改属性的对象和另一个描述符对象，其属性与要添加或修改的属性一一对应。比如：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>book</span> <span style=color:#f92672>=</span> {};
Object.<span style=color:#a6e22e>defineProperties</span>(<span style=color:#a6e22e>book</span>, {
  <span style=color:#a6e22e>year_</span><span style=color:#f92672>:</span> {
    <span style=color:#a6e22e>value</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>2017</span>,
  },

  <span style=color:#a6e22e>edition</span><span style=color:#f92672>:</span> {
    <span style=color:#a6e22e>value</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>1</span>,
  },

  <span style=color:#a6e22e>year</span><span style=color:#f92672>:</span> {
    <span style=color:#a6e22e>get</span>() {
      <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>year_</span>;
    },

    <span style=color:#a6e22e>set</span>(<span style=color:#a6e22e>newValue</span>) {
      <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>newValue</span> <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>2017</span>) {
        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>year_</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>newValue</span>;
        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>edition</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>newValue</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>2017</span>;
      }
    },
  },
});
</code></pre></div><p>这段代码在 book 对象上定义了两个数据属性 <code>year_</code> 和 <code>edition</code>，还有一个访问器属性 <code>year</code>。最终的对象跟上一节示例中的一样。唯一的区别是所有属性都是同时定义的，并且数据属性的 <code>configurable</code>、<code>enumerable</code> 和 <code>writable</code> 特性值都是 <code>false</code>。</p><h2 id=读取属性的特性>读取属性的特性
<a class=anchor href=#%e8%af%bb%e5%8f%96%e5%b1%9e%e6%80%a7%e7%9a%84%e7%89%b9%e6%80%a7>#</a></h2><p>使用 <code>Object.getOwnPropertyDescriptor()</code> 方法可以取得指定属性的属性描述符。这个方法接收两个参数：属性所在的对象和要取得其描述符的属性名。返回值是一个对象，对于访问器属性包含 <code>configurable</code>、<code>enumerable</code>、<code>get</code> 和 <code>set</code> 属性，对于数据属性包含 <code>configurable</code>、<code>enumerable</code>、<code>writable</code> 和 <code>value</code> 属性。比如：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>book</span> <span style=color:#f92672>=</span> {};
Object.<span style=color:#a6e22e>defineProperties</span>(<span style=color:#a6e22e>book</span>, {
  <span style=color:#a6e22e>year_</span><span style=color:#f92672>:</span> {
    <span style=color:#a6e22e>value</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>2017</span>,
  },

  <span style=color:#a6e22e>edition</span><span style=color:#f92672>:</span> {
    <span style=color:#a6e22e>value</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>1</span>,
  },

  <span style=color:#a6e22e>year</span><span style=color:#f92672>:</span> {
    <span style=color:#a6e22e>get</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>function</span> () {
      <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>year_</span>;
    },

    <span style=color:#a6e22e>set</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>function</span> (<span style=color:#a6e22e>newValue</span>) {
      <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>newValue</span> <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>2017</span>) {
        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>year_</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>newValue</span>;
        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>edition</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>newValue</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>2017</span>;
      }
    },
  },
});

<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>descriptor</span> <span style=color:#f92672>=</span> Object.<span style=color:#a6e22e>getOwnPropertyDescriptor</span>(<span style=color:#a6e22e>book</span>, <span style=color:#e6db74>&#34;year_&#34;</span>);
<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>descriptor</span>.<span style=color:#a6e22e>value</span>); <span style=color:#75715e>// 2017
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>descriptor</span>.<span style=color:#a6e22e>configurable</span>); <span style=color:#75715e>// false
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#66d9ef>typeof</span> <span style=color:#a6e22e>descriptor</span>.<span style=color:#a6e22e>get</span>); <span style=color:#75715e>// &#34;undefined&#34;
</span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>descriptor</span> <span style=color:#f92672>=</span> Object.<span style=color:#a6e22e>getOwnPropertyDescriptor</span>(<span style=color:#a6e22e>book</span>, <span style=color:#e6db74>&#34;year&#34;</span>);
<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>descriptor</span>.<span style=color:#a6e22e>value</span>); <span style=color:#75715e>// undefined
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>descriptor</span>.<span style=color:#a6e22e>enumerable</span>); <span style=color:#75715e>// false
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#66d9ef>typeof</span> <span style=color:#a6e22e>descriptor</span>.<span style=color:#a6e22e>get</span>); <span style=color:#75715e>// &#34;function&#34;
</span></code></pre></div><p>对于数据属性 <code>year_</code>，<code>value</code> 等于原来的值，<code>configurable</code> 是 <code>false</code>，<code>get</code> 是 <code>undefined</code>。对于访问器属性 <code>year</code>，<code>value</code> 是 <code>undefined</code>，<code>enumerable</code> 是 <code>false</code>，<code>get</code> 是一个指向获取函数的指针。</p><p>ECMAScript 2017 新增了 <code>Object.getOwnPropertyDescriptors()</code> 静态方法。这个方法实际上会在每个自有属性上调用 <code>Object.getOwnPropertyDescriptor()</code> 并在一个新对象中返回它们。对于前面的例子，使用这个静态方法会返回如下对象：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>book</span> <span style=color:#f92672>=</span> {};
Object.<span style=color:#a6e22e>defineProperties</span>(<span style=color:#a6e22e>book</span>, {
  <span style=color:#a6e22e>year_</span><span style=color:#f92672>:</span> {
    <span style=color:#a6e22e>value</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>2017</span>,
  },

  <span style=color:#a6e22e>edition</span><span style=color:#f92672>:</span> {
    <span style=color:#a6e22e>value</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>1</span>,
  },

  <span style=color:#a6e22e>year</span><span style=color:#f92672>:</span> {
    <span style=color:#a6e22e>get</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>function</span> () {
      <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>year_</span>;
    },

    <span style=color:#a6e22e>set</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>function</span> (<span style=color:#a6e22e>newValue</span>) {
      <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>newValue</span> <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>2017</span>) {
        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>year_</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>newValue</span>;
        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>edition</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>newValue</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>2017</span>;
      }
    },
  },
});

<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(Object.<span style=color:#a6e22e>getOwnPropertyDescriptors</span>(<span style=color:#a6e22e>book</span>));
<span style=color:#75715e>// {
</span><span style=color:#75715e>//   edition: {
</span><span style=color:#75715e>//     configurable: false,
</span><span style=color:#75715e>//     enumerable: false,
</span><span style=color:#75715e>//     value: 1,
</span><span style=color:#75715e>//     writable: false
</span><span style=color:#75715e>//   },
</span><span style=color:#75715e>//   year: {
</span><span style=color:#75715e>//     configurable: false,
</span><span style=color:#75715e>//     enumerable: false,
</span><span style=color:#75715e>//     get: f(),
</span><span style=color:#75715e>//     set: f(newValue),
</span><span style=color:#75715e>//   },
</span><span style=color:#75715e>//   year_: {
</span><span style=color:#75715e>//     configurable: false,
</span><span style=color:#75715e>//     enumerable: false,
</span><span style=color:#75715e>//     value: 2017,
</span><span style=color:#75715e>//     writable: false
</span><span style=color:#75715e>//   }
</span><span style=color:#75715e>// }
</span></code></pre></div><h2 id=合并对象>合并对象
<a class=anchor href=#%e5%90%88%e5%b9%b6%e5%af%b9%e8%b1%a1>#</a></h2><p>JavaScript 开发者经常觉得“合并”（merge）两个对象很有用。更具体地说，就是把源对象所有的本地属性一起复制到目标对象上。有时候这种操作也被称为“混入”（mixin），因为目标对象通过混入源对象的属性得到了增强。</p><p>ECMAScript 6 专门为合并对象提供了 <code>Object.assign()</code> 方法。这个方法接收一个目标对象和一个或多个源对象作为参数，然后将每个源对象中可枚举（<code>Object.propertyIsEnumerable()</code> 返回 <code>true</code>）和自有（<code>Object.hasOwnProperty()</code> 返回 <code>true</code>）属性复制到目标对象。以字符串和符号为键的属性会被复制。对每个符合条件的属性，这个方法会使用源对象上的 <code>[[Get]]</code> 取得属性的值，然后使用目标对象上的 <code>[[Set]]</code> 设置属性的值。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>dest</span>, <span style=color:#a6e22e>src</span>, <span style=color:#a6e22e>result</span>;

<span style=color:#75715e>/**
</span><span style=color:#75715e> * 简单复制
</span><span style=color:#75715e> */</span>
<span style=color:#a6e22e>dest</span> <span style=color:#f92672>=</span> {};
<span style=color:#a6e22e>src</span> <span style=color:#f92672>=</span> { <span style=color:#a6e22e>id</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;src&#34;</span> };

<span style=color:#a6e22e>result</span> <span style=color:#f92672>=</span> Object.<span style=color:#a6e22e>assign</span>(<span style=color:#a6e22e>dest</span>, <span style=color:#a6e22e>src</span>);

<span style=color:#75715e>// Object.assign修改目标对象
</span><span style=color:#75715e>// 也会返回修改后的目标对象
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>dest</span> <span style=color:#f92672>===</span> <span style=color:#a6e22e>result</span>); <span style=color:#75715e>// true
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>dest</span> <span style=color:#f92672>!==</span> <span style=color:#a6e22e>src</span>); <span style=color:#75715e>// true
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>result</span>); <span style=color:#75715e>// { id: src }
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>dest</span>); <span style=color:#75715e>// { id: src }
</span><span style=color:#75715e></span>
<span style=color:#75715e>/**
</span><span style=color:#75715e> * 多个源对象
</span><span style=color:#75715e> */</span>
<span style=color:#a6e22e>dest</span> <span style=color:#f92672>=</span> {};

<span style=color:#a6e22e>result</span> <span style=color:#f92672>=</span> Object.<span style=color:#a6e22e>assign</span>(<span style=color:#a6e22e>dest</span>, { <span style=color:#a6e22e>a</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;foo&#34;</span> }, { <span style=color:#a6e22e>b</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;bar&#34;</span> });

<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>result</span>); <span style=color:#75715e>// { a: foo, b: bar }
</span><span style=color:#75715e></span>
<span style=color:#75715e>/**
</span><span style=color:#75715e> * 获取函数与设置函数
</span><span style=color:#75715e> */</span>
<span style=color:#a6e22e>dest</span> <span style=color:#f92672>=</span> {
  <span style=color:#a6e22e>set</span> <span style=color:#a6e22e>a</span>(<span style=color:#a6e22e>val</span>) {
    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>`Invoked dest setter with param </span><span style=color:#e6db74>${</span><span style=color:#a6e22e>val</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>);
  },
};
<span style=color:#a6e22e>src</span> <span style=color:#f92672>=</span> {
  <span style=color:#a6e22e>get</span> <span style=color:#a6e22e>a</span>() {
    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;Invoked src getter&#34;</span>);
    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;foo&#34;</span>;
  },
};

Object.<span style=color:#a6e22e>assign</span>(<span style=color:#a6e22e>dest</span>, <span style=color:#a6e22e>src</span>);
<span style=color:#75715e>// 调用src的获取方法
</span><span style=color:#75715e>// 调用dest的设置方法并传入参数&#34;foo&#34;
</span><span style=color:#75715e>// 因为这里的设置函数不执行赋值操作
</span><span style=color:#75715e>// 所以实际上并没有把值转移过来
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>dest</span>); <span style=color:#75715e>// { set a(val) {...} }
</span></code></pre></div><p><code>Object.assign()</code> 实际上对每个源对象执行的是浅复制。如果多个源对象都有相同的属性，则使用最后一个复制的值。此外，从源对象访问器属性取得的值，比如获取函数，会作为一个静态值赋给目标对象。换句话说，不能在两个对象间转移获取函数和设置函数。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>dest</span>, <span style=color:#a6e22e>src</span>, <span style=color:#a6e22e>result</span>;

<span style=color:#75715e>/**
</span><span style=color:#75715e> * 覆盖属性
</span><span style=color:#75715e> */</span>
<span style=color:#a6e22e>dest</span> <span style=color:#f92672>=</span> { <span style=color:#a6e22e>id</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;dest&#34;</span> };

<span style=color:#a6e22e>result</span> <span style=color:#f92672>=</span> Object.<span style=color:#a6e22e>assign</span>(
  <span style=color:#a6e22e>dest</span>,
  { <span style=color:#a6e22e>id</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;src1&#34;</span>, <span style=color:#a6e22e>a</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;foo&#34;</span> },
  { <span style=color:#a6e22e>id</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;src2&#34;</span>, <span style=color:#a6e22e>b</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;bar&#34;</span> }
);

<span style=color:#75715e>// Object.assign会覆盖重复的属性
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>result</span>); <span style=color:#75715e>// { id: src2, a: foo, b: bar }
</span><span style=color:#75715e></span>
<span style=color:#75715e>// 可以通过目标对象上的设置函数观察到覆盖的过程：
</span><span style=color:#75715e></span><span style=color:#a6e22e>dest</span> <span style=color:#f92672>=</span> {
  <span style=color:#a6e22e>set</span> <span style=color:#a6e22e>id</span>(<span style=color:#a6e22e>x</span>) {
    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>x</span>);
  },
};

Object.<span style=color:#a6e22e>assign</span>(<span style=color:#a6e22e>dest</span>, { <span style=color:#a6e22e>id</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;first&#34;</span> }, { <span style=color:#a6e22e>id</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;second&#34;</span> }, { <span style=color:#a6e22e>id</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;third&#34;</span> });
<span style=color:#75715e>// first
</span><span style=color:#75715e>// second
</span><span style=color:#75715e>// third
</span><span style=color:#75715e></span>
<span style=color:#75715e>/**
</span><span style=color:#75715e> * 对象引用
</span><span style=color:#75715e> */</span>

<span style=color:#a6e22e>dest</span> <span style=color:#f92672>=</span> {};
<span style=color:#a6e22e>src</span> <span style=color:#f92672>=</span> { <span style=color:#a6e22e>a</span><span style=color:#f92672>:</span> {} };

Object.<span style=color:#a6e22e>assign</span>(<span style=color:#a6e22e>dest</span>, <span style=color:#a6e22e>src</span>);

<span style=color:#75715e>// 浅复制意味着只会复制对象的引用
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>dest</span>); <span style=color:#75715e>// { a :{} }
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>dest</span>.<span style=color:#a6e22e>a</span> <span style=color:#f92672>===</span> <span style=color:#a6e22e>src</span>.<span style=color:#a6e22e>a</span>); <span style=color:#75715e>// true
</span></code></pre></div><p>如果赋值期间出错，则操作会中止并退出，同时抛出错误。<code>Object.assign()</code> 没有“回滚”之前赋值的概念，因此它是一个尽力而为、可能只会完成部分复制的方法。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>dest</span>, <span style=color:#a6e22e>src</span>, <span style=color:#a6e22e>result</span>;

<span style=color:#75715e>/**
</span><span style=color:#75715e> * 错误处理
</span><span style=color:#75715e> */</span>
<span style=color:#a6e22e>dest</span> <span style=color:#f92672>=</span> {};
<span style=color:#a6e22e>src</span> <span style=color:#f92672>=</span> {
  <span style=color:#a6e22e>a</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;foo&#34;</span>,
  <span style=color:#a6e22e>get</span> <span style=color:#a6e22e>b</span>() {
    <span style=color:#75715e>// Object.assign()在调用这个获取函数时会抛出错误
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> Error();
  },
  <span style=color:#a6e22e>c</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;bar&#34;</span>,
};

<span style=color:#66d9ef>try</span> {
  Object.<span style=color:#a6e22e>assign</span>(<span style=color:#a6e22e>dest</span>, <span style=color:#a6e22e>src</span>);
} <span style=color:#66d9ef>catch</span> (<span style=color:#a6e22e>e</span>) {}

<span style=color:#75715e>// Object.assign()没办法回滚已经完成的修改
</span><span style=color:#75715e>// 因此在抛出错误之前，目标对象上已经完成的修改会继续存在：
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>dest</span>); <span style=color:#75715e>// { a: foo }
</span></code></pre></div><h2 id=对象标识及相等判定>对象标识及相等判定
<a class=anchor href=#%e5%af%b9%e8%b1%a1%e6%a0%87%e8%af%86%e5%8f%8a%e7%9b%b8%e7%ad%89%e5%88%a4%e5%ae%9a>#</a></h2><p>在 ECMAScript 6 之前，有些特殊情况即使是===操作符也无能为力：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#75715e>// 这些是===符合预期的情况
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#66d9ef>true</span> <span style=color:#f92672>===</span> <span style=color:#ae81ff>1</span>); <span style=color:#75715e>// false
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>({} <span style=color:#f92672>===</span> {}); <span style=color:#75715e>// false
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;2&#34;</span> <span style=color:#f92672>===</span> <span style=color:#ae81ff>2</span>); <span style=color:#75715e>// false
</span><span style=color:#75715e></span>
<span style=color:#75715e>// 这些情况在不同JavaScript引擎中表现不同，但仍被认为相等
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#f92672>+</span><span style=color:#ae81ff>0</span> <span style=color:#f92672>===</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>0</span>); <span style=color:#75715e>// true
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#f92672>+</span><span style=color:#ae81ff>0</span> <span style=color:#f92672>===</span> <span style=color:#ae81ff>0</span>); <span style=color:#75715e>// true
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>0</span> <span style=color:#f92672>===</span> <span style=color:#ae81ff>0</span>); <span style=color:#75715e>// true
</span><span style=color:#75715e></span>
<span style=color:#75715e>// 要确定NaN的相等性，必须使用极为讨厌的isNaN()
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#66d9ef>NaN</span> <span style=color:#f92672>===</span> <span style=color:#66d9ef>NaN</span>); <span style=color:#75715e>// false
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(isNaN(<span style=color:#66d9ef>NaN</span>)); <span style=color:#75715e>// true
</span></code></pre></div><p>为改善这类情况，ECMAScript 6 规范新增了 <code>Object.is()</code>，这个方法与 <code>===</code> 很像，但同时也考虑到了上述边界情形。这个方法必须接收两个参数：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(Object.<span style=color:#a6e22e>is</span>(<span style=color:#66d9ef>true</span>, <span style=color:#ae81ff>1</span>)); <span style=color:#75715e>// false
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(Object.<span style=color:#a6e22e>is</span>({}, {})); <span style=color:#75715e>// false
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(Object.<span style=color:#a6e22e>is</span>(<span style=color:#e6db74>&#34;2&#34;</span>, <span style=color:#ae81ff>2</span>)); <span style=color:#75715e>// false
</span><span style=color:#75715e></span>
<span style=color:#75715e>// 正确的0、-0、+0相等/不等判定
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(Object.<span style=color:#a6e22e>is</span>(<span style=color:#f92672>+</span><span style=color:#ae81ff>0</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>0</span>)); <span style=color:#75715e>// false
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(Object.<span style=color:#a6e22e>is</span>(<span style=color:#f92672>+</span><span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>)); <span style=color:#75715e>// true
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(Object.<span style=color:#a6e22e>is</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>)); <span style=color:#75715e>// false
</span><span style=color:#75715e></span>
<span style=color:#75715e>// 正确的NaN相等判定
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(Object.<span style=color:#a6e22e>is</span>(<span style=color:#66d9ef>NaN</span>, <span style=color:#66d9ef>NaN</span>)); <span style=color:#75715e>// true
</span></code></pre></div><p>要检查超过两个值，递归地利用相等性传递即可：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>recursivelyCheckEqual</span>(<span style=color:#a6e22e>x</span>, ...<span style=color:#a6e22e>rest</span>) {
  <span style=color:#66d9ef>return</span> (
    Object.<span style=color:#a6e22e>is</span>(<span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>rest</span>[<span style=color:#ae81ff>0</span>]) <span style=color:#f92672>&amp;&amp;</span> (<span style=color:#a6e22e>rest</span>.<span style=color:#a6e22e>length</span> <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>recursivelyCheckEqual</span>(...<span style=color:#a6e22e>rest</span>))
  );
}
</code></pre></div><h2 id=增强的对象语法>增强的对象语法
<a class=anchor href=#%e5%a2%9e%e5%bc%ba%e7%9a%84%e5%af%b9%e8%b1%a1%e8%af%ad%e6%b3%95>#</a></h2><p>ECMAScript 6 为定义和操作对象新增了很多极其有用的语法糖特性。这些特性都没有改变现有引擎的行为，但极大地提升了处理对象的方便程度。</p><p>本节介绍的所有对象语法同样适用于 ECMAScript 6 的类，本篇后面会讨论。</p><blockquote class="book-hint warning"><strong>注意</strong>
相比于以往的替代方案，本节介绍的增强对象语法可以说是一骑绝尘。因此后面会默认使用这些新语法特性。</blockquote><h3 id=属性值简写>属性值简写
<a class=anchor href=#%e5%b1%9e%e6%80%a7%e5%80%bc%e7%ae%80%e5%86%99>#</a></h3><p>在给对象添加变量的时候，开发者经常会发现属性名和变量名是一样的。例如：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Matt&#34;</span>;

<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>person</span> <span style=color:#f92672>=</span> {
  <span style=color:#a6e22e>name</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>name</span>,
};

<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>person</span>); <span style=color:#75715e>// { name: &#39;Matt&#39; }
</span></code></pre></div><p>为此，简写属性名语法出现了。简写属性名只要使用变量名（不用再写冒号）就会自动被解释为同名的属性键。如果没有找到同名变量，则会抛出 ReferenceError。</p><p>以下代码和之前的代码是等价的：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Matt&#34;</span>;

<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>person</span> <span style=color:#f92672>=</span> {
  <span style=color:#a6e22e>name</span>,
};

<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>person</span>); <span style=color:#75715e>// { name: &#39;Matt&#39; }
</span></code></pre></div><p>代码压缩程序会在不同作用域间保留属性名，以防止找不到引用。以下面的代码为例：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>makePerson</span>(<span style=color:#a6e22e>name</span>) {
  <span style=color:#66d9ef>return</span> {
    <span style=color:#a6e22e>name</span>,
  };
}

<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>person</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>makePerson</span>(<span style=color:#e6db74>&#34;Matt&#34;</span>);

<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>person</span>.<span style=color:#a6e22e>name</span>); <span style=color:#75715e>// Matt
</span></code></pre></div><p>在这里，即使参数标识符只限定于函数作用域，编译器也会保留初始的 name 标识符。如果使用 Google Closure 编译器压缩，那么函数参数会被缩短，而属性名不变：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>makePerson</span>(<span style=color:#a6e22e>a</span>) {
  <span style=color:#66d9ef>return</span> {
    <span style=color:#a6e22e>name</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>a</span>,
  };
}

<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>person</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>makePerson</span>(<span style=color:#e6db74>&#34;Matt&#34;</span>);

<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>person</span>.<span style=color:#a6e22e>name</span>); <span style=color:#75715e>// Matt
</span></code></pre></div><h3 id=可计算属性>可计算属性
<a class=anchor href=#%e5%8f%af%e8%ae%a1%e7%ae%97%e5%b1%9e%e6%80%a7>#</a></h3><p>在引入可计算属性之前，如果想使用变量的值作为属性，那么必须先声明对象，然后使用中括号语法来添加属性。换句话说，不能在对象字面量中直接动态命名属性。比如：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>nameKey</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;name&#34;</span>;
<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>ageKey</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;age&#34;</span>;
<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>jobKey</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;job&#34;</span>;

<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>person</span> <span style=color:#f92672>=</span> {};
<span style=color:#a6e22e>person</span>[<span style=color:#a6e22e>nameKey</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Matt&#34;</span>;
<span style=color:#a6e22e>person</span>[<span style=color:#a6e22e>ageKey</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>27</span>;
<span style=color:#a6e22e>person</span>[<span style=color:#a6e22e>jobKey</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Software engineer&#34;</span>;

<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>person</span>); <span style=color:#75715e>// { name: &#39;Matt&#39;, age: 27, job: &#39;Software engineer&#39; }
</span></code></pre></div><p>有了可计算属性，就可以在对象字面量中完成动态属性赋值。中括号包围的对象属性键告诉运行时将其作为 JavaScript 表达式而不是字符串来求值：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>nameKey</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;name&#34;</span>;
<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>ageKey</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;age&#34;</span>;
<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>jobKey</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;job&#34;</span>;

<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>person</span> <span style=color:#f92672>=</span> {
  [<span style=color:#a6e22e>nameKey</span>]<span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;Matt&#34;</span>,
  [<span style=color:#a6e22e>ageKey</span>]<span style=color:#f92672>:</span> <span style=color:#ae81ff>27</span>,
  [<span style=color:#a6e22e>jobKey</span>]<span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;Software engineer&#34;</span>,
};

<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>person</span>); <span style=color:#75715e>// { name: &#39;Matt&#39;, age: 27, job: &#39;Software engineer&#39; }
</span></code></pre></div><p>因为被当作 JavaScript 表达式求值，所以可计算属性本身可以是复杂的表达式，在实例化时再求值：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>nameKey</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;name&#34;</span>;
<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>ageKey</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;age&#34;</span>;
<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>jobKey</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;job&#34;</span>;
<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>uniqueToken</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;

<span style=color:#66d9ef>function</span> <span style=color:#a6e22e>getUniqueKey</span>(<span style=color:#a6e22e>key</span>) {
  <span style=color:#66d9ef>return</span> <span style=color:#e6db74>`</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>key</span><span style=color:#e6db74>}</span><span style=color:#e6db74>_</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>uniqueToken</span><span style=color:#f92672>++</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>;
}

<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>person</span> <span style=color:#f92672>=</span> {
  [<span style=color:#a6e22e>getUniqueKey</span>(<span style=color:#a6e22e>nameKey</span>)]<span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;Matt&#34;</span>,
  [<span style=color:#a6e22e>getUniqueKey</span>(<span style=color:#a6e22e>ageKey</span>)]<span style=color:#f92672>:</span> <span style=color:#ae81ff>27</span>,
  [<span style=color:#a6e22e>getUniqueKey</span>(<span style=color:#a6e22e>jobKey</span>)]<span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;Software engineer&#34;</span>,
};

<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>person</span>); <span style=color:#75715e>// { name_0: &#39;Matt&#39;, age_1: 27, job_2: &#39;Software engineer&#39; }
</span></code></pre></div><blockquote class="book-hint warning"><strong>注意</strong>
可计算属性表达式中抛出任何错误都会中断对象创建。如果计算属性的表达式有副作用，那就要小心了，因为如果表达式抛出错误，那么之前完成的计算是不能回滚的。</blockquote><h3 id=简写方法名>简写方法名
<a class=anchor href=#%e7%ae%80%e5%86%99%e6%96%b9%e6%b3%95%e5%90%8d>#</a></h3><p>在给对象定义方法时，通常都要写一个方法名、冒号，然后再引用一个匿名函数表达式，如下所示：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>person</span> <span style=color:#f92672>=</span> {
  <span style=color:#a6e22e>sayName</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>function</span> (<span style=color:#a6e22e>name</span>) {
    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>`My name is </span><span style=color:#e6db74>${</span><span style=color:#a6e22e>name</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>);
  },
};

<span style=color:#a6e22e>person</span>.<span style=color:#a6e22e>sayName</span>(<span style=color:#e6db74>&#34;Matt&#34;</span>); <span style=color:#75715e>// My name is Matt
</span></code></pre></div><p>新的简写方法的语法遵循同样的模式，但开发者要放弃给函数表达式命名（不过给作为方法的函数命名通常没什么用）。相应地，这样也可以明显缩短方法声明。</p><p>以下代码和之前的代码在行为上是等价的：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>person</span> <span style=color:#f92672>=</span> {
  <span style=color:#a6e22e>sayName</span>(<span style=color:#a6e22e>name</span>) {
    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>`My name is </span><span style=color:#e6db74>${</span><span style=color:#a6e22e>name</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>);
  },
};

<span style=color:#a6e22e>person</span>.<span style=color:#a6e22e>sayName</span>(<span style=color:#e6db74>&#34;Matt&#34;</span>); <span style=color:#75715e>// My name is Matt
</span></code></pre></div><p>简写方法名对获取函数和设置函数也是适用的：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>person</span> <span style=color:#f92672>=</span> {
  <span style=color:#a6e22e>name_</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;&#34;</span>,
  <span style=color:#a6e22e>get</span> <span style=color:#a6e22e>name</span>() {
    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name_</span>;
  },
  <span style=color:#a6e22e>set</span> <span style=color:#a6e22e>name</span>(<span style=color:#a6e22e>name</span>) {
    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name_</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>name</span>;
  },
  <span style=color:#a6e22e>sayName</span>() {
    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>`My name is </span><span style=color:#e6db74>${</span><span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name_</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>);
  },
};

<span style=color:#a6e22e>person</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Matt&#34;</span>;
<span style=color:#a6e22e>person</span>.<span style=color:#a6e22e>sayName</span>(); <span style=color:#75715e>// My name is Matt
</span></code></pre></div><p>简写方法名与可计算属性键相互兼容：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>methodKey</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;sayName&#34;</span>;

<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>person</span> <span style=color:#f92672>=</span> {
  [<span style=color:#a6e22e>methodKey</span>](<span style=color:#a6e22e>name</span>) {
    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>`My name is </span><span style=color:#e6db74>${</span><span style=color:#a6e22e>name</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>);
  },
};

<span style=color:#a6e22e>person</span>.<span style=color:#a6e22e>sayName</span>(<span style=color:#e6db74>&#34;Matt&#34;</span>); <span style=color:#75715e>// My name is Matt
</span></code></pre></div><blockquote class="book-hint warning"><strong>注意</strong>
简写方法名对于本篇后面介绍的 ECMAScript 6 的类更有用。</blockquote><h2 id=对象解构>对象解构
<a class=anchor href=#%e5%af%b9%e8%b1%a1%e8%a7%a3%e6%9e%84>#</a></h2><p>ECMAScript 6 新增了对象解构语法，可以在一条语句中使用嵌套数据实现一个或多个赋值操作。简单地说，对象解构就是使用与对象匹配的结构来实现对象属性赋值。</p><p>下面的例子展示了两段等价的代码，首先是不使用对象解构的：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#75715e>// 不使用对象解构
</span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>person</span> <span style=color:#f92672>=</span> {
  <span style=color:#a6e22e>name</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;Matt&#34;</span>,
  <span style=color:#a6e22e>age</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>27</span>,
};

<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>personName</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>person</span>.<span style=color:#a6e22e>name</span>,
  <span style=color:#a6e22e>personAge</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>person</span>.<span style=color:#a6e22e>age</span>;

<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>personName</span>); <span style=color:#75715e>// Matt
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>personAge</span>); <span style=color:#75715e>// 27
</span></code></pre></div><p>然后，是使用对象解构的：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#75715e>// 使用对象解构
</span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>person</span> <span style=color:#f92672>=</span> {
  <span style=color:#a6e22e>name</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;Matt&#34;</span>,
  <span style=color:#a6e22e>age</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>27</span>,
};

<span style=color:#66d9ef>let</span> { <span style=color:#a6e22e>name</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>personName</span>, <span style=color:#a6e22e>age</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>personAge</span> } <span style=color:#f92672>=</span> <span style=color:#a6e22e>person</span>;

<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>personName</span>); <span style=color:#75715e>// Matt
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>personAge</span>); <span style=color:#75715e>// 27
</span></code></pre></div><p>使用解构，可以在一个类似对象字面量的结构中，声明多个变量，同时执行多个赋值操作。如果想让变量直接使用属性的名称，那么可以使用简写语法，比如：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>person</span> <span style=color:#f92672>=</span> {
  <span style=color:#a6e22e>name</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;Matt&#34;</span>,
  <span style=color:#a6e22e>age</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>27</span>,
};

<span style=color:#66d9ef>let</span> { <span style=color:#a6e22e>name</span>, <span style=color:#a6e22e>age</span> } <span style=color:#f92672>=</span> <span style=color:#a6e22e>person</span>;

<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>name</span>); <span style=color:#75715e>// Matt
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>age</span>); <span style=color:#75715e>// 27
</span></code></pre></div><p>解构赋值不一定与对象的属性匹配。赋值的时候可以忽略某些属性，而如果引用的属性不存在，则该变量的值就是 undefined：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>person</span> <span style=color:#f92672>=</span> {
  <span style=color:#a6e22e>name</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;Matt&#34;</span>,
  <span style=color:#a6e22e>age</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>27</span>,
};

<span style=color:#66d9ef>let</span> { <span style=color:#a6e22e>name</span>, <span style=color:#a6e22e>job</span> } <span style=color:#f92672>=</span> <span style=color:#a6e22e>person</span>;

<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>name</span>); <span style=color:#75715e>// Matt
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>job</span>); <span style=color:#75715e>// undefined
</span></code></pre></div><p>也可以在解构赋值的同时定义默认值，这适用于前面刚提到的引用的属性不存在于源对象中的情况：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>person</span> <span style=color:#f92672>=</span> {
  <span style=color:#a6e22e>name</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;Matt&#34;</span>,
  <span style=color:#a6e22e>age</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>27</span>,
};

<span style=color:#66d9ef>let</span> { <span style=color:#a6e22e>name</span>, <span style=color:#a6e22e>job</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Software engineer&#34;</span> } <span style=color:#f92672>=</span> <span style=color:#a6e22e>person</span>;

<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>name</span>); <span style=color:#75715e>// Matt
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>job</span>); <span style=color:#75715e>// Software engineer
</span></code></pre></div><p>解构在内部使用函数 ToObject()（不能在运行时环境中直接访问）把源数据结构转换为对象。这意味着在对象解构的上下文中，原始值会被当成对象。这也意味着（根据 ToObject()的定义），null 和 undefined 不能被解构，否则会抛出错误。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>let</span> { <span style=color:#a6e22e>length</span> } <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;foobar&#34;</span>;
<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>length</span>); <span style=color:#75715e>// 6
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>let</span> { <span style=color:#a6e22e>constructor</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>c</span> } <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>;
<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>c</span> <span style=color:#f92672>===</span> Number); <span style=color:#75715e>// true
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>let</span> { <span style=color:#ae81ff>_</span> } <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>; <span style=color:#75715e>// TypeError
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>let</span> { <span style=color:#ae81ff>_</span> } <span style=color:#f92672>=</span> <span style=color:#66d9ef>undefined</span>; <span style=color:#75715e>// TypeError
</span></code></pre></div><p>解构并不要求变量必须在解构表达式中声明。不过，如果是给事先声明的变量赋值，则赋值表达式必须包含在一对括号中：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>personName</span>, <span style=color:#a6e22e>personAge</span>;

<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>person</span> <span style=color:#f92672>=</span> {
  <span style=color:#a6e22e>name</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;Matt&#34;</span>,
  <span style=color:#a6e22e>age</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>27</span>,
};

({ <span style=color:#a6e22e>name</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>personName</span>, <span style=color:#a6e22e>age</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>personAge</span> } <span style=color:#f92672>=</span> <span style=color:#a6e22e>person</span>);

<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>personName</span>, <span style=color:#a6e22e>personAge</span>); <span style=color:#75715e>// Matt, 27
</span></code></pre></div><h3 id=嵌套解构>嵌套解构
<a class=anchor href=#%e5%b5%8c%e5%a5%97%e8%a7%a3%e6%9e%84>#</a></h3><p>解构对于引用嵌套的属性或赋值目标没有限制。为此，可以通过解构来复制对象属性：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>person</span> <span style=color:#f92672>=</span> {
  <span style=color:#a6e22e>name</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;Matt&#34;</span>,
  <span style=color:#a6e22e>age</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>27</span>,
  <span style=color:#a6e22e>job</span><span style=color:#f92672>:</span> {
    <span style=color:#a6e22e>title</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;Software engineer&#34;</span>,
  },
};
<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>personCopy</span> <span style=color:#f92672>=</span> {};
({ <span style=color:#a6e22e>name</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>personCopy</span>.<span style=color:#a6e22e>name</span>, <span style=color:#a6e22e>age</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>personCopy</span>.<span style=color:#a6e22e>age</span>, <span style=color:#a6e22e>job</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>personCopy</span>.<span style=color:#a6e22e>job</span> } <span style=color:#f92672>=</span> <span style=color:#a6e22e>person</span>);

<span style=color:#75715e>// 因为一个对象的引用被赋值给personCopy，所以修改
</span><span style=color:#75715e>// person.job对象的属性也会影响personCopy
</span><span style=color:#75715e></span><span style=color:#a6e22e>person</span>.<span style=color:#a6e22e>job</span>.<span style=color:#a6e22e>title</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Hacker&#34;</span>;

<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>person</span>);
<span style=color:#75715e>// { name: &#39;Matt&#39;, age: 27, job: { title: &#39;Hacker&#39; } }
</span><span style=color:#75715e></span>
<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>personCopy</span>);
<span style=color:#75715e>// { name: &#39;Matt&#39;, age: 27, job: { title: &#39;Hacker&#39; } }
</span></code></pre></div><p>解构赋值可以使用嵌套结构，以匹配嵌套的属性：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>person</span> <span style=color:#f92672>=</span> {
  <span style=color:#a6e22e>name</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;Matt&#34;</span>,
  <span style=color:#a6e22e>age</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>27</span>,
  <span style=color:#a6e22e>job</span><span style=color:#f92672>:</span> {
    <span style=color:#a6e22e>title</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;Software engineer&#34;</span>,
  },
};

<span style=color:#75715e>// 声明title变量并将person.job.title的值赋给它
</span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> {
  <span style=color:#a6e22e>job</span><span style=color:#f92672>:</span> { <span style=color:#a6e22e>title</span> },
} <span style=color:#f92672>=</span> <span style=color:#a6e22e>person</span>;

<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>title</span>); <span style=color:#75715e>// Software engineer
</span></code></pre></div><p>在外层属性没有定义的情况下不能使用嵌套解构。无论源对象还是目标对象都一样：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>person</span> <span style=color:#f92672>=</span> {
  <span style=color:#a6e22e>job</span><span style=color:#f92672>:</span> {
    <span style=color:#a6e22e>title</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;Software engineer&#34;</span>,
  },
};
<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>personCopy</span> <span style=color:#f92672>=</span> {};

<span style=color:#75715e>// foo在源对象上是undefined
</span><span style=color:#75715e></span>({
  <span style=color:#a6e22e>foo</span><span style=color:#f92672>:</span> { <span style=color:#a6e22e>bar</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>personCopy</span>.<span style=color:#a6e22e>bar</span> },
} <span style=color:#f92672>=</span> <span style=color:#a6e22e>person</span>);
<span style=color:#75715e>// TypeError: Cannot destructure property &#39;bar&#39; of &#39;undefined&#39; or &#39;null&#39;.
</span><span style=color:#75715e></span>
<span style=color:#75715e>// job在目标对象上是undefined
</span><span style=color:#75715e></span>({
  <span style=color:#a6e22e>job</span><span style=color:#f92672>:</span> { <span style=color:#a6e22e>title</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>personCopy</span>.<span style=color:#a6e22e>job</span>.<span style=color:#a6e22e>title</span> },
} <span style=color:#f92672>=</span> <span style=color:#a6e22e>person</span>);
<span style=color:#75715e>// TypeError: Cannot set property &#39;title&#39; of undefined
</span></code></pre></div><h3 id=部分解构>部分解构
<a class=anchor href=#%e9%83%a8%e5%88%86%e8%a7%a3%e6%9e%84>#</a></h3><p>需要注意的是，涉及多个属性的解构赋值是一个输出无关的顺序化操作。如果一个解构表达式涉及多个赋值，开始的赋值成功而后面的赋值出错，则整个解构赋值只会完成一部分：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>person</span> <span style=color:#f92672>=</span> {
  <span style=color:#a6e22e>name</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;Matt&#34;</span>,
  <span style=color:#a6e22e>age</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>27</span>,
};

<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>personName</span>, <span style=color:#a6e22e>personBar</span>, <span style=color:#a6e22e>personAge</span>;

<span style=color:#66d9ef>try</span> {
  <span style=color:#75715e>// person.foo是undefined，因此会抛出错误
</span><span style=color:#75715e></span>  ({
    <span style=color:#a6e22e>name</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>personName</span>,
    <span style=color:#a6e22e>foo</span><span style=color:#f92672>:</span> { <span style=color:#a6e22e>bar</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>personBar</span> },
    <span style=color:#a6e22e>age</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>personAge</span>,
  } <span style=color:#f92672>=</span> <span style=color:#a6e22e>person</span>);
} <span style=color:#66d9ef>catch</span> (<span style=color:#a6e22e>e</span>) {}

<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>personName</span>, <span style=color:#a6e22e>personBar</span>, <span style=color:#a6e22e>personAge</span>);
<span style=color:#75715e>// Matt, undefined, undefined
</span></code></pre></div><h3 id=参数上下文匹配>参数上下文匹配
<a class=anchor href=#%e5%8f%82%e6%95%b0%e4%b8%8a%e4%b8%8b%e6%96%87%e5%8c%b9%e9%85%8d>#</a></h3><p>在函数参数列表中也可以进行解构赋值。对参数的解构赋值不会影响 arguments 对象，但可以在函数签名中声明在函数体内使用局部变量：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>person</span> <span style=color:#f92672>=</span> {
  <span style=color:#a6e22e>name</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;Matt&#34;</span>,
  <span style=color:#a6e22e>age</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>27</span>,
};

<span style=color:#66d9ef>function</span> <span style=color:#a6e22e>printPerson</span>(<span style=color:#a6e22e>foo</span>, { <span style=color:#a6e22e>name</span>, <span style=color:#a6e22e>age</span> }, <span style=color:#a6e22e>bar</span>) {
  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>arguments</span>);
  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>name</span>, <span style=color:#a6e22e>age</span>);
}

<span style=color:#66d9ef>function</span> <span style=color:#a6e22e>printPerson2</span>(<span style=color:#a6e22e>foo</span>, { <span style=color:#a6e22e>name</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>personName</span>, <span style=color:#a6e22e>age</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>personAge</span> }, <span style=color:#a6e22e>bar</span>) {
  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>arguments</span>);
  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>personName</span>, <span style=color:#a6e22e>personAge</span>);
}

<span style=color:#a6e22e>printPerson</span>(<span style=color:#e6db74>&#34;1st&#34;</span>, <span style=color:#a6e22e>person</span>, <span style=color:#e6db74>&#34;2nd&#34;</span>);
<span style=color:#75715e>// [&#39;1st&#39;, { name: &#39;Matt&#39;, age: 27 }, &#39;2nd&#39;]
</span><span style=color:#75715e>// &#39;Matt&#39;, 27
</span><span style=color:#75715e></span>
<span style=color:#a6e22e>printPerson2</span>(<span style=color:#e6db74>&#34;1st&#34;</span>, <span style=color:#a6e22e>person</span>, <span style=color:#e6db74>&#34;2nd&#34;</span>);
<span style=color:#75715e>// [&#39;1st&#39;, { name: &#39;Matt&#39;, age: 27 }, &#39;2nd&#39;]
</span><span style=color:#75715e>// &#39;Matt&#39;, 27
</span></code></pre></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function a(c){const a=window.getSelection(),b=document.createRange();b.selectNodeContents(c),a.removeAllRanges(),a.addRange(b)}document.querySelectorAll("pre code").forEach(b=>{b.addEventListener("click",function(c){a(b.parentElement),navigator.clipboard&&navigator.clipboard.writeText(b.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#属性的类型>属性的类型</a><ul><li><a href=#数据属性>数据属性</a></li><li><a href=#访问器属性>访问器属性</a></li></ul></li><li><a href=#定义多个属性>定义多个属性</a></li><li><a href=#读取属性的特性>读取属性的特性</a></li><li><a href=#合并对象>合并对象</a></li><li><a href=#对象标识及相等判定>对象标识及相等判定</a></li><li><a href=#增强的对象语法>增强的对象语法</a><ul><li><a href=#属性值简写>属性值简写</a></li><li><a href=#可计算属性>可计算属性</a></li><li><a href=#简写方法名>简写方法名</a></li></ul></li><li><a href=#对象解构>对象解构</a><ul><li><a href=#嵌套解构>嵌套解构</a></li><li><a href=#部分解构>部分解构</a></li><li><a href=#参数上下文匹配>参数上下文匹配</a></li></ul></li></ul></nav></div></aside></main></body></html>