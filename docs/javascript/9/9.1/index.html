<!doctype html><html lang=zh dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="代理基础 #  正如本篇开头所介绍的，代理是目标对象的抽象。从很多方面看，代理类似 C++指针，因为它可以用作目标对象的替身，但又完全独立于目标对象。目标对象既可以直接被操作，也可以通过代理来操作。但直接操作会绕过代理施予的行为。
注意 ECMAScript 代理与 C++指针有重大区别，后面会再讨论。不过作为一种有助于理解的类比，指针在概念上还是比较合适的结构。  创建空代理 #  最简单的代理是空代理，即除了作为一个抽象的目标对象，什么也不做。默认情况下，在代理对象上执行的所有操作都会无障碍地传播到目标对象。因此，在任何可以使用目标对象的地方，都可以通过同样的方式来使用与之关联的代理对象。
代理是使用 Proxy 构造函数创建的。这个构造函数接收两个参数：目标对象和处理程序对象。缺少其中任何一个参数都会抛出 TypeError。要创建空代理，可以传一个简单的对象字面量作为处理程序对象，从而让所有操作畅通无阻地抵达目标对象。
如下面的代码所示，在代理对象上执行的任何操作实际上都会应用到目标对象。唯一可感知的不同就是代码中操作的是代理对象。
const target = { id: &#34;target&#34;, }; const handler = {}; const proxy = new Proxy(target, handler); // id属性会访问同一个值 console.log(target.id); // target console.log(proxy.id); // target  // 给目标属性赋值会反映在两个对象上 // 因为两个对象访问的是同一个值 target.id = &#34;foo&#34;; console.log(target.id); // foo console.log(proxy.id); // foo  // 给代理属性赋值会反映在两个对象上 // 因为这个赋值会转移到目标对象 proxy.id = &#34;bar&#34;; console.log(target.id); // bar console.log(proxy.id); // bar  // hasOwnProperty()方法在两个地方 // 都会应用到目标对象 console."><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="代理基础"><meta property="og:description" content="代理基础 #  正如本篇开头所介绍的，代理是目标对象的抽象。从很多方面看，代理类似 C++指针，因为它可以用作目标对象的替身，但又完全独立于目标对象。目标对象既可以直接被操作，也可以通过代理来操作。但直接操作会绕过代理施予的行为。
注意 ECMAScript 代理与 C++指针有重大区别，后面会再讨论。不过作为一种有助于理解的类比，指针在概念上还是比较合适的结构。  创建空代理 #  最简单的代理是空代理，即除了作为一个抽象的目标对象，什么也不做。默认情况下，在代理对象上执行的所有操作都会无障碍地传播到目标对象。因此，在任何可以使用目标对象的地方，都可以通过同样的方式来使用与之关联的代理对象。
代理是使用 Proxy 构造函数创建的。这个构造函数接收两个参数：目标对象和处理程序对象。缺少其中任何一个参数都会抛出 TypeError。要创建空代理，可以传一个简单的对象字面量作为处理程序对象，从而让所有操作畅通无阻地抵达目标对象。
如下面的代码所示，在代理对象上执行的任何操作实际上都会应用到目标对象。唯一可感知的不同就是代码中操作的是代理对象。
const target = { id: &#34;target&#34;, }; const handler = {}; const proxy = new Proxy(target, handler); // id属性会访问同一个值 console.log(target.id); // target console.log(proxy.id); // target  // 给目标属性赋值会反映在两个对象上 // 因为两个对象访问的是同一个值 target.id = &#34;foo&#34;; console.log(target.id); // foo console.log(proxy.id); // foo  // 给代理属性赋值会反映在两个对象上 // 因为这个赋值会转移到目标对象 proxy.id = &#34;bar&#34;; console.log(target.id); // bar console.log(proxy.id); // bar  // hasOwnProperty()方法在两个地方 // 都会应用到目标对象 console."><meta property="og:type" content="article"><meta property="og:url" content="https://hi-web.io/docs/javascript/9/9.1/"><meta property="article:section" content="docs"><title>代理基础 | Hi Web</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.3e90539cf7130f0a89ba2f8b9f54ac5e5ecdd1fa345b6c8e3e5a83ec6f19ec8e.css integrity="sha256-PpBTnPcTDwqJui+Ln1SsXl7N0fo0W2yOPlqD7G8Z7I4=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script><script defer src=/zh.search.min.a53f7096b2565476c1928b72df9484e169e2a670b1e3747ea341515c4930413f.js integrity="sha256-pT9wlrJWVHbBkoty35SE4WnipnCx43R+o0FRXEkwQT8=" crossorigin=anonymous></script><script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-156423980-1','auto'),ga('send','pageview'))</script><script async src=https://www.google-analytics.com/analytics.js></script><script data-ad-client=ca-pub-6487844781006261 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a href=/><span>Hi Web</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li class=book-section-flat><a href=https://hi-web.io/docs/javascript/>Javascript</a><ul><li><input type=checkbox id=section-a98eae978127bafe5d9b0cc6fcfe8d1b class=toggle>
<label for=section-a98eae978127bafe5d9b0cc6fcfe8d1b class="flex justify-between"><a href=https://hi-web.io/docs/javascript/1/>什么是 JavaScript</a></label><ul><li><a href=https://hi-web.io/docs/javascript/1/1.1/>简短的历史回顾</a></li><li><a href=https://hi-web.io/docs/javascript/1/1.2/>JavaScript 实现</a></li><li><a href=https://hi-web.io/docs/javascript/1/1.3/>JavaScript 版本</a></li><li><a href=https://hi-web.io/docs/javascript/1/1.4/>小结</a></li></ul></li><li><input type=checkbox id=section-13c960072f37f61a8695a75afa03bfa5 class=toggle>
<label for=section-13c960072f37f61a8695a75afa03bfa5 class="flex justify-between"><a href=https://hi-web.io/docs/javascript/2/>HTML 中的 JavaScript</a></label><ul><li><a href=https://hi-web.io/docs/javascript/2/2.1/>&lt;script> 元素</a></li><li><a href=https://hi-web.io/docs/javascript/2/2.2/>行内代码与外部文件</a></li><li><a href=https://hi-web.io/docs/javascript/2/2.3/>文档模式</a></li><li><a href=https://hi-web.io/docs/javascript/2/2.4/>&lt;noscript> 元素</a></li><li><a href=https://hi-web.io/docs/javascript/2/2.5/>小结</a></li></ul></li><li><input type=checkbox id=section-6aa73d0047b6c4a47e48010e1ab6843e class=toggle>
<label for=section-6aa73d0047b6c4a47e48010e1ab6843e class="flex justify-between"><a href=https://hi-web.io/docs/javascript/3/>语言基础</a></label><ul><li><a href=https://hi-web.io/docs/javascript/3/3.1/>语法</a></li></ul></li><li><input type=checkbox id=section-0517b866fbc9f4a1231cd89e84602147 class=toggle>
<label for=section-0517b866fbc9f4a1231cd89e84602147 class="flex justify-between"><a href=https://hi-web.io/docs/javascript/4/>变量、作用域与内存</a></label><ul><li><a href=https://hi-web.io/docs/javascript/4/4.1/>原始值与引用值</a></li></ul></li><li><input type=checkbox id=section-f0099a2820f72b7cbd5e830b9a6f653e class=toggle>
<label for=section-f0099a2820f72b7cbd5e830b9a6f653e class="flex justify-between"><a href=https://hi-web.io/docs/javascript/5/>基本引用类型</a></label><ul><li><a href=https://hi-web.io/docs/javascript/5/5.1/>Date</a></li></ul></li><li><input type=checkbox id=section-e50f1bea1c6f86dc765d50c5836823cb class=toggle>
<label for=section-e50f1bea1c6f86dc765d50c5836823cb class="flex justify-between"><a href=https://hi-web.io/docs/javascript/6/>集合引用类型</a></label><ul><li><a href=https://hi-web.io/docs/javascript/6/6.1/>Object</a></li></ul></li><li><input type=checkbox id=section-7e9f9df9783a9fed06a027def220f1c5 class=toggle>
<label for=section-7e9f9df9783a9fed06a027def220f1c5 class="flex justify-between"><a href=https://hi-web.io/docs/javascript/7/>迭代器与生成器</a></label><ul><li><a href=https://hi-web.io/docs/javascript/7/7.1/>理解迭代</a></li></ul></li><li><input type=checkbox id=section-ce2e75ee3c4bd5b8fcad41ee49cf5a84 class=toggle>
<label for=section-ce2e75ee3c4bd5b8fcad41ee49cf5a84 class="flex justify-between"><a href=https://hi-web.io/docs/javascript/8/>对象、类与面向对象编程</a></label><ul><li><a href=https://hi-web.io/docs/javascript/8/8.1/>理解对象</a></li></ul></li><li><input type=checkbox id=section-0c16022b762653ac1125e9cf6c7eab01 class=toggle checked>
<label for=section-0c16022b762653ac1125e9cf6c7eab01 class="flex justify-between"><a href=https://hi-web.io/docs/javascript/9/>代理与反射</a></label><ul><li><a href=https://hi-web.io/docs/javascript/9/9.1/ class=active>代理基础</a></li></ul></li><li><input type=checkbox id=section-d15886a42b556e7006a9b0ee252baf12 class=toggle>
<label for=section-d15886a42b556e7006a9b0ee252baf12 class="flex justify-between"><a href=https://hi-web.io/docs/javascript/10/>函数</a></label><ul><li><a href=https://hi-web.io/docs/javascript/10/10.1/>箭头函数</a></li></ul></li><li><input type=checkbox id=section-fa5c8de9ea31d3b55b3ecfdc90271591 class=toggle>
<label for=section-fa5c8de9ea31d3b55b3ecfdc90271591 class="flex justify-between"><a href=https://hi-web.io/docs/javascript/11/>期约与异步函数</a></label><ul><li><a href=https://hi-web.io/docs/javascript/11/11.1/>异步编程</a></li></ul></li><li><input type=checkbox id=section-d963f2603cce19cfc287fc10ec5a749b class=toggle>
<label for=section-d963f2603cce19cfc287fc10ec5a749b class="flex justify-between"><a href=https://hi-web.io/docs/javascript/12/>BOM</a></label><ul><li><a href=https://hi-web.io/docs/javascript/12/12.1/>window 对象</a></li></ul></li></ul></li></ul></nav><script>(function(){var a=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(b){localStorage.setItem("menu.scrollTop",a.scrollTop)}),a.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>代理基础</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#创建空代理>创建空代理</a></li><li><a href=#定义捕获器>定义捕获器</a></li><li><a href=#捕获器参数和反射-api>捕获器参数和反射 API</a></li><li><a href=#捕获器不变式>捕获器不变式</a></li><li><a href=#可撤销代理>可撤销代理</a></li><li><a href=#实用反射-api>实用反射 API</a><ul><li><a href=#反射-api-与对象-api>反射 API 与对象 API</a></li><li><a href=#状态标记>状态标记</a></li><li><a href=#用一等函数替代操作符>用一等函数替代操作符</a></li><li><a href=#安全地应用函数>安全地应用函数</a></li></ul></li><li><a href=#代理另一个代理>代理另一个代理</a></li><li><a href=#代理的问题与不足>代理的问题与不足</a><ul><li><a href=#代理中的-this>代理中的 <code>this</code></a></li><li><a href=#代理与内部槽位>代理与内部槽位</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=代理基础>代理基础
<a class=anchor href=#%e4%bb%a3%e7%90%86%e5%9f%ba%e7%a1%80>#</a></h1><p>正如本篇开头所介绍的，代理是目标对象的抽象。从很多方面看，代理类似 C++指针，因为它可以用作目标对象的替身，但又完全独立于目标对象。目标对象既可以直接被操作，也可以通过代理来操作。但直接操作会绕过代理施予的行为。</p><blockquote class="book-hint warning"><strong>注意</strong>
ECMAScript 代理与 C++指针有重大区别，后面会再讨论。不过作为一种有助于理解的类比，指针在概念上还是比较合适的结构。</blockquote><h2 id=创建空代理>创建空代理
<a class=anchor href=#%e5%88%9b%e5%bb%ba%e7%a9%ba%e4%bb%a3%e7%90%86>#</a></h2><p>最简单的代理是空代理，即除了作为一个抽象的目标对象，什么也不做。默认情况下，在代理对象上执行的所有操作都会无障碍地传播到目标对象。因此，在任何可以使用目标对象的地方，都可以通过同样的方式来使用与之关联的代理对象。</p><p>代理是使用 Proxy 构造函数创建的。这个构造函数接收两个参数：目标对象和处理程序对象。缺少其中任何一个参数都会抛出 TypeError。要创建空代理，可以传一个简单的对象字面量作为处理程序对象，从而让所有操作畅通无阻地抵达目标对象。</p><p>如下面的代码所示，在代理对象上执行的任何操作实际上都会应用到目标对象。唯一可感知的不同就是代码中操作的是代理对象。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>target</span> <span style=color:#f92672>=</span> {
  <span style=color:#a6e22e>id</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;target&#34;</span>,
};

<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>handler</span> <span style=color:#f92672>=</span> {};

<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>proxy</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Proxy(<span style=color:#a6e22e>target</span>, <span style=color:#a6e22e>handler</span>);

<span style=color:#75715e>// id属性会访问同一个值
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>target</span>.<span style=color:#a6e22e>id</span>); <span style=color:#75715e>// target
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>proxy</span>.<span style=color:#a6e22e>id</span>); <span style=color:#75715e>// target
</span><span style=color:#75715e></span>
<span style=color:#75715e>// 给目标属性赋值会反映在两个对象上
</span><span style=color:#75715e>// 因为两个对象访问的是同一个值
</span><span style=color:#75715e></span><span style=color:#a6e22e>target</span>.<span style=color:#a6e22e>id</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;foo&#34;</span>;
<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>target</span>.<span style=color:#a6e22e>id</span>); <span style=color:#75715e>// foo
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>proxy</span>.<span style=color:#a6e22e>id</span>); <span style=color:#75715e>// foo
</span><span style=color:#75715e></span>
<span style=color:#75715e>// 给代理属性赋值会反映在两个对象上
</span><span style=color:#75715e>// 因为这个赋值会转移到目标对象
</span><span style=color:#75715e></span><span style=color:#a6e22e>proxy</span>.<span style=color:#a6e22e>id</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;bar&#34;</span>;
<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>target</span>.<span style=color:#a6e22e>id</span>); <span style=color:#75715e>// bar
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>proxy</span>.<span style=color:#a6e22e>id</span>); <span style=color:#75715e>// bar
</span><span style=color:#75715e></span>
<span style=color:#75715e>// hasOwnProperty()方法在两个地方
</span><span style=color:#75715e>// 都会应用到目标对象
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>target</span>.<span style=color:#a6e22e>hasOwnProperty</span>(<span style=color:#e6db74>&#34;id&#34;</span>)); <span style=color:#75715e>// true
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>proxy</span>.<span style=color:#a6e22e>hasOwnProperty</span>(<span style=color:#e6db74>&#34;id&#34;</span>)); <span style=color:#75715e>// true
</span><span style=color:#75715e></span>
<span style=color:#75715e>// Proxy.prototype是undefined
</span><span style=color:#75715e>// 因此不能使用instanceof操作符
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>target</span> <span style=color:#66d9ef>instanceof</span> Proxy); <span style=color:#75715e>// TypeError: Function has non-object prototype &#39;undefined&#39; in instanceof check
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>proxy</span> <span style=color:#66d9ef>instanceof</span> Proxy); <span style=color:#75715e>// TypeError: Function has non-object prototype &#39;undefined&#39; in instanceof check
</span><span style=color:#75715e></span>
<span style=color:#75715e>// 严格相等可以用来区分代理和目标
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>target</span> <span style=color:#f92672>===</span> <span style=color:#a6e22e>proxy</span>); <span style=color:#75715e>// false
</span></code></pre></div><h2 id=定义捕获器>定义捕获器
<a class=anchor href=#%e5%ae%9a%e4%b9%89%e6%8d%95%e8%8e%b7%e5%99%a8>#</a></h2><p>使用代理的主要目的是可以定义捕获器（trap）。捕获器就是在处理程序对象中定义的“基本操作的拦截器”。每个处理程序对象可以包含零个或多个捕获器，每个捕获器都对应一种基本操作，可以直接或间接在代理对象上调用。每次在代理对象上调用这些基本操作时，代理可以在这些操作传播到目标对象之前先调用捕获器函数，从而拦截并修改相应的行为。</p><blockquote class="book-hint warning"><strong>注意</strong>
捕获器（trap）是从操作系统中借用的概念。在操作系统中，捕获器是程序流中的一个同步中断，可以暂停程序流，转而执行一段子例程，之后再返回原始程序流。</blockquote><p>例如，可以定义一个 get()捕获器，在 ECMAScript 操作以某种形式调用 get()时触发。下面的例子定义了一个 get()捕获器：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>target</span> <span style=color:#f92672>=</span> {
  <span style=color:#a6e22e>foo</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;bar&#34;</span>,
};

<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>handler</span> <span style=color:#f92672>=</span> {
  <span style=color:#75715e>// 捕获器在处理程序对象中以方法名为键
</span><span style=color:#75715e></span>  <span style=color:#a6e22e>get</span>() {
    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;handler override&#34;</span>;
  },
};

<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>proxy</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Proxy(<span style=color:#a6e22e>target</span>, <span style=color:#a6e22e>handler</span>);
</code></pre></div><p>这样，当通过代理对象执行 get()操作时，就会触发定义的 get()捕获器。当然，get()不是 ECMAScript 对象可以调用的方法。这个操作在 JavaScript 代码中可以通过多种形式触发并被 get()捕获器拦截到。proxy[property]、proxy.property 或 Object.create(proxy)[property]等操作都会触发基本的 get()操作以获取属性。因此所有这些操作只要发生在代理对象上，就会触发 get()捕获器。注意，只有在代理对象上执行这些操作才会触发捕获器。在目标对象上执行这些操作仍然会产生正常的行为。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>target</span> <span style=color:#f92672>=</span> {
  <span style=color:#a6e22e>foo</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;bar&#34;</span>,
};

<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>handler</span> <span style=color:#f92672>=</span> {
  <span style=color:#75715e>// 捕获器在处理程序对象中以方法名为键
</span><span style=color:#75715e></span>  <span style=color:#a6e22e>get</span>() {
    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;handler override&#34;</span>;
  },
};

<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>proxy</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Proxy(<span style=color:#a6e22e>target</span>, <span style=color:#a6e22e>handler</span>);

<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>target</span>.<span style=color:#a6e22e>foo</span>); <span style=color:#75715e>// bar
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>proxy</span>.<span style=color:#a6e22e>foo</span>); <span style=color:#75715e>// handler override
</span><span style=color:#75715e></span>
<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>target</span>[<span style=color:#e6db74>&#34;foo&#34;</span>]); <span style=color:#75715e>// bar
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>proxy</span>[<span style=color:#e6db74>&#34;foo&#34;</span>]); <span style=color:#75715e>// handler override
</span><span style=color:#75715e></span>
<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(Object.<span style=color:#a6e22e>create</span>(<span style=color:#a6e22e>target</span>)[<span style=color:#e6db74>&#34;foo&#34;</span>]); <span style=color:#75715e>// bar
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(Object.<span style=color:#a6e22e>create</span>(<span style=color:#a6e22e>proxy</span>)[<span style=color:#e6db74>&#34;foo&#34;</span>]); <span style=color:#75715e>// handler override
</span></code></pre></div><h2 id=捕获器参数和反射-api>捕获器参数和反射 API
<a class=anchor href=#%e6%8d%95%e8%8e%b7%e5%99%a8%e5%8f%82%e6%95%b0%e5%92%8c%e5%8f%8d%e5%b0%84-api>#</a></h2><p>所有捕获器都可以访问相应的参数，基于这些参数可以重建被捕获方法的原始行为。比如，get()捕获器会接收到目标对象、要查询的属性和代理对象三个参数。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>target</span> <span style=color:#f92672>=</span> {
  <span style=color:#a6e22e>foo</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;bar&#34;</span>,
};

<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>handler</span> <span style=color:#f92672>=</span> {
  <span style=color:#a6e22e>get</span>(<span style=color:#a6e22e>trapTarget</span>, <span style=color:#a6e22e>property</span>, <span style=color:#a6e22e>receiver</span>) {
    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>trapTarget</span> <span style=color:#f92672>===</span> <span style=color:#a6e22e>target</span>);
    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>property</span>);
    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>receiver</span> <span style=color:#f92672>===</span> <span style=color:#a6e22e>proxy</span>);
  },
};

<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>proxy</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Proxy(<span style=color:#a6e22e>target</span>, <span style=color:#a6e22e>handler</span>);

<span style=color:#a6e22e>proxy</span>.<span style=color:#a6e22e>foo</span>;
<span style=color:#75715e>// true
</span><span style=color:#75715e>// foo
</span><span style=color:#75715e>// true
</span></code></pre></div><p>有了这些参数，就可以重建被捕获方法的原始行为：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>target</span> <span style=color:#f92672>=</span> {
  <span style=color:#a6e22e>foo</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;bar&#34;</span>,
};

<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>handler</span> <span style=color:#f92672>=</span> {
  <span style=color:#a6e22e>get</span>(<span style=color:#a6e22e>trapTarget</span>, <span style=color:#a6e22e>property</span>, <span style=color:#a6e22e>receiver</span>) {
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>trapTarget</span>[<span style=color:#a6e22e>property</span>];
  },
};

<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>proxy</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Proxy(<span style=color:#a6e22e>target</span>, <span style=color:#a6e22e>handler</span>);

<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>proxy</span>.<span style=color:#a6e22e>foo</span>); <span style=color:#75715e>// bar
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>target</span>.<span style=color:#a6e22e>foo</span>); <span style=color:#75715e>// bar
</span></code></pre></div><p>所有捕获器都可以基于自己的参数重建原始操作，但并非所有捕获器行为都像 get()那么简单。因此，通过手动写码如法炮制的想法是不现实的。实际上，开发者并不需要手动重建原始行为，而是可以通过调用全局 Reflect 对象上（封装了原始行为）的同名方法来轻松重建。</p><p>处理程序对象中所有可以捕获的方法都有对应的反射（Reflect）API 方法。这些方法与捕获器拦截的方法具有相同的名称和函数签名，而且也具有与被拦截方法相同的行为。因此，使用反射 API 也可以像下面这样定义出空代理对象：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>target</span> <span style=color:#f92672>=</span> {
  <span style=color:#a6e22e>foo</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;bar&#34;</span>,
};

<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>handler</span> <span style=color:#f92672>=</span> {
  <span style=color:#a6e22e>get</span>() {
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Reflect</span>.<span style=color:#a6e22e>get</span>(...<span style=color:#a6e22e>arguments</span>);
  },
};

<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>proxy</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Proxy(<span style=color:#a6e22e>target</span>, <span style=color:#a6e22e>handler</span>);

<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>proxy</span>.<span style=color:#a6e22e>foo</span>); <span style=color:#75715e>// bar
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>target</span>.<span style=color:#a6e22e>foo</span>); <span style=color:#75715e>// bar
</span></code></pre></div><p>甚至还可以写得更简洁一些：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>target</span> <span style=color:#f92672>=</span> {
  <span style=color:#a6e22e>foo</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;bar&#34;</span>,
};

<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>handler</span> <span style=color:#f92672>=</span> {
  <span style=color:#a6e22e>get</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>Reflect</span>.<span style=color:#a6e22e>get</span>,
};

<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>proxy</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Proxy(<span style=color:#a6e22e>target</span>, <span style=color:#a6e22e>handler</span>);

<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>proxy</span>.<span style=color:#a6e22e>foo</span>); <span style=color:#75715e>// bar
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>target</span>.<span style=color:#a6e22e>foo</span>); <span style=color:#75715e>// bar
</span></code></pre></div><p>事实上，如果真想创建一个可以捕获所有方法，然后将每个方法转发给对应反射 API 的空代理，那么甚至不需要定义处理程序对象：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>target</span> <span style=color:#f92672>=</span> {
  <span style=color:#a6e22e>foo</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;bar&#34;</span>,
};

<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>proxy</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Proxy(<span style=color:#a6e22e>target</span>, <span style=color:#a6e22e>Reflect</span>);

<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>proxy</span>.<span style=color:#a6e22e>foo</span>); <span style=color:#75715e>// bar
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>target</span>.<span style=color:#a6e22e>foo</span>); <span style=color:#75715e>// bar
</span></code></pre></div><p>反射 API 为开发者准备好了样板代码，在此基础上开发者可以用最少的代码修改捕获的方法。比如，下面的代码在某个属性被访问时，会对返回的值进行一番修饰：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>target</span> <span style=color:#f92672>=</span> {
  <span style=color:#a6e22e>foo</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;bar&#34;</span>,
  <span style=color:#a6e22e>baz</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;qux&#34;</span>,
};

<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>handler</span> <span style=color:#f92672>=</span> {
  <span style=color:#a6e22e>get</span>(<span style=color:#a6e22e>trapTarget</span>, <span style=color:#a6e22e>property</span>, <span style=color:#a6e22e>receiver</span>) {
    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>decoration</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;&#34;</span>;
    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>property</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#34;foo&#34;</span>) {
      <span style=color:#a6e22e>decoration</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;!!!&#34;</span>;
    }

    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Reflect</span>.<span style=color:#a6e22e>get</span>(...<span style=color:#a6e22e>arguments</span>) <span style=color:#f92672>+</span> <span style=color:#a6e22e>decoration</span>;
  },
};

<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>proxy</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Proxy(<span style=color:#a6e22e>target</span>, <span style=color:#a6e22e>handler</span>);

<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>proxy</span>.<span style=color:#a6e22e>foo</span>); <span style=color:#75715e>// bar!!!
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>target</span>.<span style=color:#a6e22e>foo</span>); <span style=color:#75715e>// bar
</span><span style=color:#75715e></span>
<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>proxy</span>.<span style=color:#a6e22e>baz</span>); <span style=color:#75715e>// qux
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>target</span>.<span style=color:#a6e22e>baz</span>); <span style=color:#75715e>// qux
</span></code></pre></div><h2 id=捕获器不变式>捕获器不变式
<a class=anchor href=#%e6%8d%95%e8%8e%b7%e5%99%a8%e4%b8%8d%e5%8f%98%e5%bc%8f>#</a></h2><p>使用捕获器几乎可以改变所有基本方法的行为，但也不是没有限制。根据 ECMAScript 规范，每个捕获的方法都知道目标对象上下文、捕获函数签名，而捕获处理程序的行为必须遵循“捕获器不变式”（trap invariant）。捕获器不变式因方法不同而异，但通常都会防止捕获器定义出现过于反常的行为。</p><p>比如，如果目标对象有一个不可配置且不可写的数据属性，那么在捕获器返回一个与该属性不同的值时，会抛出 TypeError：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>target</span> <span style=color:#f92672>=</span> {};
Object.<span style=color:#a6e22e>defineProperty</span>(<span style=color:#a6e22e>target</span>, <span style=color:#e6db74>&#34;foo&#34;</span>, {
  <span style=color:#a6e22e>configurable</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>false</span>,
  <span style=color:#a6e22e>writable</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>false</span>,
  <span style=color:#a6e22e>value</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;bar&#34;</span>,
});

<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>handler</span> <span style=color:#f92672>=</span> {
  <span style=color:#a6e22e>get</span>() {
    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;qux&#34;</span>;
  },
};

<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>proxy</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Proxy(<span style=color:#a6e22e>target</span>, <span style=color:#a6e22e>handler</span>);

<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>proxy</span>.<span style=color:#a6e22e>foo</span>);
<span style=color:#75715e>// TypeError
</span></code></pre></div><h2 id=可撤销代理>可撤销代理
<a class=anchor href=#%e5%8f%af%e6%92%a4%e9%94%80%e4%bb%a3%e7%90%86>#</a></h2><p>有时候可能需要中断代理对象与目标对象之间的联系。对于使用 new Proxy()创建的普通代理来说，这种联系会在代理对象的生命周期内一直持续存在。</p><p>Proxy 也暴露了 revocable()方法，这个方法支持撤销代理对象与目标对象的关联。撤销代理的操作是不可逆的。而且，撤销函数（revoke()）是幂等的，调用多少次的结果都一样。撤销代理之后再调用代理会抛出 TypeError。</p><p>撤销函数和代理对象是在实例化时同时生成的：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>target</span> <span style=color:#f92672>=</span> {
  <span style=color:#a6e22e>foo</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;bar&#34;</span>,
};

<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>handler</span> <span style=color:#f92672>=</span> {
  <span style=color:#a6e22e>get</span>() {
    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;intercepted&#34;</span>;
  },
};

<span style=color:#66d9ef>const</span> { <span style=color:#a6e22e>proxy</span>, <span style=color:#a6e22e>revoke</span> } <span style=color:#f92672>=</span> Proxy.<span style=color:#a6e22e>revocable</span>(<span style=color:#a6e22e>target</span>, <span style=color:#a6e22e>handler</span>);

<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>proxy</span>.<span style=color:#a6e22e>foo</span>); <span style=color:#75715e>// intercepted
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>target</span>.<span style=color:#a6e22e>foo</span>); <span style=color:#75715e>// bar
</span><span style=color:#75715e></span>
<span style=color:#a6e22e>revoke</span>();

<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>proxy</span>.<span style=color:#a6e22e>foo</span>); <span style=color:#75715e>// TypeError
</span></code></pre></div><h2 id=实用反射-api>实用反射 API
<a class=anchor href=#%e5%ae%9e%e7%94%a8%e5%8f%8d%e5%b0%84-api>#</a></h2><p>某些情况下应该优先使用反射 API，这是有一些理由的。</p><h3 id=反射-api-与对象-api>反射 API 与对象 API
<a class=anchor href=#%e5%8f%8d%e5%b0%84-api-%e4%b8%8e%e5%af%b9%e8%b1%a1-api>#</a></h3><p>在使用反射 API 时，要记住：</p><p>(1) 反射 API 并不限于捕获处理程序；</p><p>(2) 大多数反射 API 方法在 Object 类型上有对应的方法。</p><p>通常，Object 上的方法适用于通用程序，而反射方法适用于细粒度的对象控制与操作。</p><h3 id=状态标记>状态标记
<a class=anchor href=#%e7%8a%b6%e6%80%81%e6%a0%87%e8%ae%b0>#</a></h3><p>很多反射方法返回称作“状态标记”的布尔值，表示意图执行的操作是否成功。有时候，状态标记比那些返回修改后的对象或者抛出错误（取决于方法）的反射 API 方法更有用。例如，可以使用反射 API 对下面的代码进行重构：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#75715e>// 初始代码
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>o</span> <span style=color:#f92672>=</span> {};

<span style=color:#66d9ef>try</span> {
  Object.<span style=color:#a6e22e>defineProperty</span>(<span style=color:#a6e22e>o</span>, <span style=color:#e6db74>&#34;foo&#34;</span>, <span style=color:#e6db74>&#34;bar&#34;</span>);
  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;success&#34;</span>);
} <span style=color:#66d9ef>catch</span> (<span style=color:#a6e22e>e</span>) {
  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;failure&#34;</span>);
}
</code></pre></div><p>在定义新属性时如果发生问题，Reflect.defineProperty()会返回 false，而不是抛出错误。因此使用这个反射方法可以这样重构上面的代码：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#75715e>// 重构后的代码
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>o</span> <span style=color:#f92672>=</span> {};

<span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>Reflect</span>.<span style=color:#a6e22e>defineProperty</span>(<span style=color:#a6e22e>o</span>, <span style=color:#e6db74>&#34;foo&#34;</span>, { <span style=color:#a6e22e>value</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;bar&#34;</span> })) {
  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;success&#34;</span>);
} <span style=color:#66d9ef>else</span> {
  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;failure&#34;</span>);
}
</code></pre></div><p>以下反射方法都会提供状态标记：</p><ul><li>Reflect.defineProperty()</li><li>Reflect.preventExtensions()</li><li>Reflect.setPrototypeOf()</li><li>Reflect.set()</li><li>Reflect.deleteProperty()</li></ul><h3 id=用一等函数替代操作符>用一等函数替代操作符
<a class=anchor href=#%e7%94%a8%e4%b8%80%e7%ad%89%e5%87%bd%e6%95%b0%e6%9b%bf%e4%bb%a3%e6%93%8d%e4%bd%9c%e7%ac%a6>#</a></h3><p>以下反射方法提供只有通过操作符才能完成的操作。</p><ul><li>Reflect.get()：可以替代对象属性访问操作符。</li><li>Reflect.set()：可以替代=赋值操作符。</li><li>Reflect.has()：可以替代 in 操作符或 with()。</li><li>Reflect.deleteProperty()：可以替代 delete 操作符。</li><li>Reflect.construct()：可以替代 new 操作符。</li></ul><h3 id=安全地应用函数>安全地应用函数
<a class=anchor href=#%e5%ae%89%e5%85%a8%e5%9c%b0%e5%ba%94%e7%94%a8%e5%87%bd%e6%95%b0>#</a></h3><p>在通过 apply 方法调用函数时，被调用的函数可能也定义了自己的 apply 属性（虽然可能性极小）。为绕过这个问题，可以使用定义在 Function 原型上的 apply 方法，比如：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js>Function.<span style=color:#a6e22e>prototype</span>.<span style=color:#a6e22e>apply</span>.<span style=color:#a6e22e>call</span>(<span style=color:#a6e22e>myFunc</span>, <span style=color:#a6e22e>thisVal</span>, <span style=color:#a6e22e>argumentList</span>);
</code></pre></div><p>这种可怕的代码完全可以使用 Reflect.apply 来避免：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#a6e22e>Reflect</span>.<span style=color:#a6e22e>apply</span>(<span style=color:#a6e22e>myFunc</span>, <span style=color:#a6e22e>thisVal</span>, <span style=color:#a6e22e>argumentsList</span>);
</code></pre></div><h2 id=代理另一个代理>代理另一个代理
<a class=anchor href=#%e4%bb%a3%e7%90%86%e5%8f%a6%e4%b8%80%e4%b8%aa%e4%bb%a3%e7%90%86>#</a></h2><p>代理可以拦截反射 API 的操作，而这意味着完全可以创建一个代理，通过它去代理另一个代理。这样就可以在一个目标对象之上构建多层拦截网：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>target</span> <span style=color:#f92672>=</span> {
  <span style=color:#a6e22e>foo</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;bar&#34;</span>,
};

<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>firstProxy</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Proxy(<span style=color:#a6e22e>target</span>, {
  <span style=color:#a6e22e>get</span>() {
    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;first proxy&#34;</span>);
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Reflect</span>.<span style=color:#a6e22e>get</span>(...<span style=color:#a6e22e>arguments</span>);
  },
});

<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>secondProxy</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Proxy(<span style=color:#a6e22e>firstProxy</span>, {
  <span style=color:#a6e22e>get</span>() {
    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;second proxy&#34;</span>);
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Reflect</span>.<span style=color:#a6e22e>get</span>(...<span style=color:#a6e22e>arguments</span>);
  },
});

<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>secondProxy</span>.<span style=color:#a6e22e>foo</span>);
<span style=color:#75715e>// second proxy
</span><span style=color:#75715e>// first proxy
</span><span style=color:#75715e>// bar
</span></code></pre></div><h2 id=代理的问题与不足>代理的问题与不足
<a class=anchor href=#%e4%bb%a3%e7%90%86%e7%9a%84%e9%97%ae%e9%a2%98%e4%b8%8e%e4%b8%8d%e8%b6%b3>#</a></h2><p>代理是在 ECMAScript 现有基础之上构建起来的一套新 API，因此其实现已经尽力做到最好了。很大程度上，代理作为对象的虚拟层可以正常使用。但在某些情况下，代理也不能与现在的 ECMAScript 机制很好地协同。</p><h3 id=代理中的-this>代理中的 <code>this</code>
<a class=anchor href=#%e4%bb%a3%e7%90%86%e4%b8%ad%e7%9a%84-this>#</a></h3><p>代理潜在的一个问题来源是 this 值。我们知道，方法中的 this 通常指向调用这个方法的对象：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>target</span> <span style=color:#f92672>=</span> {
  <span style=color:#a6e22e>thisValEqualsProxy</span>() {
    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span> <span style=color:#f92672>===</span> <span style=color:#a6e22e>proxy</span>;
  },
};

<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>proxy</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Proxy(<span style=color:#a6e22e>target</span>, {});

<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>target</span>.<span style=color:#a6e22e>thisValEqualsProxy</span>()); <span style=color:#75715e>// false
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>proxy</span>.<span style=color:#a6e22e>thisValEqualsProxy</span>()); <span style=color:#75715e>// true
</span></code></pre></div><p>从直觉上讲，这样完全没有问题：调用代理上的任何方法，比如 proxy.outerMethod()，而这个方法进而又会调用另一个方法，如 this.innerMethod()，实际上都会调用 proxy.innerMethod()。多数情况下，这是符合预期的行为。可是，如果目标对象依赖于对象标识，那就可能碰到意料之外的问题。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>wm</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>WeakMap</span>();

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>User</span> {
  <span style=color:#a6e22e>constructor</span>(<span style=color:#a6e22e>userId</span>) {
    <span style=color:#a6e22e>wm</span>.<span style=color:#a6e22e>set</span>(<span style=color:#66d9ef>this</span>, <span style=color:#a6e22e>userId</span>);
  }

  <span style=color:#a6e22e>set</span> <span style=color:#a6e22e>id</span>(<span style=color:#a6e22e>userId</span>) {
    <span style=color:#a6e22e>wm</span>.<span style=color:#a6e22e>set</span>(<span style=color:#66d9ef>this</span>, <span style=color:#a6e22e>userId</span>);
  }

  <span style=color:#a6e22e>get</span> <span style=color:#a6e22e>id</span>() {
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>wm</span>.<span style=color:#a6e22e>get</span>(<span style=color:#66d9ef>this</span>);
  }
}
</code></pre></div><p>由于这个实现依赖 User 实例的对象标识，在这个实例被代理的情况下就会出问题：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>user</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>User</span>(<span style=color:#ae81ff>123</span>);
<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>user</span>.<span style=color:#a6e22e>id</span>); <span style=color:#75715e>// 123
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>userInstanceProxy</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Proxy(<span style=color:#a6e22e>user</span>, {});
<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>userInstanceProxy</span>.<span style=color:#a6e22e>id</span>); <span style=color:#75715e>// undefined
</span></code></pre></div><p>这是因为 User 实例一开始使用目标对象作为 WeakMap 的键，代理对象却尝试从自身取得这个实例。要解决这个问题，就需要重新配置代理，把代理 User 实例改为代理 User 类本身。之后再创建代理的实例就会以代理实例作为 WeakMap 的键了：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>UserClassProxy</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Proxy(<span style=color:#a6e22e>User</span>, {});
<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>proxyUser</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>UserClassProxy</span>(<span style=color:#ae81ff>456</span>);
<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>proxyUser</span>.<span style=color:#a6e22e>id</span>);
</code></pre></div><h3 id=代理与内部槽位>代理与内部槽位
<a class=anchor href=#%e4%bb%a3%e7%90%86%e4%b8%8e%e5%86%85%e9%83%a8%e6%a7%bd%e4%bd%8d>#</a></h3><p>代理与内置引用类型（比如 Array）的实例通常可以很好地协同，但有些 ECMAScript 内置类型可能会依赖代理无法控制的机制，结果导致在代理上调用某些方法会出错。</p><p>一个典型的例子就是 Date 类型。根据 ECMAScript 规范，Date 类型方法的执行依赖 this 值上的内部槽位[[NumberDate]]。代理对象上不存在这个内部槽位，而且这个内部槽位的值也不能通过普通的 get()和 set()操作访问到，于是代理拦截后本应转发给目标对象的方法会抛出 TypeError：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>target</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Date();
<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>proxy</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Proxy(<span style=color:#a6e22e>target</span>, {});

<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>proxy</span> <span style=color:#66d9ef>instanceof</span> Date); <span style=color:#75715e>// true
</span><span style=color:#75715e></span>
<span style=color:#a6e22e>proxy</span>.<span style=color:#a6e22e>getDate</span>(); <span style=color:#75715e>// TypeError: &#39;this&#39; is not a Date object
</span></code></pre></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function a(c){const a=window.getSelection(),b=document.createRange();b.selectNodeContents(c),a.removeAllRanges(),a.addRange(b)}document.querySelectorAll("pre code").forEach(b=>{b.addEventListener("click",function(c){a(b.parentElement),navigator.clipboard&&navigator.clipboard.writeText(b.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#创建空代理>创建空代理</a></li><li><a href=#定义捕获器>定义捕获器</a></li><li><a href=#捕获器参数和反射-api>捕获器参数和反射 API</a></li><li><a href=#捕获器不变式>捕获器不变式</a></li><li><a href=#可撤销代理>可撤销代理</a></li><li><a href=#实用反射-api>实用反射 API</a><ul><li><a href=#反射-api-与对象-api>反射 API 与对象 API</a></li><li><a href=#状态标记>状态标记</a></li><li><a href=#用一等函数替代操作符>用一等函数替代操作符</a></li><li><a href=#安全地应用函数>安全地应用函数</a></li></ul></li><li><a href=#代理另一个代理>代理另一个代理</a></li><li><a href=#代理的问题与不足>代理的问题与不足</a><ul><li><a href=#代理中的-this>代理中的 <code>this</code></a></li><li><a href=#代理与内部槽位>代理与内部槽位</a></li></ul></li></ul></nav></div></aside></main></body></html>