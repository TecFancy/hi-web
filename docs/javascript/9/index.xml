<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>代理与反射 on Hi Web</title><link>https://hi-web.io/docs/javascript/9/</link><description>Recent content in 代理与反射 on Hi Web</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><atom:link href="https://hi-web.io/docs/javascript/9/index.xml" rel="self" type="application/rss+xml"/><item><title>代理基础</title><link>https://hi-web.io/docs/javascript/9/9.1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hi-web.io/docs/javascript/9/9.1/</guid><description>代理基础 # 正如本篇开头所介绍的，代理是目标对象的抽象。从很多方面看，代理类似 C++指针，因为它可以用作目标对象的替身，但又完全独立于目标对象。目标对象既可以直接被操作，也可以通过代理来操作。但直接操作会绕过代理施予的行为。
注意 ECMAScript 代理与 C++指针有重大区别，后面会再讨论。不过作为一种有助于理解的类比，指针在概念上还是比较合适的结构。 创建空代理 # 最简单的代理是空代理，即除了作为一个抽象的目标对象，什么也不做。默认情况下，在代理对象上执行的所有操作都会无障碍地传播到目标对象。因此，在任何可以使用目标对象的地方，都可以通过同样的方式来使用与之关联的代理对象。
代理是使用 Proxy 构造函数创建的。这个构造函数接收两个参数：目标对象和处理程序对象。缺少其中任何一个参数都会抛出 TypeError。要创建空代理，可以传一个简单的对象字面量作为处理程序对象，从而让所有操作畅通无阻地抵达目标对象。
如下面的代码所示，在代理对象上执行的任何操作实际上都会应用到目标对象。唯一可感知的不同就是代码中操作的是代理对象。
const target = { id: &amp;#34;target&amp;#34;, }; const handler = {}; const proxy = new Proxy(target, handler); // id属性会访问同一个值 console.log(target.id); // target console.log(proxy.id); // target // 给目标属性赋值会反映在两个对象上 // 因为两个对象访问的是同一个值 target.id = &amp;#34;foo&amp;#34;; console.log(target.id); // foo console.log(proxy.id); // foo // 给代理属性赋值会反映在两个对象上 // 因为这个赋值会转移到目标对象 proxy.id = &amp;#34;bar&amp;#34;; console.log(target.id); // bar console.log(proxy.id); // bar // hasOwnProperty()方法在两个地方 // 都会应用到目标对象 console.</description></item></channel></rss>