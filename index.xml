<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Introduction on Hi Web</title><link>https://hi-web.io/</link><description>Recent content in Introduction on Hi Web</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><atom:link href="https://hi-web.io/index.xml" rel="self" type="application/rss+xml"/><item><title>&lt;script> 元素</title><link>https://hi-web.io/docs/javascript/2/2.1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hi-web.io/docs/javascript/2/2.1/</guid><description>&amp;lt;script&amp;gt; 元素 # 将 JavaScript 插入 HTML 的主要方法是使用元素。这个元素是由网景公司创造出来，并最早在 Netscape Navigator 2 中实现的。后来，这个元素被正式加入到 HTML 规范。元素有下列 8 个属性。
async：可选。表示应该立即开始下载脚本，但不能阻止其他页面动作，比如下载资源或等待其他脚本加载。只对外部脚本文件有效。 charset：可选。使用 src 属性指定的代码字符集。这个属性很少使用，因为大多数浏览器不在乎它的值。 crossorigin：可选。配置相关请求的 CORS（跨源资源共享）设置。默认不使用 CORS。crossorigin=&amp;ldquo;anonymous&amp;quot;配置文件请求不必设置凭据标志。crossorigin=&amp;ldquo;use-credentials&amp;quot;设置凭据标志，意味着出站请求会包含凭据。 defer：可选。表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。在 IE7 及更早的版本中，对行内脚本也可以指定这个属性。 integrity：可选。允许比对接收到的资源和指定的加密签名以验证子资源完整性（SRI，Subresource Integrity）。如果接收到的资源的签名与这个属性指定的签名不匹配，则页面会报错，脚本不会执行。这个属性可以用于确保内容分发网络（CDN，Content Delivery Network）不会提供恶意内容。 language：废弃。最初用于表示代码块中的脚本语言（如&amp;quot;JavaScript&amp;rdquo;、&amp;ldquo;JavaScript 1.2&amp;quot;或&amp;quot;VBScript&amp;rdquo;）。大多数浏览器都会忽略这个属性，不应该再使用它。 src：可选。表示包含要执行的代码的外部文件。 type：可选。代替 language，表示代码块中脚本语言的内容类型（也称 MIME 类型）。按照惯例，这个值始终都是&amp;quot;text/javascript&amp;rdquo;，尽管&amp;quot;text/javascript&amp;quot;和&amp;quot;text/ecmascript&amp;quot;都已经废弃了。JavaScript 文件的 MIME 类型通常是&amp;quot;application/x-javascript&amp;quot;，不过给 type 属性这个值有可能导致脚本被忽略。在非 IE 的浏览器中有效的其他值还有&amp;quot;application/javascript&amp;quot;和&amp;quot;application/ecmascript&amp;quot;。如果这个值是 module，则代码会被当成 ES6 模块，而且只有这时候代码中才能出现 import 和 export 关键字。 使用 &amp;lt;script&amp;gt; 的方式有两种：通过它直接在网页中嵌入 JavaScript 代码，以及通过它在网页中包含外部 JavaScript 文件。
要嵌入行内 JavaScript 代码，直接把代码放在 &amp;lt;script&amp;gt; 元素中就行：
&amp;lt;script&amp;gt; function sayHi() { console.</description></item><item><title>Date</title><link>https://hi-web.io/docs/javascript/5/5.1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hi-web.io/docs/javascript/5/5.1/</guid><description>Date # ECMAScript 的 Date 类型参考了 Java 早期版本中的 java.util.Date。为此，Date 类型将日期保存为自协调世界时（UTC，Universal Time Coordinated）时间 1970 年 1 月 1 日午夜（零时）至今所经过的毫秒数。使用这种存储格式，Date 类型可以精确表示 1970 年 1 月 1 日之前及之后 285 616 年的日期。
要创建日期对象，就使用 new 操作符来调用 Date 构造函数：
let now = new Date(); 在不给 Date 构造函数传参数的情况下，创建的对象将保存当前日期和时间。要基于其他日期和时间创建日期对象，必须传入其毫秒表示（UNIX 纪元 1970 年 1 月 1 日午夜之后的毫秒数）。ECMAScript 为此提供了两个辅助方法：Date.parse()和 Date.UTC()。
Date.parse()方法接收一个表示日期的字符串参数，尝试将这个字符串转换为表示该日期的毫秒数。ECMA-262 第 5 版定义了 Date.parse()应该支持的日期格式，填充了第 3 版遗留的空白。所有实现都必须支持下列日期格式：
“月/日/年”，如&amp;quot;5/23/2019&amp;quot;； “月名 日, 年”，如&amp;quot;May 23, 2019&amp;quot;； “周几 月名 日 年 时:分:秒 时区”，如&amp;quot;Tue May 23 2019 00:00:00 GMT-0700&amp;quot;； ISO 8601 扩展格式“YYYY-MM-DDTHH:mm:ss.</description></item><item><title>Object</title><link>https://hi-web.io/docs/javascript/6/6.1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hi-web.io/docs/javascript/6/6.1/</guid><description>Object # 到目前为止，大多数引用值的示例使用的是 Object 类型。Object 是 ECMAScript 中最常用的类型之一。虽然 Object 的实例没有多少功能，但很适合存储和在应用程序间交换数据。
显式地创建 Object 的实例有两种方式。第一种是使用 new 操作符和 Object 构造函数，如下所示：
let person = new Object(); person.name = &amp;#34;Nicholas&amp;#34;; person.age = 29; 另一种方式是使用对象字面量（object literal）表示法。对象字面量是对象定义的简写形式，目的是为了简化包含大量属性的对象的创建。比如，下面的代码定义了与前面示例相同的 person 对象，但使用的是对象字面量表示法：
let person = { name: &amp;#34;Nicholas&amp;#34;, age: 29, }; 在这个例子中，左大括号（{）表示对象字面量开始，因为它出现在一个表达式上下文（expression context）中。在 ECMAScript 中，表达式上下文指的是期待返回值的上下文。赋值操作符表示后面要期待一个值，因此左大括号表示一个表达式的开始。同样是左大括号，如果出现在语句上下文（statement context）中，比如 if 语句的条件后面，则表示一个语句块的开始。
接下来指定了 name 属性，后跟一个冒号，然后是属性的值。逗号用于在对象字面量中分隔属性，因此字符串&amp;quot;Nicholas&amp;quot;后面有一个逗号，而 29 后面没有，因为 age 是这个对象的最后一个属性。在最后一个属性后面加上逗号在非常老的浏览器中会导致报错，但所有现代浏览器都支持这种写法。
在对象字面量表示法中，属性名可以是字符串或数值，比如：
let person = { name: &amp;#34;Nicholas&amp;#34;, age: 29, 5: true, }; 这个例子会得到一个带有属性 name、age 和 5 的对象。注意，数值属性会自动转换为字符串。</description></item><item><title>代理基础</title><link>https://hi-web.io/docs/javascript/9/9.1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hi-web.io/docs/javascript/9/9.1/</guid><description>代理基础 # 正如本篇开头所介绍的，代理是目标对象的抽象。从很多方面看，代理类似 C++指针，因为它可以用作目标对象的替身，但又完全独立于目标对象。目标对象既可以直接被操作，也可以通过代理来操作。但直接操作会绕过代理施予的行为。
注意 ECMAScript 代理与 C++指针有重大区别，后面会再讨论。不过作为一种有助于理解的类比，指针在概念上还是比较合适的结构。 创建空代理 # 最简单的代理是空代理，即除了作为一个抽象的目标对象，什么也不做。默认情况下，在代理对象上执行的所有操作都会无障碍地传播到目标对象。因此，在任何可以使用目标对象的地方，都可以通过同样的方式来使用与之关联的代理对象。
代理是使用 Proxy 构造函数创建的。这个构造函数接收两个参数：目标对象和处理程序对象。缺少其中任何一个参数都会抛出 TypeError。要创建空代理，可以传一个简单的对象字面量作为处理程序对象，从而让所有操作畅通无阻地抵达目标对象。
如下面的代码所示，在代理对象上执行的任何操作实际上都会应用到目标对象。唯一可感知的不同就是代码中操作的是代理对象。
const target = { id: &amp;#34;target&amp;#34;, }; const handler = {}; const proxy = new Proxy(target, handler); // id属性会访问同一个值 console.log(target.id); // target console.log(proxy.id); // target // 给目标属性赋值会反映在两个对象上 // 因为两个对象访问的是同一个值 target.id = &amp;#34;foo&amp;#34;; console.log(target.id); // foo console.log(proxy.id); // foo // 给代理属性赋值会反映在两个对象上 // 因为这个赋值会转移到目标对象 proxy.id = &amp;#34;bar&amp;#34;; console.log(target.id); // bar console.log(proxy.id); // bar // hasOwnProperty()方法在两个地方 // 都会应用到目标对象 console.</description></item><item><title>原始值与引用值</title><link>https://hi-web.io/docs/javascript/4/4.1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hi-web.io/docs/javascript/4/4.1/</guid><description>原始值与引用值 # ECMAScript 变量可以包含两种不同类型的数据：原始值和引用值。原始值（primitive value）就是最简单的数据，引用值（reference value）则是由多个值构成的对象。
在把一个值赋给变量时，JavaScript 引擎必须确定这个值是原始值还是引用值。上一章讨论了 6 种原始值：Undefined、Null、Boolean、Number、String 和 Symbol。保存原始值的变量是按值（by value）访问的，因为我们操作的就是存储在变量中的实际值。
引用值是保存在内存中的对象。与其他语言不同，JavaScript 不允许直接访问内存位置，因此也就不能直接操作对象所在的内存空间。在操作对象时，实际上操作的是对该对象的引用（reference）而非实际的对象本身。为此，保存引用值的变量是按引用（by reference）访问的。
注意 在很多语言中，字符串是使用对象表示的，因此被认为是引用类型。ECMAScript 打破了这个惯例。 动态属性 # 原始值和引用值的定义方式很类似，都是创建一个变量，然后给它赋一个值。不过，在变量保存了这个值之后，可以对这个值做什么，则大有不同。对于引用值而言，可以随时添加、修改和删除其属性和方法。比如，看下面的例子：
let person = new Object(); person.name = &amp;#34;Nicholas&amp;#34;; console.log(person.name); // &amp;#34;Nicholas&amp;#34; 这里，首先创建了一个对象，并把它保存在变量 person 中。然后，给这个对象添加了一个名为 name 的属性，并给这个属性赋值了一个字符串&amp;quot;Nicholas&amp;quot;。在此之后，就可以访问这个新属性，直到对象被销毁或属性被显式地删除。
原始值不能有属性，尽管尝试给原始值添加属性不会报错。比如：
let name = &amp;#34;Nicholas&amp;#34;; name.age = 27; console.log(name.age); // undefined 在此，代码想给字符串 name 定义一个 age 属性并给该属性赋值 27。紧接着在下一行，属性不见了。记住，只有引用值可以动态添加后面可以使用的属性。
注意，原始类型的初始化可以只使用原始字面量形式。如果使用的是 new 关键字，则 JavaScript 会创建一个 Object 类型的实例，但其行为类似原始值。下面来看看这两种初始化方式的差异：
let name1 = &amp;#34;Nicholas&amp;#34;; let name2 = new String(&amp;#34;Matt&amp;#34;); name1.</description></item><item><title>理解对象</title><link>https://hi-web.io/docs/javascript/8/8.1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hi-web.io/docs/javascript/8/8.1/</guid><description>理解对象 # 创建自定义对象的通常方式是创建 Object 的一个新实例，然后再给它添加属性和方法，如下例所示：
let person = new Object(); person.name = &amp;#34;Nicholas&amp;#34;; person.age = 29; person.job = &amp;#34;Software Engineer&amp;#34;; person.sayName = function () { console.log(this.name); }; 这个例子创建了一个名为 person 的对象，而且有三个属性（name、age 和 job）和一个方法（sayName()）。sayName()方法会显示 this.name 的值，这个属性会解析为 person.name。早期 JavaScript 开发者频繁使用这种方式创建新对象。几年后，对象字面量变成了更流行的方式。前面的例子如果使用对象字面量则可以这样写：
let person = { name: &amp;#34;Nicholas&amp;#34;, age: 29, job: &amp;#34;Software Engineer&amp;#34;, sayName() { console.log(this.name); }, }; 这个例子中的 person 对象跟前面例子中的 person 对象是等价的，它们的属性和方法都一样。这些属性都有自己的特征，而这些特征决定了它们在 JavaScript 中的行为。
属性的类型 # ECMA-262 使用一些内部特性来描述属性的特征。这些特性是由为 JavaScript 实现引擎的规范定义的。因此，开发者不能在 JavaScript 中直接访问这些特性。为了将某个特性标识为内部特性，规范会用两个中括号把特性的名称括起来，比如[[Enumerable]]。</description></item><item><title>理解迭代</title><link>https://hi-web.io/docs/javascript/7/7.1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hi-web.io/docs/javascript/7/7.1/</guid><description>理解迭代 # 在 JavaScript 中，计数循环就是一种最简单的迭代：
for (let i = 1; i &amp;lt;= 10; ++i) { console.log(i); } 循环是迭代机制的基础，这是因为它可以指定迭代的次数，以及每次迭代要执行什么操作。每次循环都会在下一次迭代开始之前完成，而每次迭代的顺序都是事先定义好的。
迭代会在一个有序集合上进行。（“有序”可以理解为集合中所有项都可以按照既定的顺序被遍历到，特别是开始和结束项有明确的定义。）数组是 JavaScript 中有序集合的最典型例子。
let collection = [&amp;#34;foo&amp;#34;, &amp;#34;bar&amp;#34;, &amp;#34;baz&amp;#34;]; for (let index = 0; index &amp;lt; collection.length; ++index) { console.log(collection[index]); } 因为数组有已知的长度，且数组每一项都可以通过索引获取，所以整个数组可以通过递增索引来遍历。
由于如下原因，通过这种循环来执行例程并不理想。
迭代之前需要事先知道如何使用数据结构。数组中的每一项都只能先通过引用取得数组对象，然后再通过[]操作符取得特定索引位置上的项。这种情况并不适用于所有数据结构。 遍历顺序并不是数据结构固有的。通过递增索引来访问数据是特定于数组类型的方式，并不适用于其他具有隐式顺序的数据结构。 ES5 新增了 Array.prototype.forEach()方法，向通用迭代需求迈进了一步（但仍然不够理想）：
let collection = [&amp;#34;foo&amp;#34;, &amp;#34;bar&amp;#34;, &amp;#34;baz&amp;#34;]; collection.forEach((item) =&amp;gt; console.log(item)); // foo // bar // baz 这个方法解决了单独记录索引和通过数组对象取得值的问题。不过，没有办法标识迭代何时终止。因此这个方法只适用于数组，而且回调结构也比较笨拙。
在 ECMAScript 较早的版本中，执行迭代必须使用循环或其他辅助结构。随着代码量增加，代码会变得越发混乱。很多语言都通过原生语言结构解决了这个问题，开发者无须事先知道如何迭代就能实现迭代操作。这个解决方案就是迭代器模式。Python、Java、C++，还有其他很多语言都对这个模式提供了完备的支持。JavaScript 在 ECMAScript 6 以后也支持了迭代器模式。</description></item><item><title>简短的历史回顾</title><link>https://hi-web.io/docs/javascript/1/1.1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hi-web.io/docs/javascript/1/1.1/</guid><description>简短的历史回顾 # 随着 Web 日益流行，对客户端脚本语言的需求也越来越强烈。当时，大多数用户使用 28.8kbit/s 的调制解调器上网，但网页变得越来越大、越来越复杂。为验证简单的表单而需要大量与服务器的往返通信成为用户的痛点。想象一下，你填写完表单，单击“提交”按钮，等 30 秒处理，然后看到一条消息，告诉你有一个必填字段没填。网景在当时是引领技术革新的公司，它将开发一个客户端脚本语言来处理这种简单的数据验证提上了日程。
1995 年，网景公司一位名叫 Brendan Eich 的工程师，开始为即将发布的 Netscape Navigator 2 开发一个叫 Mocha（后来改名为 LiveScript）的脚本语言。当时的计划是在客户端和服务器端都使用它，它在服务器端叫 LiveWire。
为了赶上发布时间，网景与 Sun 公司结为开发联盟，共同完成 LiveScript 的开发。就在 Netscape Navigator 2 正式发布前，网景把 LiveScript 改名为 JavaScript，以便搭上媒体当时热烈炒作 Java 的顺风车。
由于 JavaScript 1.0 很成功，网景又在 Netscape Navigator 3 中发布了 1.1 版本。尚未成熟的 Web 的受欢迎程度创造了历史新高，而网景则稳居市场领导者的位置。这时候，微软决定向 IE 投入更多资源。就在 Netscape Navigator 3 发布后不久，微软发布了 IE3，其中包含自己名为 JScript（叫这个名字是为了避免与网景发生许可纠纷）的 JavaScript 实现。1996 年 8 月，微软重磅进入 Web 浏览器领域，这是网景永远的痛，但它代表 JavaScript 作为一门语言向前迈进了一大步。
微软的 JavaScript 实现意味着出现了两个版本的 JavaScript：Netscape Navigator 中的 JavaScript，以及 IE 中的 JScript。与 C 语言以及很多其他编程语言不同，JavaScript 还没有规范其语法或特性的标准，两个版本并存让这个问题更加突出了。随着业界担忧日甚，JavaScript 终于踏上了标准化的征程。</description></item><item><title>语法</title><link>https://hi-web.io/docs/javascript/3/3.1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hi-web.io/docs/javascript/3/3.1/</guid><description>语法 # ECMAScript 的语法很大程度上借鉴了 C 语言和其他类 C 语言，如 Java 和 Perl。熟悉这些语言的开发者，应该很容易理解 ECMAScript 宽松的语法。
区分大小写 # 首先要知道的是，ECMAScript 中一切都区分大小写。无论是变量、函数名还是操作符，都区分大小写。换句话说，变量 test 和变量 Test 是两个不同的变量。类似地，typeof 不能作为函数名，因为它是一个关键字（后面会介绍）。但 Typeof 是一个完全有效的函数名。
标识符 # 所谓标识符，就是变量、函数、属性或函数参数的名称。标识符可以由一或多个下列字符组成：
第一个字符必须是一个字母、下划线（_）或美元符号（$）；
剩下的其他字符可以是字母、下划线、美元符号或数字。 标识符中的字母可以是扩展 ASCII（Extended ASCII）中的字母，也可以是 Unicode 的字母字符，如 À 和 Æ（但不推荐使用）。 按照惯例，ECMAScript 标识符使用驼峰大小写形式，即第一个单词的首字母小写，后面每个单词的首字母大写，如：
firstSecond myCar doSomethingImportant 虽然这种写法并不是强制性的，但因为这种形式跟 ECMAScript 内置函数和对象的命名方式一致，所以算是最佳实践。
注意 关键字、保留字、true、false 和 null 不能作为标识符。具体内容请参考 3.2 节。 注释 # ECMAScript 采用 C 语言风格的注释，包括单行注释和块注释。单行注释以两个斜杠字符开头，如：
// 单行注释 块注释以一个斜杠和一个星号（/）开头，以它们的反向组合（/）结尾，如：
/* 这是多行 注释 */ 严格模式 # ECMAScript 5 增加了严格模式（strict mode）的概念。严格模式是一种不同的 JavaScript 解析和执行模型，ECMAScript 3 的一些不规范写法在这种模式下会被处理，对于不安全的活动将抛出错误。要对整个脚本启用严格模式，在脚本开头加上这一行：</description></item><item><title>JavaScript 实现</title><link>https://hi-web.io/docs/javascript/1/1.2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hi-web.io/docs/javascript/1/1.2/</guid><description>JavaScript 实现 # 虽然 JavaScript 和 ECMAScript 基本上是同义词，但 JavaScript 远远不限于 ECMA-262 所定义的那样。没错，完整的 JavaScript 实现包含以下几个部分（见图 1-1）：
核心（ECMAScript） 文档对象模型（DOM） 浏览器对象模型（BOM） ECMAScript # ECMAScript，即 ECMA-262 定义的语言，并不局限于 Web 浏览器。事实上，这门语言没有输入和输出之类的方法。ECMA-262 将这门语言作为一个基准来定义，以便在它之上再构建更稳健的脚本语言。Web 浏览器只是 ECMAScript 实现可能存在的一种宿主环境（host environment）。宿主环境提供 ECMAScript 的基准实现和与环境自身交互必需的扩展。扩展（比如 DOM）使用 ECMAScript 核心类型和语法，提供特定于环境的额外功能。其他宿主环境还有服务器端 JavaScript 平台 Node.js 和即将被淘汰的 Adobe Flash。
如果不涉及浏览器的话，ECMA-262 到底定义了什么？在基本的层面，它描述这门语言的如下部分：
语法 类型 语句 关键字 保留字 操作符 全局对象 ECMAScript 只是对实现这个规范描述的所有方面的一门语言的称呼。JavaScript 实现了 ECMAScript，而 Adobe ActionScript 同样也实现了 ECMAScript。
ECMAScript 版本 # ECMAScript 不同的版本以“edition”表示（也就是描述特定实现的 ECMA-262 的版本）。ECMA-262 最近的版本是第 10 版，发布于 2019 年 6 月。ECMA-262 的第 1 版本质上跟网景的 JavaScript 1.</description></item><item><title>行内代码与外部文件</title><link>https://hi-web.io/docs/javascript/2/2.2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hi-web.io/docs/javascript/2/2.2/</guid><description>行内代码与外部文件 # 虽然可以直接在 HTML 文件中嵌入 JavaScript 代码，但通常认为最佳实践是尽可能将 JavaScript 代码放在外部文件中。不过这个最佳实践并不是明确的强制性规则。推荐使用外部文件的理由如下。
可维护性。JavaScript 代码如果分散到很多 HTML 页面，会导致维护困难。而用一个目录保存所有 JavaScript 文件，则更容易维护，这样开发者就可以独立于使用它们的 HTML 页面来编辑代码。 缓存。浏览器会根据特定的设置缓存所有外部链接的 JavaScript 文件，这意味着如果两个页面都用到同一个文件，则该文件只需下载一次。这最终意味着页面加载更快。 适应未来。通过把 JavaScript 放到外部文件中，就不必考虑用 XHTML 或前面提到的注释黑科技。包含外部 JavaScript 文件的语法在 HTML 和 XHTML 中是一样的。 在配置浏览器请求外部文件时，要重点考虑的一点是它们会占用多少带宽。在 SPDY/HTTP2 中，预请求的消耗已显著降低，以轻量、独立 JavaScript 组件形式向客户端送达脚本更具优势。
比如，第一个页面包含如下脚本：
&amp;lt;script src=&amp;#34;mainA.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script src=&amp;#34;component1.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script src=&amp;#34;component2.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script src=&amp;#34;component3.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; ... 后续页面可能包含如下脚本：
&amp;lt;script src=&amp;#34;mainB.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script src=&amp;#34;component3.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script src=&amp;#34;component4.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script src=&amp;#34;component5.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; ... 在初次请求时，如果浏览器支持 SPDY/HTTP2，就可以从同一个地方取得一批文件，并将它们逐个放到浏览器缓存中。从浏览器角度看，通过 SPDY/HTTP2 获取所有这些独立的资源与获取一个大 JavaScript 文件的延迟差不多。
在第二个页面请求时，由于你已经把应用程序切割成了轻量可缓存的文件，第二个页面也依赖的某些组件此时已经存在于浏览器缓存中了。
当然，这里假设浏览器支持 SPDY/HTTP2，只有比较新的浏览器才满足。如果你还想支持那些比较老的浏览器，可能还是用一个大文件更合适。</description></item><item><title>JavaScript 版本</title><link>https://hi-web.io/docs/javascript/1/1.3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hi-web.io/docs/javascript/1/1.3/</guid><description>JavaScript 版本 # 作为网景的继承者，Mozilla 是唯一仍在延续最初 JavaScript 版本编号的浏览器厂商。当初网景在将其源代码开源时（项目名为 Mozilla Project），JavaScript 在其浏览器中最后的版本是 1.3。（前面提到过，1.4 版是专门为服务器实现的。）因为 Mozilla Foundation 在持续开发 JavaScript，为它增加新特性、关键字和语法，所以 JavaScript 的版本号也在不断递增。下表展示了 Netscape/Mozilla 浏览器发布的历代 JavaScript 版本。
浏览器 JavaScript 版本 Netscape Navigator 2 1.0 Netscape Navigator 3 1.1 Netscape Navigator 4 1.2 Netscape Navigator 4.06 1.3 Netscape 6+（Mozilla 0.6.0+） 1.5 Firefox 1 1.5 Firefox 1.5 1.</description></item><item><title>文档模式</title><link>https://hi-web.io/docs/javascript/2/2.3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hi-web.io/docs/javascript/2/2.3/</guid><description>文档模式 # IE5.5 发明了文档模式的概念，即可以使用 doctype 切换文档模式。最初的文档模式有两种：混杂模式（quirks mode）和标准模式（standards mode）。前者让 IE 像 IE5 一样（支持一些非标准的特性），后者让 IE 具有兼容标准的行为。虽然这两种模式的主要区别只体现在通过 CSS 渲染的内容方面，但对 JavaScript 也有一些关联影响，或称为副作用。
IE 初次支持文档模式切换以后，其他浏览器也跟着实现了。随着浏览器的普遍实现，又出现了第三种文档模式：准标准模式（almost standards mode）。这种模式下的浏览器支持很多标准的特性，但是没有标准规定得那么严格。主要区别在于如何对待图片元素周围的空白（在表格中使用图片时最明显）。
混杂模式在所有浏览器中都以省略文档开头的 doctype 声明作为开关。这种约定并不合理，因为混杂模式在不同浏览器中的差异非常大，不使用黑科技基本上就没有浏览器一致性可言。
标准模式通过下列几种文档类型声明开启：
&amp;lt;!-- HTML 4.01 Strict --&amp;gt; &amp;lt;!DOCTYPE html PUBLIC &amp;#34;-//W3C//DTD HTML 4.01//EN&amp;#34; &amp;#34;http://www.w3.org/TR/html4/strict.dtd&amp;#34;&amp;gt; &amp;lt;!-- XHTML 1.0 Strict --&amp;gt; &amp;lt;!DOCTYPE html PUBLIC &amp;#34;-//W3C//DTD XHTML 1.0 Strict//EN&amp;#34; &amp;#34;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&amp;#34;&amp;gt; &amp;lt;!-- HTML5 --&amp;gt; &amp;lt;!DOCTYPE html&amp;gt; 准标准模式通过过渡性文档类型（Transitional）和框架集文档类型（Frameset）来触发：
&amp;lt;!-- HTML 4.01 Transitional --&amp;gt; &amp;lt;!DOCTYPE html PUBLIC &amp;#34;-//W3C//DTD HTML 4.01 Transitional//EN&amp;#34; &amp;#34;http://www.</description></item><item><title>&lt;noscript> 元素</title><link>https://hi-web.io/docs/javascript/2/2.4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hi-web.io/docs/javascript/2/2.4/</guid><description>&amp;lt;noscript&amp;gt; 元素 # 针对早期浏览器不支持 JavaScript 的问题，需要一个页面优雅降级的处理方案。最终，&amp;lt;noscript&amp;gt; 元素出现，被用于给不支持 JavaScript 的浏览器提供替代内容。虽然如今的浏览器已经 100%支持 JavaScript，但对于禁用 JavaScript 的浏览器来说，这个元素仍然有它的用处。
&amp;lt;noscript&amp;gt; 元素可以包含任何可以出现在 &amp;lt;body&amp;gt; 中的 HTML 元素，&amp;lt;script&amp;gt; 除外。在下列两种情况下，浏览器将显示包含在 &amp;lt;noscript&amp;gt; 中的内容：
浏览器不支持脚本； 浏览器对脚本的支持被关闭。 任何一个条件被满足，包含在 &amp;lt;noscript&amp;gt; 中的内容就会被渲染。否则，浏览器不会渲染 &amp;lt;noscript&amp;gt; 中的内容。
下面是一个例子：
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;Example HTML Page&amp;lt;/title&amp;gt; &amp;lt;script defer=&amp;#34;defer&amp;#34; src=&amp;#34;example1.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script defer=&amp;#34;defer&amp;#34; src=&amp;#34;example2.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;noscript&amp;gt; &amp;lt;p&amp;gt;This page requires a JavaScript-enabled browser.&amp;lt;/p&amp;gt; &amp;lt;/noscript&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 这个例子是在脚本不可用时让浏览器显示一段话。如果浏览器支持脚本，则用户永远不会看到它。</description></item><item><title>小结</title><link>https://hi-web.io/docs/javascript/1/1.4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hi-web.io/docs/javascript/1/1.4/</guid><description>小结 # JavaScript 是一门用来与网页交互的脚本语言，包含以下三个组成部分。
ECMAScript：由 ECMA-262 定义并提供核心功能。 文档对象模型（DOM）：提供与网页内容交互的方法和接口。 浏览器对象模型（BOM）：提供与浏览器交互的方法和接口。 JavaScript 的这三个部分得到了五大 Web 浏览器（IE、Firefox、Chrome、Safari 和 Opera）不同程度的支持。所有浏览器基本上对 ES5（ECMAScript 5）提供了完善的支持，而对 ES6（ECMAScript 6）和 ES7（ECMAScript 7）的支持度也在不断提升。这些浏览器对 DOM 的支持各不相同，但对 Level 3 的支持日益趋于规范。HTML5 中收录的 BOM 会因浏览器而异，不过开发者仍然可以假定存在很大一部分公共特性。</description></item><item><title>小结</title><link>https://hi-web.io/docs/javascript/2/2.5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hi-web.io/docs/javascript/2/2.5/</guid><description>小结 # JavaScript 是通过 &amp;lt;script&amp;gt; 元素插入到 HTML 页面中的。这个元素可用于把 JavaScript 代码嵌入到 HTML 页面中，跟其他标记混合在一起，也可用于引入保存在外部文件中的 JavaScript。本篇的重点可以总结如下。
要包含外部 JavaScript 文件，必须将 src 属性设置为要包含文件的 URL。文件可以跟网页在同一台服务器上，也可以位于完全不同的域。 所有 &amp;lt;script&amp;gt; 元素会依照它们在网页中出现的次序被解释。在不使用 defer 和 async 属性的情况下，包含在 &amp;lt;script&amp;gt; 元素中的代码必须严格按次序解释。 对不推迟执行的脚本，浏览器必须解释完位于 &amp;lt;script&amp;gt; 元素中的代码，然后才能继续渲染页面的剩余部分。为此，通常应该把 &amp;lt;script&amp;gt; 元素放到页面末尾，介于主内容之后及 &amp;lt;/body&amp;gt; 标签之前。 可以使用 defer 属性把脚本推迟到文档渲染完毕后再执行。推迟的脚本原则上按照它们被列出的次序执行。 可以使用 async 属性表示脚本不需要等待其他脚本，同时也不阻塞文档渲染，即异步加载。异步脚本不能保证按照它们在页面中出现的次序执行。 -通过使用 &amp;lt;noscript&amp;gt; 元素，可以指定在浏览器不支持脚本时显示的内容。如果浏览器支持并启用脚本，则 &amp;lt;noscript&amp;gt; 元素中的任何内容都不会被渲染。</description></item><item><title>箭头函数</title><link>https://hi-web.io/docs/javascript/10/10.1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hi-web.io/docs/javascript/10/10.1/</guid><description>箭头函数 # ECMAScript 6 新增了使用胖箭头（=&amp;gt;）语法定义函数表达式的能力。很大程度上，箭头函数实例化的函数对象与正式的函数表达式创建的函数对象行为是相同的。任何可以使用函数表达式的地方，都可以使用箭头函数：
let arrowSum = (a, b) =&amp;gt; { return a + b; }; let functionExpressionSum = function (a, b) { return a + b; }; console.log(arrowSum(5, 8)); // 13 console.log(functionExpressionSum(5, 8)); // 13 箭头函数简洁的语法非常适合嵌入函数的场景：
let ints = [1, 2, 3]; console.log( ints.map(function (i) { return i + 1; }) ); // [2, 3, 4] console.log( ints.map((i) =&amp;gt; { return i + 1; }) ); // [2, 3, 4] 如果只有一个参数，那也可以不用括号。只有没有参数，或者多个参数的情况下，才需要使用括号：</description></item><item><title>异步编程</title><link>https://hi-web.io/docs/javascript/11/11.1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hi-web.io/docs/javascript/11/11.1/</guid><description>异步编程 # 同步行为和异步行为的对立统一是计算机科学的一个基本概念。特别是在 JavaScript 这种单线程事件循环模型中，同步操作与异步操作更是代码所要依赖的核心机制。异步行为是为了优化因计算量大而时间长的操作。如果在等待其他操作完成的同时，即使运行其他指令，系统也能保持稳定，那么这样做就是务实的。
重要的是，异步操作并不一定计算量大或要等很长时间。只要你不想为等待某个异步操作而阻塞线程执行，那么任何时候都可以使用。
同步与异步 # 同步行为对应内存中顺序执行的处理器指令。每条指令都会严格按照它们出现的顺序来执行，而每条指令执行后也能立即获得存储在系统本地（如寄存器或系统内存）的信息。这样的执行流程容易分析程序在执行到代码任意位置时的状态（比如变量的值）。
同步操作的例子可以是执行一次简单的数学计算：
let x = 3; x = x + 4; 在程序执行的每一步，都可以推断出程序的状态。这是因为后面的指令总是在前面的指令完成后才会执行。等到最后一条指定执行完毕，存储在 x 的值就立即可以使用。
这两行 JavaScript 代码对应的低级指令（从 JavaScript 到 x86）并不难想象。首先，操作系统会在栈内存上分配一个存储浮点数值的空间，然后针对这个值做一次数学计算，再把计算结果写回之前分配的内存中。所有这些指令都是在单个线程中按顺序执行的。在低级指令的层面，有充足的工具可以确定系统状态。
相对地，异步行为类似于系统中断，即当前进程外部的实体可以触发代码执行。异步操作经常是必要的，因为强制进程等待一个长时间的操作通常是不可行的（同步操作则必须要等）。如果代码要访问一些高延迟的资源，比如向远程服务器发送请求并等待响应，那么就会出现长时间的等待。
异步操作的例子可以是在定时回调中执行一次简单的数学计算：
let x = 3; setTimeout(() =&amp;gt; (x = x + 4), 1000); 这段程序最终与同步代码执行的任务一样，都是把两个数加在一起，但这一次执行线程不知道 x 值何时会改变，因为这取决于回调何时从消息队列出列并执行。
异步代码不容易推断。虽然这个例子对应的低级代码最终跟前面的例子没什么区别，但第二个指令块（加操作及赋值操作）是由系统计时器触发的，这会生成一个入队执行的中断。到底什么时候会触发这个中断，这对 JavaScript 运行时来说是一个黑盒，因此实际上无法预知（尽管可以保证这发生在当前线程的同步代码执行之后，否则回调都没有机会出列被执行）。无论如何，在排定回调以后基本没办法知道系统状态何时变化。
为了让后续代码能够使用 x，异步执行的函数需要在更新 x 的值以后通知其他代码。如果程序不需要这个值，那么就只管继续执行，不必等待这个结果了。
设计一个能够知道 x 什么时候可以读取的系统是非常难的。JavaScript 在实现这样一个系统的过程中也经历了几次迭代。
以往的异步编程模式 # 异步行为是 JavaScript 的基础，但以前的实现不理想。在早期的 JavaScript 中，只支持定义回调函数来表明异步操作完成。串联多个异步操作是一个常见的问题，通常需要深度嵌套的回调函数（俗称“回调地狱”）来解决。
假设有以下异步函数，使用了 setTimeout 在一秒钟之后执行某些操作：
function double(value) { setTimeout(() =&amp;gt; setTimeout(console.</description></item><item><title>window 对象</title><link>https://hi-web.io/docs/javascript/12/12.1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hi-web.io/docs/javascript/12/12.1/</guid><description>window 对象 # BOM 的核心是 window 对象，表示浏览器的实例。window 对象在浏览器中有两重身份，一个是 ECMAScript 中的 Global 对象，另一个就是浏览器窗口的 JavaScript 接口。这意味着网页中定义的所有对象、变量和函数都以 window 作为其 Global 对象，都可以访问其上定义的 parseInt()等全局方法。
注意 因为 window 对象的属性在全局作用域中有效，所以很多浏览器 API 及相关构造函数都以 window 对象属性的形式暴露出来。这些 API 将在全书各章中介绍，特别是第 20 章。
另外，由于实现不同，某些 window 对象的属性在不同浏览器间可能差异很大。本篇不会介绍已经废弃的、非标准化或特定于浏览器的 window 属性。
Global 作用域 # 因为 window 对象被复用为 ECMAScript 的 Global 对象，所以通过 var 声明的所有全局变量和函数都会变成 window 对象的属性和方法。比如：
var age = 29; var sayAge = () =&amp;gt; alert(this.age); alert(window.age); // 29 sayAge(); // 29 window.sayAge(); // 29 这里，变量 age 和函数 sayAge()被定义在全局作用域中，它们自动成为了 window 对象的成员。因此，变量 age 可以通过 window.</description></item></channel></rss>